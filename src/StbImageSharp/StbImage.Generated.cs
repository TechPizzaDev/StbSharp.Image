// Generated by Sichem at 1/6/2018 7:16:35 PM

using System;
using System.IO;
using System.IO.Compression;
using System.Runtime.InteropServices;
using System.Threading;

namespace StbSharp
{
    public static unsafe partial class StbImage
    {
        // TODO move to the ReadContext
        public static int stbi__unpremultiply_on_load = 1;
        public static int stbi__de_iphone_flag = 1;

        public class ReadContext
        {
            public readonly Stream Stream;
            public readonly byte[] ReadBuffer; 
            public readonly CancellationToken Cancellation;

            public readonly ReadCallback Read;
            public readonly SkipCallback Skip;
            public bool ReadFromCallbacks;

            public uint W;
            public uint H;
            public int N;
            public int OutN;

            public readonly int DataLength;
            public byte* DataStart;
            public byte* Data;
            public byte* DataEnd;
            public readonly byte* DataOriginal;
            public readonly byte* DataOriginalEnd;

            public ReadContext(byte* data, int len, CancellationToken cancellation)
            {
                ReadFromCallbacks = false;
                Read = null;
                Skip = null;
                Cancellation = cancellation;

                DataLength = len;
                DataStart = null;
                Data = DataOriginal = data;
                DataEnd = DataOriginalEnd = data + len;
            }

            public ReadContext(
                Stream stream, byte[] readBuffer, CancellationToken cancellation,
                ReadCallback read, SkipCallback skip)
            {
                Stream = stream;
                ReadBuffer = readBuffer;
                Cancellation = cancellation;

                Read = read;
                Skip = skip;
                ReadFromCallbacks = true;

                DataLength = 256;
                DataStart = (byte*)CRuntime.malloc(DataLength);
                DataOriginal = DataStart;
                stbi__refill_buffer(this);
                DataOriginalEnd = DataEnd;
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct ReadState
        {
            public readonly ReadProgressCallback Progress;

            public int BitsPerChannel;
            public int Components;
            public int AnimationDelay;

            public int Width;
            public int Height;
            public int RequestedComponents;

            public ReadState(ReadProgressCallback onProgress) : this()
            {
                Progress = onProgress;
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct stbi__huffman
        {
            public const int len_fast = 1 << 9;

            public fixed byte fast[len_fast];
            public fixed ushort code[256];
            public fixed byte values[256];
            public fixed byte size[257];
            public fixed uint maxcode[18];
            public fixed int delta[17];
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct stbi__zhuffman
        {
            public fixed ushort fast[1 << 9];
            public fixed ushort firstcode[16];
            public fixed int maxcode[17];
            public fixed ushort firstsymbol[16];
            public fixed byte size[288];
            public fixed ushort value[288];
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct stbi__zbuf
        {
            public byte* zbuffer;
            public byte* zbuffer_end;
            public int num_bits;
            public uint code_buffer;
            public byte* zout;
            public byte* zout_start;
            public byte* zout_end;
            public int z_expandable;
            public stbi__zhuffman z_length;
            public stbi__zhuffman z_distance;
        }

        [StructLayout(LayoutKind.Sequential)]
        public readonly struct PngChunkHeader
        {
            public const uint CgBI = ('C' << 24) + ('g' << 16) + ('B' << 8) + 'I';
            public const uint IHDR = ('I' << 24) + ('H' << 16) + ('D' << 8) + 'R';
            public const uint PLTE = ('P' << 24) + ('L' << 16) + ('T' << 8) + 'E';
            public const uint tRNS = ('t' << 24) + ('R' << 16) + ('N' << 8) + 'S';
            public const uint IDAT = ('I' << 24) + ('D' << 16) + ('A' << 8) + 'T';
            public const uint IEND = ('I' << 24) + ('E' << 16) + ('N' << 8) + 'D';

            public readonly uint Length;
            public readonly uint Type;

            public PngChunkHeader(uint length, uint type)
            {
                Length = length;
                Type = type;
            }
        }

        public struct PngContext
        {
            public readonly ReadContext s;
            public byte* idata;
            public byte* _out_;
            public int depth;

            public PngContext(ReadContext s) : this()
            {
                this.s = s;
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct BmpInfo
        {
            public int bpp;
            public int offset;
            public int hsz;
            public uint mr;
            public uint mg;
            public uint mb;
            public uint ma;
            public uint all_a;
        }

        public const int STBI_default = 0;
        public const int STBI_grey = 1;
        public const int STBI_grey_alpha = 2;
        public const int STBI_rgb = 3;
        public const int STBI_rgb_alpha = 4;

        public const int STBI__SCAN_load = 0;
        public const int STBI__SCAN_type = 1;
        public const int STBI__SCAN_header = 2;
        public const int STBI__F_none = 0;
        public const int STBI__F_sub = 1;
        public const int STBI__F_up = 2;
        public const int STBI__F_avg = 3;
        public const int STBI__F_paeth = 4;
        public const int STBI__F_avg_first = 5;
        public const int STBI__F_paeth_first = 6;

        internal static uint[] stbi__bmask =
        {
            0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535
        };

        internal static int[] stbi__jbias =
        {
            0, -1, -3, -7, -15, -31, -63, -127, -255, -511, -1023, -2047, -4095, -8191, -16383, -32767
        };

        internal static byte[] stbi__jpeg_dezigzag =
        {
            0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40,
            48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29,
            22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54,
            47, 55, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63
        };

        internal static byte[] png_sig = { 137, 80, 78, 71, 13, 10, 26, 10 };

        internal static byte[] first_row_filter =
        {
            STBI__F_none, STBI__F_sub, STBI__F_none, STBI__F_avg_first, STBI__F_paeth_first
        };

        internal static byte[] stbi__depth_scale_table = { 0, 0xff, 0x55, 0, 0x11, 0, 0, 0, 0x01 };

        public static void stbi__rewind(ReadContext s)
        {
            s.Data = s.DataOriginal;
            s.DataEnd = s.DataOriginalEnd;
        }

        public static int stbi__addsizes_valid(int a, int b)
        {
            if ((b) < (0))
                return 0;
            return (a <= 2147483647 - b) ? 1 : 0;
        }

        public static int stbi__mul2sizes_valid(int a, int b)
        {
            if (((a) < (0)) || ((b) < (0)))
                return 0;
            if ((b) == 0)
                return 1;
            return (a <= 2147483647 / b) ? 1 : 0;
        }

        public static int stbi__mad2sizes_valid(int a, int b, int add)
        {
            return (int)
                (((stbi__mul2sizes_valid((int)(a), (int)(b))) != 0) &&
                 ((stbi__addsizes_valid((int)(a * b), (int)(add))) != 0)
                    ? 1
                    : 0);
        }

        public static int stbi__mad3sizes_valid(int a, int b, int c, int add)
        {
            return
                (int)
                ((((stbi__mul2sizes_valid((int)(a), (int)(b))) != 0) &&
                  ((stbi__mul2sizes_valid((int)(a * b), (int)(c))) != 0)) &&
                 ((stbi__addsizes_valid((int)(a * b * c), (int)(add))) != 0)
                    ? 1
                    : 0);
        }

        public static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
        {
            return
                (int)
                (((((stbi__mul2sizes_valid((int)(a), (int)(b))) != 0) &&
                   ((stbi__mul2sizes_valid((int)(a * b), (int)(c))) != 0)) &&
                  ((stbi__mul2sizes_valid((int)(a * b * c), (int)(d))) != 0)) &&
                 ((stbi__addsizes_valid((int)(a * b * c * d), (int)(add))) != 0)
                    ? 1
                    : 0);
        }

        public static void* stbi__malloc_mad2(int a, int b, int add)
        {
            if (stbi__mad2sizes_valid((int)(a), (int)(b), (int)(add)) == 0)
                return null;
            return CRuntime.malloc((ulong)(a * b + add));
        }

        public static void* stbi__malloc_mad3(int a, int b, int c, int add)
        {
            if (stbi__mad3sizes_valid((int)(a), (int)(b), (int)(c), (int)(add)) == 0)
                return null;
            return CRuntime.malloc((ulong)(a * b * c + add));
        }

        public static void* stbi__malloc_mad4(int a, int b, int c, int d, int add)
        {
            if (stbi__mad4sizes_valid((int)(a), (int)(b), (int)(c), (int)(d), (int)(add)) == 0)
                return null;
            return CRuntime.malloc((ulong)(a * b * c * d + add));
        }

        public static void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
        {
            stbi__vertically_flip_on_load = (int)(flag_true_if_should_flip);
        }

        public static void* stbi__load_main(
            ReadContext s, int req_comp, int bytesPerComp, out ReadState ri)
        {
            ri = default;
            ri.BitsPerChannel = bytesPerComp;
            ri.RequestedComponents = req_comp;

            if ((stbi__jpeg_test(s)) != 0)
                return stbi__jpeg_load(s, ref ri);
            if ((stbi__png_test(s)) != 0)
                return stbi__png_load(s, ref ri);
            if ((stbi__bmp_test(s)) != 0)
                return stbi__bmp_load(s, ref ri);
            if ((stbi__gif_test(s)) != 0)
                return stbi__gif_load(s, ref ri);
            if ((stbi__psd_test(s)) != 0)
                return stbi__psd_load(s, ref ri);
            if ((stbi__tga_test(s)) != 0)
                return stbi__tga_load(s, ref ri);

            return (byte*)((ulong)((stbi__err("unknown image type")) != 0 ? ((byte*)null) : null));
        }

        public static byte* stbi__convert_16_to_8(ushort* orig, int w, int h, int channels)
        {
            int i;
            int img_len = (int)(w * h * channels);
            byte* reduced;
            reduced = (byte*)(CRuntime.malloc((ulong)(img_len)));
            if ((reduced) == null)
                return ((byte*)((ulong)((stbi__err("outofmem")) != 0 ? ((byte*)null) : null)));

            for (i = 0; (i) < (img_len); ++i)
                reduced[i] = ((byte)((orig[i] >> 8) & 0xFF));

            CRuntime.free(orig);
            return reduced;
        }

        public static ushort* stbi__convert_8_to_16(byte* orig, int w, int h, int channels)
        {
            int i;
            int img_len = (int)(w * h * channels);
            ushort* enlarged;
            enlarged = (ushort*)(CRuntime.malloc((ulong)(img_len * 2)));
            if ((enlarged) == null)
                return (ushort*)((byte*)((ulong)((stbi__err("outofmem")) != 0 ? ((byte*)null) : null)));
            for (i = 0; (i) < (img_len); ++i)
            {
                enlarged[i] = ((ushort)((orig[i] << 8) + orig[i]));
            }

            CRuntime.free(orig);
            return enlarged;
        }

        public static void stbi__vertical_flip(void* image, int w, int h, int bytes_per_pixel)
        {
            int row;
            ulong bytes_per_row = (ulong)(w * bytes_per_pixel);
            byte* tmp = stackalloc byte[2048];
            byte* bytes = (byte*)(image);
            for (row = 0; (row) < (h >> 1); row++)
            {
                byte* row0 = bytes + (ulong)row * bytes_per_row;
                byte* row1 = bytes + (ulong)(h - row - 1) * bytes_per_row;
                ulong bytes_left = (ulong)(bytes_per_row);
                while ((bytes_left) != 0)
                {
                    ulong bytes_copy = (ulong)(((bytes_left) < (2048)) ? bytes_left : 2048);
                    CRuntime.memcpy(tmp, row0, (ulong)(bytes_copy));
                    CRuntime.memcpy(row0, row1, (ulong)(bytes_copy));
                    CRuntime.memcpy(row1, tmp, (ulong)(bytes_copy));
                    row0 += bytes_copy;
                    row1 += bytes_copy;
                    bytes_left -= (ulong)(bytes_copy);
                }
            }
        }

        public static byte* stbi__load_and_postprocess_8bit(
            ReadContext s, out int x, out int y, out int comp, int req_comp)
        {
            void* result = stbi__load_main(s, req_comp, 8, out ReadState ri);
            x = ri.Width;
            y = ri.Height;
            comp = ri.Components;

            if ((result) == null)
                return null;

            if (ri.BitsPerChannel != 8)
            {
                result = stbi__convert_16_to_8((ushort*)result, x, y, req_comp == 0 ? comp : req_comp);
                ri.BitsPerChannel = (int)(8);
            }

            if ((stbi__vertically_flip_on_load) != 0)
            {
                int channels = (int)((req_comp) != 0 ? req_comp : comp);
                stbi__vertical_flip(result, (int)(x), (int)(y), (int)(channels));
            }

            return (byte*)(result);
        }

        public static ushort* stbi__load_and_postprocess_16bit(
            ReadContext s, out int x, out int y, out int comp, int req_comp)
        {
            void* result = stbi__load_main(s, req_comp, 16, out ReadState ri);
            x = ri.Width;
            y = ri.Height;
            comp = ri.Components;

            if ((result) == null)
                return null;

            if (ri.BitsPerChannel != 16)
            {
                result = stbi__convert_8_to_16((byte*)result, x, y, req_comp == 0 ? comp : req_comp);
                ri.BitsPerChannel = (int)(16);
            }

            if ((stbi__vertically_flip_on_load) != 0)
            {
                int channels = (int)((req_comp) != 0 ? req_comp : comp);
                stbi__vertical_flip(result, (int)(x), (int)(y), (int)(channels * 2));
            }

            return (ushort*)(result);
        }

        public static void stbi__refill_buffer(ReadContext s)
        {
            int n = (int)(s.Read(s, new Span<byte>(s.DataStart, (int)(s.DataLength))));
            if ((n) == 0)
            {
                s.ReadFromCallbacks = false;
                s.Data = s.DataStart;
                s.DataEnd = s.DataStart;
                s.DataEnd++;
                *s.Data = (byte)(0);
            }
            else
            {
                s.Data = s.DataStart;
                s.DataEnd = s.DataStart;
                s.DataEnd += n;
            }
        }

        public static byte stbi__get8(ReadContext s)
        {
            if ((s.Data) < (s.DataEnd))
                return (byte)(*s.Data++);

            if (s.ReadFromCallbacks)
            {
                stbi__refill_buffer(s);
                return (byte)(*s.Data++);
            }

            return (byte)(0);
        }

        public static int stbi__at_eof(ReadContext s)
        {
            if ((s.Read) != null)
            {
                if (s.Stream.CanRead)
                    return 0; // not at eof

                if (s.ReadFromCallbacks)
                    return 1;
            }

            return (int)((s.Data) >= (s.DataEnd) ? 1 : 0);
        }

        public static void stbi__skip(ReadContext s, int n)
        {
            if ((n) < (0))
            {
                s.Data = s.DataEnd;
                return;
            }

            if ((s.Read) != null)
            {
                int blen = (int)(s.DataEnd - s.Data);
                if ((blen) < (n))
                {
                    s.Data = s.DataEnd;
                    s.Skip(s, (int)(n - blen));
                    return;
                }
            }

            s.Data += n;
        }

        public static int stbi__getn(ReadContext s, byte* buffer, int n)
        {
            if ((s.Read) != null)
            {
                int blen = (int)(s.DataEnd - s.Data);
                if ((blen) < (n))
                {
                    int res;
                    int count;
                    CRuntime.memcpy(buffer, s.Data, (ulong)(blen));
                    count = (int)(s.Read(s, new Span<byte>(buffer + blen, n - blen)));
                    res = (int)((count) == (n - blen) ? 1 : 0);
                    s.Data = s.DataEnd;
                    return (int)(res);
                }
            }

            if (s.Data + n <= s.DataEnd)
            {
                CRuntime.memcpy(buffer, s.Data, (ulong)(n));
                s.Data += n;
                return 1;
            }
            else
                return 0;
        }

        public static int stbi__get16be(ReadContext s)
        {
            int z = (int)(stbi__get8(s));
            return (int)((z << 8) + stbi__get8(s));
        }

        public static uint stbi__get32be(ReadContext s)
        {
            uint z = (uint)(stbi__get16be(s));
            return (uint)((z << 16) + stbi__get16be(s));
        }

        public static int stbi__get16le(ReadContext s)
        {
            int z = (int)(stbi__get8(s));
            return (int)(z + (stbi__get8(s) << 8));
        }

        public static uint stbi__get32le(ReadContext s)
        {
            uint z = (uint)(stbi__get16le(s));
            return (uint)(z + (stbi__get16le(s) << 16));
        }

        public static byte stbi__compute_y(int r, int g, int b)
        {
            return (byte)(((r * 77) + (g * 150) + (29 * b)) >> 8);
        }

        public static byte* stbi__convert_format(byte* data, int img_n, int req_comp, uint x, uint y)
        {
            if ((req_comp) == (img_n))
                return data;

            byte* good = (byte*)(stbi__malloc_mad3((int)(req_comp), (int)(x), (int)(y), 0));
            if ((good) == null)
            {
                CRuntime.free(data);
                return ((byte*)((ulong)((stbi__err("outofmem")) != 0 ? ((byte*)null) : null)));
            }

            int i;
            int j;

            for (j = 0; (j) < ((int)(y)); ++j)
            {
                byte* src = data + j * x * img_n;
                byte* dest = good + j * x * req_comp;
                switch (img_n * 8 + req_comp)
                {
                    case ((1) * 8 + (2)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 1, dest += 2)
                        {
                            dest[0] = (byte)(src[0]);
                            dest[1] = (byte)(255);
                        }
                        break;

                    case ((1) * 8 + (3)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 1, dest += 3)
                            dest[0] = (byte)(dest[1] = (byte)(dest[2] = (byte)(src[0])));
                        break;

                    case ((1) * 8 + (4)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 1, dest += 4)
                        {
                            dest[0] = (byte)(dest[1] = (byte)(dest[2] = (byte)(src[0])));
                            dest[3] = (byte)(255);
                        }
                        break;

                    case ((2) * 8 + (1)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 2, dest += 1)
                            dest[0] = (byte)(src[0]);
                        break;

                    case ((2) * 8 + (3)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 2, dest += 3)
                            dest[0] = (byte)(dest[1] = (byte)(dest[2] = (byte)(src[0])));
                        break;

                    case ((2) * 8 + (4)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 2, dest += 4)
                        {
                            dest[0] = (byte)(dest[1] = (byte)(dest[2] = (byte)(src[0])));
                            dest[3] = (byte)(src[1]);
                        }
                        break;

                    case ((3) * 8 + (4)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 3, dest += 4)
                        {
                            dest[0] = (byte)(src[0]);
                            dest[1] = (byte)(src[1]);
                            dest[2] = (byte)(src[2]);
                            dest[3] = (byte)(255);
                        }
                        break;

                    case ((3) * 8 + (1)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 3, dest += 1)
                            dest[0] = (byte)(stbi__compute_y((int)(src[0]), (int)(src[1]), (int)(src[2])));
                        break;

                    case ((3) * 8 + (2)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 3, dest += 2)
                        {
                            dest[0] = (byte)(stbi__compute_y((int)(src[0]), (int)(src[1]), (int)(src[2])));
                            dest[1] = (byte)(255);
                        }
                        break;

                    case ((4) * 8 + (1)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 4, dest += 1)
                            dest[0] = (byte)(stbi__compute_y((int)(src[0]), (int)(src[1]), (int)(src[2])));
                        break;

                    case ((4) * 8 + (2)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 4, dest += 2)
                            dest[0] = (byte)(stbi__compute_y((int)(src[0]), (int)(src[1]), (int)(src[2])));
                        dest[1] = (byte)(src[3]);
                        break;

                    case ((4) * 8 + (3)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 4, dest += 3)
                            dest[0] = (byte)(src[0]);
                        dest[1] = (byte)(src[1]);
                        dest[2] = (byte)(src[2]);
                        break;

                    default:
                        return ((byte*)((ulong)((stbi__err("0")) != 0 ? ((byte*)null) : null)));
                }
            }

            CRuntime.free(data);
            return good;
        }

        public static ushort stbi__compute_y_16(int r, int g, int b)
        {
            return (ushort)(((r * 77) + (g * 150) + (29 * b)) >> 8);
        }

        public static ushort* stbi__convert_format16(ushort* data, int img_n, int req_comp, uint x, uint y)
        {
            int i;
            int j;
            if ((req_comp) == (img_n))
                return data;

            ushort* good = (ushort*)(CRuntime.malloc((ulong)(req_comp * x * y * 2)));
            if ((good) == null)
            {
                CRuntime.free(data);
                return (ushort*)((byte*)((ulong)((stbi__err("outofmem")) != 0 ? ((byte*)null) : null)));
            }

            for (j = 0; (j) < ((int)(y)); ++j)
            {
                ushort* src = data + j * x * img_n;
                ushort* dest = good + j * x * req_comp;
                switch (((img_n) * 8 + (req_comp)))
                {
                    case ((1) * 8 + (2)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 1, dest += 2)
                        {
                            dest[0] = (ushort)(src[0]);
                            dest[1] = (ushort)(0xffff);
                        }
                        break;

                    case ((1) * 8 + (3)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 1, dest += 3)
                            dest[0] = (ushort)(dest[1] = (ushort)(dest[2] = (ushort)(src[0])));
                        break;

                    case ((1) * 8 + (4)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 1, dest += 4)
                        {
                            dest[0] = (ushort)(dest[1] = (ushort)(dest[2] = (ushort)(src[0])));
                            dest[3] = (ushort)(0xffff);
                        }
                        break;

                    case ((2) * 8 + (1)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 2, dest += 1)
                            dest[0] = (ushort)(src[0]);
                        break;

                    case ((2) * 8 + (3)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 2, dest += 3)
                            dest[0] = (ushort)(dest[1] = (ushort)(dest[2] = (ushort)(src[0])));
                        break;

                    case ((2) * 8 + (4)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 2, dest += 4)
                        {
                            dest[0] = (ushort)(dest[1] = (ushort)(dest[2] = (ushort)(src[0])));
                            dest[3] = (ushort)(src[1]);
                        }
                        break;

                    case ((3) * 8 + (4)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 3, dest += 4)
                        {
                            dest[0] = (ushort)(src[0]);
                            dest[1] = (ushort)(src[1]);
                            dest[2] = (ushort)(src[2]);
                            dest[3] = (ushort)(0xffff);
                        }
                        break;

                    case ((3) * 8 + (1)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 3, dest += 1)
                            dest[0] = (ushort)(stbi__compute_y_16((int)(src[0]), (int)(src[1]), (int)(src[2])));
                        break;

                    case ((3) * 8 + (2)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 3, dest += 2)
                            dest[0] = (ushort)(stbi__compute_y_16((int)(src[0]), (int)(src[1]), (int)(src[2])));
                        dest[1] = (ushort)(0xffff);
                        break;

                    case ((4) * 8 + (1)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 4, dest += 1)
                            dest[0] = (ushort)(stbi__compute_y_16((int)(src[0]), (int)(src[1]), (int)(src[2])));
                        break;

                    case ((4) * 8 + (2)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 4, dest += 2)
                        {
                            dest[0] = (ushort)(stbi__compute_y_16((int)(src[0]), (int)(src[1]), (int)(src[2])));
                            dest[1] = (ushort)(src[3]);
                        }
                        break;

                    case ((4) * 8 + (3)):
                        for (i = (int)(x - 1); (i) >= (0); --i, src += 4, dest += 3)
                        {
                            dest[0] = (ushort)(src[0]);
                            dest[1] = (ushort)(src[1]);
                            dest[2] = (ushort)(src[2]);
                        }
                        break;

                    default:
                        return (ushort*)((byte*)((ulong)((stbi__err("0")) != 0 ? ((byte*)null) : null)));
                }
            }

            CRuntime.free(data);
            return good;
        }

        public static int stbi__build_huffman(ref stbi__huffman h, int* count)
        {
            int i;
            int j;
            int k = 0;
            int code = 0;
            for (i = 0; (i) < (16); ++i)
            {
                for (j = 0; (j) < (count[i]); ++j)
                    h.size[k++] = ((byte)(i + 1));
            }

            h.size[k] = (byte)(0);
            k = 0;
            for (j = 1; j <= 16; ++j)
            {
                h.delta[j] = (int)(k - code);
                if ((h.size[k]) == (j))
                {
                    while ((h.size[k]) == (j))
                    {
                        h.code[k++] = ((ushort)(code++));
                    }

                    if ((code - 1) >= (1 << j))
                        return (int)(stbi__err("bad code lengths"));
                }

                h.maxcode[j] = (uint)(code << (16 - j));
                code <<= 1;
            }

            h.maxcode[j] = (uint)(0xffffffff);
            for (i = 0; i < stbi__huffman.len_fast; ++i)
            {
                h.fast[i] = 255;
            }
            for (i = 0; (i) < (k); ++i)
            {
                int s = (int)(h.size[i]);
                if (s <= 9)
                {
                    int c = (int)(h.code[i] << (9 - s));
                    int m = (int)(1 << (9 - s));
                    for (j = 0; (j) < (m); ++j)
                    {
                        h.fast[c + j] = ((byte)(i));
                    }
                }
            }

            return 1;
        }

        public static void stbi__build_fast_ac(short[] fast_ac, ref stbi__huffman h)
        {
            int i;
            for (i = 0; (i) < (1 << 9); ++i)
            {
                byte fast = (byte)(h.fast[i]);
                fast_ac[i] = (short)(0);
                if ((fast) < (255))
                {
                    int rs = (int)(h.values[fast]);
                    int run = (int)((rs >> 4) & 15);
                    int magbits = (int)(rs & 15);
                    int len = (int)(h.size[fast]);
                    if (((magbits) != 0) && (len + magbits <= 9))
                    {
                        int k = (int)(((i << len) & ((1 << 9) - 1)) >> (9 - magbits));
                        int m = (int)(1 << (magbits - 1));
                        if ((k) < (m))
                            k += (int)((~0U << magbits) + 1);
                        if (((k) >= (-128)) && (k <= 127))
                            fast_ac[i] = ((short)((k << 8) + (run << 4) + (len + magbits)));
                    }
                }
            }
        }

        public static void stbi__grow_buffer_unsafe(JpegContext j)
        {
            do
            {
                int b = (int)((j.nomore) != 0 ? 0 : stbi__get8(j.s));
                if ((b) == (0xff))
                {
                    int c = (int)(stbi__get8(j.s));
                    while ((c) == (0xff))
                        c = (int)(stbi__get8(j.s));

                    if (c != 0)
                    {
                        j.marker = ((byte)(c));
                        j.nomore = 1;
                        return;
                    }
                }

                j.code_buffer |= (uint)(b << (24 - j.code_bits));
                j.code_bits += (int)(8);
            } while (j.code_bits <= 24);
        }

        public static int stbi__jpeg_huff_decode(JpegContext j, ref stbi__huffman h)
        {
            uint temp;
            int c;
            int k;
            if ((j.code_bits) < (16))
                stbi__grow_buffer_unsafe(j);
            c = (int)((j.code_buffer >> (32 - 9)) & ((1 << 9) - 1));
            k = (int)(h.fast[c]);
            if ((k) < (255))
            {
                int s = (int)(h.size[k]);
                if ((s) > (j.code_bits))
                    return (int)(-1);
                j.code_buffer <<= s;
                j.code_bits -= (int)(s);
                return (int)(h.values[k]);
            }

            temp = (uint)(j.code_buffer >> 16);
            for (k = (int)(9 + 1); ; ++k)
            {
                if ((temp) < (h.maxcode[k]))
                    break;
            }

            if ((k) == (17))
            {
                j.code_bits -= (int)(16);
                return (int)(-1);
            }

            if ((k) > (j.code_bits))
                return (int)(-1);
            c = (int)(((j.code_buffer >> (32 - k)) & stbi__bmask[k]) + h.delta[k]);
            j.code_bits -= (int)(k);
            j.code_buffer <<= k;
            return (int)(h.values[c]);
        }

        public static int stbi__extend_receive(JpegContext j, int n)
        {
            uint k;
            int sgn;
            if ((j.code_bits) < (n))
                stbi__grow_buffer_unsafe(j);
            sgn = (int)((int)j.code_buffer >> 31);
            k = (uint)(CRuntime._lrotl(j.code_buffer, (int)(n)));
            j.code_buffer = (uint)(k & ~stbi__bmask[n]);
            k &= (uint)(stbi__bmask[n]);
            j.code_bits -= (int)(n);
            return (int)(k + (stbi__jbias[n] & ~sgn));
        }

        public static int stbi__jpeg_get_bits(JpegContext j, int n)
        {
            uint k;
            if ((j.code_bits) < (n))
                stbi__grow_buffer_unsafe(j);
            k = (uint)(CRuntime._lrotl(j.code_buffer, (int)(n)));
            j.code_buffer = (uint)(k & ~stbi__bmask[n]);
            k &= (uint)(stbi__bmask[n]);
            j.code_bits -= (int)(n);
            return (int)(k);
        }

        public static int stbi__jpeg_get_bit(JpegContext j)
        {
            uint k;
            if ((j.code_bits) < (1))
                stbi__grow_buffer_unsafe(j);
            k = (uint)(j.code_buffer);
            j.code_buffer <<= 1;
            --j.code_bits;
            return (int)(k & 0x80000000);
        }

        public static int stbi__jpeg_decode_block(
            JpegContext j, short* data, ref stbi__huffman hdc, ref stbi__huffman hac,
            short[] fac, int b, ushort[] dequant)
        {
            int diff;
            int dc;
            int k;
            int t;
            if ((j.code_bits) < (16))
                stbi__grow_buffer_unsafe(j);
            t = (int)(stbi__jpeg_huff_decode(j, ref hdc));
            if ((t) < (0))
                return (int)(stbi__err("bad huffman code"));
            CRuntime.memset(data, 0, (ulong)(64 * sizeof(short)));
            diff = (int)((t) != 0 ? stbi__extend_receive(j, (int)(t)) : 0);
            dc = (int)(j.img_comp[b].dc_pred + diff);
            j.img_comp[b].dc_pred = (int)(dc);
            data[0] = ((short)(dc * dequant[0]));
            k = 1;
            do
            {
                uint zig;
                int c;
                int r;
                int s;
                if ((j.code_bits) < (16))
                    stbi__grow_buffer_unsafe(j);
                c = (int)((j.code_buffer >> (32 - 9)) & ((1 << 9) - 1));
                r = (int)(fac[c]);
                if ((r) != 0)
                {
                    k += (int)((r >> 4) & 15);
                    s = (int)(r & 15);
                    j.code_buffer <<= s;
                    j.code_bits -= (int)(s);
                    zig = (uint)(stbi__jpeg_dezigzag[k++]);
                    data[zig] = ((short)((r >> 8) * dequant[zig]));
                }
                else
                {
                    int rs = (int)(stbi__jpeg_huff_decode(j, ref hac));
                    if ((rs) < (0))
                        return (int)(stbi__err("bad huffman code"));
                    s = (int)(rs & 15);
                    r = (int)(rs >> 4);
                    if ((s) == 0)
                    {
                        if (rs != 0xf0)
                            break;
                        k += (int)(16);
                    }
                    else
                    {
                        k += (int)(r);
                        zig = (uint)(stbi__jpeg_dezigzag[k++]);
                        data[zig] = ((short)(stbi__extend_receive(j, (int)(s)) * dequant[zig]));
                    }
                }
            } while ((k) < (64));

            return 1;
        }

        public static int stbi__jpeg_decode_block_prog_dc(
            JpegContext j, short* data, ref stbi__huffman hdc, int b)
        {
            int diff;
            int dc;
            int t;
            if (j.spec_end != 0)
                return (int)(stbi__err("can't merge dc and ac"));
            if ((j.code_bits) < (16))
                stbi__grow_buffer_unsafe(j);
            if ((j.succ_high) == 0)
            {
                CRuntime.memset(data, 0, (ulong)(64 * sizeof(short)));
                t = (int)(stbi__jpeg_huff_decode(j, ref hdc));
                diff = (int)((t) != 0 ? stbi__extend_receive(j, (int)(t)) : 0);
                dc = (int)(j.img_comp[b].dc_pred + diff);
                j.img_comp[b].dc_pred = (int)(dc);
                data[0] = ((short)(dc << j.succ_low));
            }
            else
            {
                if ((stbi__jpeg_get_bit(j)) != 0)
                    data[0] += ((short)(1 << j.succ_low));
            }

            return 1;
        }

        public static int stbi__jpeg_decode_block_prog_ac(
            JpegContext j, short* data, ref stbi__huffman hac, short[] fac)
        {
            int k;
            if ((j.spec_start) == 0)
                return (int)(stbi__err("can't merge dc and ac"));
            if ((j.succ_high) == 0)
            {
                int shift = (int)(j.succ_low);
                if ((j.eob_run) != 0)
                {
                    --j.eob_run;
                    return 1;
                }

                k = (int)(j.spec_start);
                do
                {
                    uint zig;
                    int c;
                    int r;
                    int s;
                    if ((j.code_bits) < (16))
                        stbi__grow_buffer_unsafe(j);
                    c = (int)((j.code_buffer >> (32 - 9)) & ((1 << 9) - 1));
                    r = (int)(fac[c]);
                    if ((r) != 0)
                    {
                        k += (int)((r >> 4) & 15);
                        s = (int)(r & 15);
                        j.code_buffer <<= s;
                        j.code_bits -= (int)(s);
                        zig = (uint)(stbi__jpeg_dezigzag[k++]);
                        data[zig] = ((short)((r >> 8) << shift));
                    }
                    else
                    {
                        int rs = (int)(stbi__jpeg_huff_decode(j, ref hac));
                        if ((rs) < (0))
                            return (int)(stbi__err("bad huffman code"));
                        s = (int)(rs & 15);
                        r = (int)(rs >> 4);
                        if ((s) == 0)
                        {
                            if ((r) < (15))
                            {
                                j.eob_run = (int)(1 << r);
                                if ((r) != 0)
                                    j.eob_run += (int)(stbi__jpeg_get_bits(j, (int)(r)));
                                --j.eob_run;
                                break;
                            }

                            k += (int)(16);
                        }
                        else
                        {
                            k += (int)(r);
                            zig = (uint)(stbi__jpeg_dezigzag[k++]);
                            data[zig] = ((short)(stbi__extend_receive(j, (int)(s)) << shift));
                        }
                    }
                } while (k <= j.spec_end);
            }
            else
            {
                short bit = (short)(1 << j.succ_low);
                if ((j.eob_run) != 0)
                {
                    --j.eob_run;
                    for (k = (int)(j.spec_start); k <= j.spec_end; ++k)
                    {
                        short* p = &data[stbi__jpeg_dezigzag[k]];
                        if (*p != 0)
                            if ((stbi__jpeg_get_bit(j)) != 0)
                                if ((*p & bit) == 0)
                                {
                                    if ((*p) > (0))
                                        *p += (short)(bit);
                                    else
                                        *p -= (short)(bit);
                                }
                    }
                }
                else
                {
                    k = (int)(j.spec_start);
                    do
                    {
                        int r;
                        int s;
                        int rs = (int)(stbi__jpeg_huff_decode(j, ref hac));
                        if ((rs) < (0))
                            return (int)(stbi__err("bad huffman code"));
                        s = (int)(rs & 15);
                        r = (int)(rs >> 4);
                        if ((s) == 0)
                        {
                            if ((r) < (15))
                            {
                                j.eob_run = (int)((1 << r) - 1);
                                if ((r) != 0)
                                    j.eob_run += (int)(stbi__jpeg_get_bits(j, (int)(r)));
                                r = (int)(64);
                            }
                            else
                            {
                            }
                        }
                        else
                        {
                            if (s != 1)
                                return (int)(stbi__err("bad huffman code"));
                            if ((stbi__jpeg_get_bit(j)) != 0)
                                s = (int)(bit);
                            else
                                s = (int)(-bit);
                        }

                        while (k <= j.spec_end)
                        {
                            short* p = &data[stbi__jpeg_dezigzag[k++]];
                            if (*p != 0)
                            {
                                if ((stbi__jpeg_get_bit(j)) != 0)
                                    if ((*p & bit) == 0)
                                    {
                                        if ((*p) > (0))
                                            *p += (short)(bit);
                                        else
                                            *p -= (short)(bit);
                                    }
                            }
                            else
                            {
                                if ((r) == 0)
                                {
                                    *p = ((short)(s));
                                    break;
                                }

                                --r;
                            }
                        }
                    } while (k <= j.spec_end);
                }
            }

            return 1;
        }

        public static byte stbi__clamp(int x)
        {
            if (((uint)(x)) > (255))
            {
                if ((x) < (0))
                    return (byte)(0);
                if ((x) > (255))
                    return (byte)(255);
            }

            return (byte)(x);
        }

        public static void stbi__idct_block(byte* _out_, int out_stride, short* data)
        {
            int i;
            int* val = stackalloc int[64];
            int* v = val;
            byte* o;
            short* d = ((short*)data);
            for (i = 0; (i) < (8); ++i, ++d, ++v)
            {
                if ((((((((d[8]) == 0) && ((d[16]) == 0)) && ((d[24]) == 0)) && ((d[32]) == 0)) &&
                      ((d[40]) == 0)) &&
                     ((d[48]) == 0)) && ((d[56]) == 0))
                {
                    int dcterm = (int)(d[0] << 2);
                    v[0] =
                        (int)
                        (v[8] =
                            (int)(v[16] = (int)(v[24] =
                                (int)(v[32] = (int)(v[40] = (int)(v[48] = (int)(v[56] = (int)(dcterm))))))));
                }
                else
                {
                    int t0;
                    int t1;
                    int t2;
                    int t3;
                    int p1;
                    int p2;
                    int p3;
                    int p4;
                    int p5;
                    int x0;
                    int x1;
                    int x2;
                    int x3;
                    p2 = (int)(d[16]);
                    p3 = (int)(d[48]);
                    p1 = (int)((p2 + p3) * ((int)((0.5411961f) * 4096 + 0.5)));
                    t2 = (int)(p1 + p3 * ((int)((-1.847759065f) * 4096 + 0.5)));
                    t3 = (int)(p1 + p2 * ((int)((0.765366865f) * 4096 + 0.5)));
                    p2 = (int)(d[0]);
                    p3 = (int)(d[32]);
                    t0 = (int)((p2 + p3) << 12);
                    t1 = (int)((p2 - p3) << 12);
                    x0 = (int)(t0 + t3);
                    x3 = (int)(t0 - t3);
                    x1 = (int)(t1 + t2);
                    x2 = (int)(t1 - t2);
                    t0 = (int)(d[56]);
                    t1 = (int)(d[40]);
                    t2 = (int)(d[24]);
                    t3 = (int)(d[8]);
                    p3 = (int)(t0 + t2);
                    p4 = (int)(t1 + t3);
                    p1 = (int)(t0 + t3);
                    p2 = (int)(t1 + t2);
                    p5 = (int)((p3 + p4) * ((int)((1.175875602f) * 4096 + 0.5)));
                    t0 = (int)(t0 * ((int)((0.298631336f) * 4096 + 0.5)));
                    t1 = (int)(t1 * ((int)((2.053119869f) * 4096 + 0.5)));
                    t2 = (int)(t2 * ((int)((3.072711026f) * 4096 + 0.5)));
                    t3 = (int)(t3 * ((int)((1.501321110f) * 4096 + 0.5)));
                    p1 = (int)(p5 + p1 * ((int)((-0.899976223f) * 4096 + 0.5)));
                    p2 = (int)(p5 + p2 * ((int)((-2.562915447f) * 4096 + 0.5)));
                    p3 = (int)(p3 * ((int)((-1.961570560f) * 4096 + 0.5)));
                    p4 = (int)(p4 * ((int)((-0.390180644f) * 4096 + 0.5)));
                    t3 += (int)(p1 + p4);
                    t2 += (int)(p2 + p3);
                    t1 += (int)(p2 + p4);
                    t0 += (int)(p1 + p3);
                    x0 += (int)(512);
                    x1 += (int)(512);
                    x2 += (int)(512);
                    x3 += (int)(512);
                    v[0] = (int)((x0 + t3) >> 10);
                    v[56] = (int)((x0 - t3) >> 10);
                    v[8] = (int)((x1 + t2) >> 10);
                    v[48] = (int)((x1 - t2) >> 10);
                    v[16] = (int)((x2 + t1) >> 10);
                    v[40] = (int)((x2 - t1) >> 10);
                    v[24] = (int)((x3 + t0) >> 10);
                    v[32] = (int)((x3 - t0) >> 10);
                }
            }

            for (i = 0, v = val, o = _out_; (i) < (8); ++i, v += 8, o += out_stride)
            {
                int t0;
                int t1;
                int t2;
                int t3;
                int p1;
                int p2;
                int p3;
                int p4;
                int p5;
                int x0;
                int x1;
                int x2;
                int x3;
                p2 = (int)(v[2]);
                p3 = (int)(v[6]);
                p1 = (int)((p2 + p3) * ((int)((0.5411961f) * 4096 + 0.5)));
                t2 = (int)(p1 + p3 * ((int)((-1.847759065f) * 4096 + 0.5)));
                t3 = (int)(p1 + p2 * ((int)((0.765366865f) * 4096 + 0.5)));
                p2 = (int)(v[0]);
                p3 = (int)(v[4]);
                t0 = (int)((p2 + p3) << 12);
                t1 = (int)((p2 - p3) << 12);
                x0 = (int)(t0 + t3);
                x3 = (int)(t0 - t3);
                x1 = (int)(t1 + t2);
                x2 = (int)(t1 - t2);
                t0 = (int)(v[7]);
                t1 = (int)(v[5]);
                t2 = (int)(v[3]);
                t3 = (int)(v[1]);
                p3 = (int)(t0 + t2);
                p4 = (int)(t1 + t3);
                p1 = (int)(t0 + t3);
                p2 = (int)(t1 + t2);
                p5 = (int)((p3 + p4) * ((int)((1.175875602f) * 4096 + 0.5)));
                t0 = (int)(t0 * ((int)((0.298631336f) * 4096 + 0.5)));
                t1 = (int)(t1 * ((int)((2.053119869f) * 4096 + 0.5)));
                t2 = (int)(t2 * ((int)((3.072711026f) * 4096 + 0.5)));
                t3 = (int)(t3 * ((int)((1.501321110f) * 4096 + 0.5)));
                p1 = (int)(p5 + p1 * ((int)((-0.899976223f) * 4096 + 0.5)));
                p2 = (int)(p5 + p2 * ((int)((-2.562915447f) * 4096 + 0.5)));
                p3 = (int)(p3 * ((int)((-1.961570560f) * 4096 + 0.5)));
                p4 = (int)(p4 * ((int)((-0.390180644f) * 4096 + 0.5)));
                t3 += (int)(p1 + p4);
                t2 += (int)(p2 + p3);
                t1 += (int)(p2 + p4);
                t0 += (int)(p1 + p3);
                x0 += (int)(65536 + (128 << 17));
                x1 += (int)(65536 + (128 << 17));
                x2 += (int)(65536 + (128 << 17));
                x3 += (int)(65536 + (128 << 17));
                o[0] = (byte)(stbi__clamp((int)((x0 + t3) >> 17)));
                o[7] = (byte)(stbi__clamp((int)((x0 - t3) >> 17)));
                o[1] = (byte)(stbi__clamp((int)((x1 + t2) >> 17)));
                o[6] = (byte)(stbi__clamp((int)((x1 - t2) >> 17)));
                o[2] = (byte)(stbi__clamp((int)((x2 + t1) >> 17)));
                o[5] = (byte)(stbi__clamp((int)((x2 - t1) >> 17)));
                o[3] = (byte)(stbi__clamp((int)((x3 + t0) >> 17)));
                o[4] = (byte)(stbi__clamp((int)((x3 - t0) >> 17)));
            }
        }

        public static byte stbi__get_marker(JpegContext j)
        {
            byte x;
            if (j.marker != 0xff)
            {
                x = (byte)(j.marker);
                j.marker = (byte)(0xff);
                return (byte)(x);
            }

            x = (byte)(stbi__get8(j.s));
            if (x != 0xff)
                return (byte)(0xff);

            while ((x) == (0xff))
                x = (byte)(stbi__get8(j.s));

            return (byte)(x);
        }

        public static void stbi__jpeg_reset(JpegContext j)
        {
            j.code_bits = 0;
            j.code_buffer = (uint)(0);
            j.nomore = 0;
            j.img_comp[0].dc_pred =
                (int)(j.img_comp[1].dc_pred =
                    (int)(j.img_comp[2].dc_pred = (int)(j.img_comp[3].dc_pred = 0)));
            j.marker = (byte)(0xff);
            j.todo = (int)((j.restart_interval) != 0 ? j.restart_interval : 0x7fffffff);
            j.eob_run = 0;
        }

        public static int stbi__parse_entropy_coded_data(JpegContext z)
        {
            stbi__jpeg_reset(z);
            if (z.progressive == 0)
            {
                if ((z.scan_n) == (1))
                {
                    int i;
                    int j;
                    short* data = stackalloc short[64];
                    int n = (int)(z.order[0]);
                    int w = (int)((z.img_comp[n].x + 7) >> 3);
                    int h = (int)((z.img_comp[n].y + 7) >> 3);
                    for (j = 0; (j) < (h); ++j)
                    {
                        for (i = 0; (i) < (w); ++i)
                        {
                            int ha = (int)(z.img_comp[n].ha);
                            if (stbi__jpeg_decode_block(
                                    z, data, ref z.huff_dc[z.img_comp[n].hd], ref z.huff_ac[ha],
                                    z.fast_ac[ha], (int)(n), z.dequant[z.img_comp[n].tq]) == 0)
                                return 0;

                            z.idct_block_kernel(
                                z.img_comp[n].data + z.img_comp[n].w2 * j * 8 + i * 8,
                                (int)(z.img_comp[n].w2), data);

                            if (--z.todo <= 0)
                            {
                                if ((z.code_bits) < (24))
                                    stbi__grow_buffer_unsafe(z);
                                if (!(((z.marker) >= (0xd0)) && ((z.marker) <= 0xd7)))
                                    return 1;
                                stbi__jpeg_reset(z);
                            }
                        }
                    }

                    return 1;
                }
                else
                {
                    int i;
                    int j;
                    int k;
                    int x;
                    int y;
                    short* data = stackalloc short[64];
                    for (j = 0; (j) < (z.img_mcu_y); ++j)
                    {
                        for (i = 0; (i) < (z.img_mcu_x); ++i)
                        {
                            for (k = 0; (k) < (z.scan_n); ++k)
                            {
                                int n = (int)(z.order[k]);
                                for (y = 0; (y) < (z.img_comp[n].v); ++y)
                                {
                                    for (x = 0; (x) < (z.img_comp[n].h); ++x)
                                    {
                                        int x2 = (int)((i * z.img_comp[n].h + x) * 8);
                                        int y2 = (int)((j * z.img_comp[n].v + y) * 8);
                                        int ha = (int)(z.img_comp[n].ha);
                                        if (
                                            stbi__jpeg_decode_block(z, data,
                                                ref z.huff_dc[z.img_comp[n].hd],
                                                ref z.huff_ac[ha], z.fast_ac[ha], (int)(n),
                                                z.dequant[z.img_comp[n].tq]) == 0)
                                            return 0;
                                        z.idct_block_kernel(z.img_comp[n].data + z.img_comp[n].w2 * y2 + x2,
                                            (int)(z.img_comp[n].w2), data);
                                    }
                                }
                            }

                            if (--z.todo <= 0)
                            {
                                if ((z.code_bits) < (24))
                                    stbi__grow_buffer_unsafe(z);
                                if (!(((z.marker) >= (0xd0)) && ((z.marker) <= 0xd7)))
                                    return 1;
                                stbi__jpeg_reset(z);
                            }
                        }
                    }

                    return 1;
                }
            }
            else
            {
                if ((z.scan_n) == (1))
                {
                    int i;
                    int j;
                    int n = (int)(z.order[0]);
                    int w = (int)((z.img_comp[n].x + 7) >> 3);
                    int h = (int)((z.img_comp[n].y + 7) >> 3);
                    for (j = 0; (j) < (h); ++j)
                    {
                        for (i = 0; (i) < (w); ++i)
                        {
                            short* data = z.img_comp[n].coeff + 64 * (i + j * z.img_comp[n].coeff_w);
                            if ((z.spec_start) == 0)
                            {
                                if (stbi__jpeg_decode_block_prog_dc(z, data,
                                        ref z.huff_dc[z.img_comp[n].hd], (int)(n)) == 0)
                                    return 0;
                            }
                            else
                            {
                                int ha = (int)(z.img_comp[n].ha);
                                if (stbi__jpeg_decode_block_prog_ac(
                                    z, data, ref z.huff_ac[ha], z.fast_ac[ha]) == 0)
                                    return 0;
                            }

                            if (--z.todo <= 0)
                            {
                                if ((z.code_bits) < (24))
                                    stbi__grow_buffer_unsafe(z);
                                if (!(((z.marker) >= (0xd0)) && ((z.marker) <= 0xd7)))
                                    return 1;
                                stbi__jpeg_reset(z);
                            }
                        }
                    }

                    return 1;
                }
                else
                {
                    int i;
                    int j;
                    int k;
                    int x;
                    int y;
                    for (j = 0; (j) < (z.img_mcu_y); ++j)
                    {
                        for (i = 0; (i) < (z.img_mcu_x); ++i)
                        {
                            for (k = 0; (k) < (z.scan_n); ++k)
                            {
                                int n = (int)(z.order[k]);
                                for (y = 0; (y) < (z.img_comp[n].v); ++y)
                                {
                                    for (x = 0; (x) < (z.img_comp[n].h); ++x)
                                    {
                                        int x2 = (int)(i * z.img_comp[n].h + x);
                                        int y2 = (int)(j * z.img_comp[n].v + y);
                                        short* data = z.img_comp[n].coeff + 64 * (x2 + y2 * z.img_comp[n].coeff_w);
                                        if (stbi__jpeg_decode_block_prog_dc(
                                            z, data, ref z.huff_dc[z.img_comp[n].hd], (int)(n)) == 0)
                                            return 0;
                                    }
                                }
                            }

                            if (--z.todo <= 0)
                            {
                                if ((z.code_bits) < (24))
                                    stbi__grow_buffer_unsafe(z);
                                if (!(((z.marker) >= (0xd0)) && ((z.marker) <= 0xd7)))
                                    return 1;
                                stbi__jpeg_reset(z);
                            }
                        }
                    }

                    return 1;
                }
            }

        }

        public static void stbi__jpeg_dequantize(short* data, ushort[] dequant)
        {
            int i;
            for (i = 0; (i) < (64); ++i)
            {
                data[i] *= (short)(dequant[i]);
            }
        }

        public static void stbi__jpeg_finish(JpegContext z)
        {
            if ((z.progressive) != 0)
            {
                int i;
                int j;
                int n;
                for (n = 0; (n) < (z.s.N); ++n)
                {
                    int w = (int)((z.img_comp[n].x + 7) >> 3);
                    int h = (int)((z.img_comp[n].y + 7) >> 3);
                    for (j = 0; (j) < (h); ++j)
                    {
                        for (i = 0; (i) < (w); ++i)
                        {
                            short* data = z.img_comp[n].coeff + 64 * (i + j * z.img_comp[n].coeff_w);
                            stbi__jpeg_dequantize(data, z.dequant[z.img_comp[n].tq]);
                            z.idct_block_kernel(z.img_comp[n].data + z.img_comp[n].w2 * j * 8 + i * 8,
                                (int)(z.img_comp[n].w2), data);
                        }
                    }
                }
            }

        }

        public static int stbi__process_marker(JpegContext z, int m)
        {
            int L;
            switch (m)
            {
                case 0xff:
                    return (int)(stbi__err("expected marker"));

                case 0xDD:
                    if (stbi__get16be(z.s) != 4)
                        return (int)(stbi__err("bad DRI len"));
                    z.restart_interval = (int)(stbi__get16be(z.s));
                    return 1;

                case 0xDB:
                    L = (int)(stbi__get16be(z.s) - 2);
                    while ((L) > (0))
                    {
                        int q = (int)(stbi__get8(z.s));
                        int p = (int)(q >> 4);
                        int sixteen = (p != 0) ? 1 : 0;
                        int t = (int)(q & 15);
                        int i;
                        if ((p != 0) && (p != 1))
                            return (int)(stbi__err("bad DQT type"));
                        if ((t) > (3))
                            return (int)(stbi__err("bad DQT table"));
                        for (i = 0; (i) < (64); ++i)
                        {
                            z.dequant[t][stbi__jpeg_dezigzag[i]] =
                                ((ushort)((sixteen) != 0 ? stbi__get16be(z.s) : stbi__get8(z.s)));
                        }
                        L -= (int)((sixteen) != 0 ? 129 : 65);
                    }
                    return (int)((L) == 0 ? 1 : 0);

                case 0xC4:
                    L = (int)(stbi__get16be(z.s) - 2);
                    while ((L) > (0))
                    {
                        int* sizes = stackalloc int[16];
                        int i;
                        int n = 0;
                        int q = (int)(stbi__get8(z.s));
                        int tc = (int)(q >> 4);
                        int th = (int)(q & 15);
                        if (((tc) > (1)) || ((th) > (3)))
                            return (int)(stbi__err("bad DHT header"));
                        for (i = 0; (i) < (16); ++i)
                        {
                            sizes[i] = (int)(stbi__get8(z.s));
                            n += (int)(sizes[i]);
                        }

                        stbi__huffman[] huff;

                        L -= (int)(17);
                        if ((tc) == 0)
                        {
                            if (stbi__build_huffman(ref z.huff_dc[th], sizes) == 0)
                                return 0;
                            huff = z.huff_dc;
                        }
                        else
                        {
                            if (stbi__build_huffman(ref z.huff_ac[th], sizes) == 0)
                                return 0;
                            huff = z.huff_ac;
                        }

                        for (i = 0; (i) < (n); ++i)
                            huff[th].values[i] = (byte)(stbi__get8(z.s));

                        if (tc != 0)
                            stbi__build_fast_ac(z.fast_ac[th], ref z.huff_ac[th]);
                        L -= (int)(n);
                    }
                    return (int)((L) == 0 ? 1 : 0);
            }

            if ((((m) >= (0xE0)) && (m <= 0xEF)) || ((m) == (0xFE)))
            {
                L = (int)(stbi__get16be(z.s));
                if ((L) < (2))
                {
                    if ((m) == (0xFE))
                        return (int)(stbi__err("bad COM len"));
                    else
                        return (int)(stbi__err("bad APP len"));
                }

                L -= (int)(2);
                if (((m) == (0xE0)) && ((L) >= (5)))
                {
                    byte* tag = stackalloc byte[5];
                    tag[0] = (byte)('J');
                    tag[1] = (byte)('F');
                    tag[2] = (byte)('I');
                    tag[3] = (byte)('F');
                    tag[4] = (byte)('\0');
                    int ok = 1;
                    int i;
                    for (i = 0; (i) < (5); ++i)
                    {
                        if (stbi__get8(z.s) != tag[i])
                            ok = 0;
                    }

                    L -= (int)(5);
                    if ((ok) != 0)
                        z.jfif = 1;
                }
                else if (((m) == (0xEE)) && ((L) >= (12)))
                {
                    byte* tag = stackalloc byte[6];
                    tag[0] = (byte)('A');
                    tag[1] = (byte)('d');
                    tag[2] = (byte)('o');
                    tag[3] = (byte)('b');
                    tag[4] = (byte)('e');
                    tag[5] = (byte)('\0');
                    int ok = 1;
                    int i;
                    for (i = 0; (i) < (6); ++i)
                    {
                        if (stbi__get8(z.s) != tag[i])
                            ok = 0;
                    }

                    L -= (int)(6);
                    if ((ok) != 0)
                    {
                        stbi__get8(z.s);
                        stbi__get16be(z.s);
                        stbi__get16be(z.s);
                        z.app14_color_transform = (int)(stbi__get8(z.s));
                        L -= (int)(6);
                    }
                }

                stbi__skip(z.s, (int)(L));
                return 1;
            }

            return (int)(stbi__err("unknown marker"));
        }

        public static int stbi__process_scan_header(JpegContext z)
        {
            int i;
            int Ls = (int)(stbi__get16be(z.s));
            z.scan_n = (int)(stbi__get8(z.s));
            if ((((z.scan_n) < (1)) || ((z.scan_n) > (4))) || ((z.scan_n) > (z.s.N)))
                return (int)(stbi__err("bad SOS component count"));
            if (Ls != 6 + 2 * z.scan_n)
                return (int)(stbi__err("bad SOS len"));
            for (i = 0; (i) < (z.scan_n); ++i)
            {
                int id = (int)(stbi__get8(z.s));
                int which;
                int q = (int)(stbi__get8(z.s));
                for (which = 0; (which) < (z.s.N); ++which)
                {
                    if ((z.img_comp[which].id) == (id))
                        break;
                }

                if ((which) == (z.s.N))
                    return 0;
                z.img_comp[which].hd = (int)(q >> 4);
                if ((z.img_comp[which].hd) > (3))
                    return (int)(stbi__err("bad DC huff"));
                z.img_comp[which].ha = (int)(q & 15);
                if ((z.img_comp[which].ha) > (3))
                    return (int)(stbi__err("bad AC huff"));
                z.order[i] = (int)(which);
            }

            {
                int aa;
                z.spec_start = (int)(stbi__get8(z.s));
                z.spec_end = (int)(stbi__get8(z.s));
                aa = (int)(stbi__get8(z.s));
                z.succ_high = (int)(aa >> 4);
                z.succ_low = (int)(aa & 15);
                if ((z.progressive) != 0)
                {
                    if ((((((z.spec_start) > (63)) || ((z.spec_end) > (63))) || ((z.spec_start) > (z.spec_end))) ||
                         ((z.succ_high) > (13))) || ((z.succ_low) > (13)))
                        return (int)(stbi__err("bad SOS"));
                }
                else
                {
                    if (z.spec_start != 0)
                        return (int)(stbi__err("bad SOS"));
                    if ((z.succ_high != 0) || (z.succ_low != 0))
                        return (int)(stbi__err("bad SOS"));
                    z.spec_end = (int)(63);
                }
            }

            return 1;
        }

        public static int stbi__free_jpeg_components(JpegContext z, int ncomp, int why)
        {
            for (int i = 0; (i) < (ncomp); ++i)
            {
                if ((z.img_comp[i].raw_data) != null)
                {
                    CRuntime.free(z.img_comp[i].raw_data);
                    z.img_comp[i].raw_data = null;
                    z.img_comp[i].data = null;
                }

                if ((z.img_comp[i].raw_coeff) != null)
                {
                    CRuntime.free(z.img_comp[i].raw_coeff);
                    z.img_comp[i].raw_coeff = null;
                    z.img_comp[i].coeff = null;
                }

                if ((z.img_comp[i].linebuf) != null)
                {
                    CRuntime.free(z.img_comp[i].linebuf);
                    z.img_comp[i].linebuf = null;
                }
            }

            return (int)(why);
        }

        public static int stbi__process_frame_header(JpegContext z, int scan)
        {
            ReadContext s = z.s;
            int Lf;
            int p;
            int i;
            int q;
            int h_max = 1;
            int v_max = 1;
            int c;
            Lf = (int)(stbi__get16be(s));
            if ((Lf) < (11))
                return (int)(stbi__err("bad SOF len"));
            p = (int)(stbi__get8(s));
            if (p != 8)
                return (int)(stbi__err("only 8-bit"));
            s.H = (uint)(stbi__get16be(s));
            if ((s.H) == 0)
                return (int)(stbi__err("no header height"));
            s.W = (uint)(stbi__get16be(s));
            if ((s.W) == 0)
                return (int)(stbi__err("0 width"));
            c = (int)(stbi__get8(s));
            if (((c != 3) && (c != 1)) && (c != 4))
                return (int)(stbi__err("bad component count"));
            s.N = (int)(c);
            for (i = 0; (i) < (c); ++i)
            {
                z.img_comp[i].data = null;
                z.img_comp[i].linebuf = null;
            }

            if (Lf != 8 + 3 * s.N)
                return (int)(stbi__err("bad SOF len"));
            z.rgb = 0;

            byte* rgb = stackalloc byte[3];
            rgb[0] = (byte)('R');
            rgb[1] = (byte)('G');
            rgb[2] = (byte)('B');
            for (i = 0; (i) < (s.N); ++i)
            {
                z.img_comp[i].id = (int)(stbi__get8(s));
                if (((s.N) == (3)) && ((z.img_comp[i].id) == (rgb[i])))
                    ++z.rgb;
                q = (int)(stbi__get8(s));
                z.img_comp[i].h = (int)(q >> 4);
                if ((z.img_comp[i].h == 0) || ((z.img_comp[i].h) > (4)))
                    return (int)(stbi__err("bad H"));
                z.img_comp[i].v = (int)(q & 15);
                if ((z.img_comp[i].v == 0) || ((z.img_comp[i].v) > (4)))
                    return (int)(stbi__err("bad V"));
                z.img_comp[i].tq = (int)(stbi__get8(s));
                if ((z.img_comp[i].tq) > (3))
                    return (int)(stbi__err("bad TQ"));
            }

            if (scan != STBI__SCAN_load)
                return 1;
            if (stbi__mad3sizes_valid((int)(s.W), (int)(s.H), (int)(s.N), 0) == 0)
                return (int)(stbi__err("too large"));

            for (i = 0; (i) < (s.N); ++i)
            {
                if ((z.img_comp[i].h) > (h_max))
                    h_max = (int)(z.img_comp[i].h);
                if ((z.img_comp[i].v) > (v_max))
                    v_max = (int)(z.img_comp[i].v);
            }

            z.img_h_max = (int)(h_max);
            z.img_v_max = (int)(v_max);
            z.img_mcu_w = (int)(h_max * 8);
            z.img_mcu_h = (int)(v_max * 8);
            z.img_mcu_x = (int)((s.W + z.img_mcu_w - 1) / z.img_mcu_w);
            z.img_mcu_y = (int)((s.H + z.img_mcu_h - 1) / z.img_mcu_h);
            for (i = 0; (i) < (s.N); ++i)
            {
                z.img_comp[i].x = (int)((s.W * z.img_comp[i].h + h_max - 1) / h_max);
                z.img_comp[i].y = (int)((s.H * z.img_comp[i].v + v_max - 1) / v_max);
                z.img_comp[i].w2 = (int)(z.img_mcu_x * z.img_comp[i].h * 8);
                z.img_comp[i].h2 = (int)(z.img_mcu_y * z.img_comp[i].v * 8);
                z.img_comp[i].coeff = null;
                z.img_comp[i].raw_coeff = null;
                z.img_comp[i].linebuf = null;
                z.img_comp[i].raw_data = stbi__malloc_mad2(
                    (int)(z.img_comp[i].w2), (int)(z.img_comp[i].h2), (int)(15));
                if ((z.img_comp[i].raw_data) == null)
                    return (int)(stbi__free_jpeg_components(z, (int)(i + 1), (int)(stbi__err("outofmem"))));

                z.img_comp[i].data = (byte*)((((long)z.img_comp[i].raw_data + 15) & ~15));
                if ((z.progressive) != 0)
                {
                    z.img_comp[i].coeff_w = (int)(z.img_comp[i].w2 / 8);
                    z.img_comp[i].coeff_h = (int)(z.img_comp[i].h2 / 8);
                    z.img_comp[i].raw_coeff = stbi__malloc_mad3(
                        (int)(z.img_comp[i].w2), (int)(z.img_comp[i].h2), (int)(2), (int)(15));

                    if ((z.img_comp[i].raw_coeff) == null)
                        return (int)(stbi__free_jpeg_components(z, (int)(i + 1), (int)(stbi__err("outofmem"))));
                    z.img_comp[i].coeff = (short*)((((long)z.img_comp[i].raw_coeff + 15) & ~15));
                }
            }

            return 1;
        }

        public static int stbi__decode_jpeg_header(JpegContext z, int scan)
        {
            z.jfif = 0;
            z.app14_color_transform = (int)(-1);
            z.marker = (byte)(0xff);

            int m = (int)(stbi__get_marker(z));
            if (!(m == 0xd8))
                return scan == STBI__SCAN_load ? (int)(stbi__err("no SOI")) : 0;
            if ((scan) == (STBI__SCAN_type))
                return 1;

            m = (int)(stbi__get_marker(z));
            while (!((((m) == (0xc0)) || ((m) == (0xc1))) || ((m) == (0xc2))))
            {
                if (stbi__process_marker(z, (int)(m)) == 0)
                    return 0;
                m = (int)(stbi__get_marker(z));
                while ((m) == (0xff))
                {
                    if ((stbi__at_eof(z.s)) != 0)
                        return (int)(stbi__err("no SOF"));
                    m = (int)(stbi__get_marker(z));
                }
            }

            z.progressive = (int)((m) == (0xc2) ? 1 : 0);
            if (stbi__process_frame_header(z, (int)(scan)) == 0)
                return 0;
            return 1;
        }

        public static int stbi__decode_jpeg_image(JpegContext j)
        {
            int m;
            for (m = 0; (m) < (4); m++)
            {
                j.img_comp[m].raw_data = null;
                j.img_comp[m].raw_coeff = null;
            }

            j.restart_interval = 0;
            if (stbi__decode_jpeg_header(j, (int)(STBI__SCAN_load)) == 0)
                return 0;
            m = (int)(stbi__get_marker(j));
            while (!((m) == (0xd9)))
            {
                if (((m) == (0xda)))
                {
                    if (stbi__process_scan_header(j) == 0)
                        return 0;
                    if (stbi__parse_entropy_coded_data(j) == 0)
                        return 0;
                    if ((j.marker) == (0xff))
                    {
                        while (stbi__at_eof(j.s) == 0)
                        {
                            int x = (int)(stbi__get8(j.s));
                            if ((x) == (255))
                            {
                                j.marker = (byte)(stbi__get8(j.s));
                                break;
                            }
                        }
                    }
                }
                else if (((m) == (0xdc)))
                {
                    int Ld = (int)(stbi__get16be(j.s));
                    uint NL = (uint)(stbi__get16be(j.s));
                    if (Ld != 4)
                        stbi__err("bad DNL len");
                    if (NL != j.s.H)
                        stbi__err("bad DNL height");
                }
                else
                {
                    if (stbi__process_marker(j, (int)(m)) == 0)
                        return 0;
                }

                m = (int)(stbi__get_marker(j));
            }

            if ((j.progressive) != 0)
                stbi__jpeg_finish(j);
            return 1;
        }

        public static byte* resample_row_1(byte* _out_, byte* in_near, byte* in_far, int w, int hs)
        {
            return in_near;
        }

        public static byte* stbi__resample_row_v_2(byte* _out_, byte* in_near, byte* in_far, int w, int hs)
        {
            int i;
            for (i = 0; (i) < (w); ++i)
            {
                _out_[i] = ((byte)((3 * in_near[i] + in_far[i] + 2) >> 2));
            }

            return _out_;
        }

        public static byte* stbi__resample_row_h_2(byte* _out_, byte* in_near, byte* in_far, int w, int hs)
        {
            int i;
            byte* input = in_near;
            if ((w) == (1))
            {
                _out_[0] = (byte)(_out_[1] = (byte)(input[0]));
                return _out_;
            }

            _out_[0] = (byte)(input[0]);
            _out_[1] = ((byte)((input[0] * 3 + input[1] + 2) >> 2));
            for (i = 1; (i) < (w - 1); ++i)
            {
                int n = (int)(3 * input[i] + 2);
                _out_[i * 2 + 0] = ((byte)((n + input[i - 1]) >> 2));
                _out_[i * 2 + 1] = ((byte)((n + input[i + 1]) >> 2));
            }

            _out_[i * 2 + 0] = ((byte)((input[w - 2] * 3 + input[w - 1] + 2) >> 2));
            _out_[i * 2 + 1] = (byte)(input[w - 1]);
            return _out_;
        }

        public static byte* stbi__resample_row_hv_2(byte* _out_, byte* in_near, byte* in_far, int w, int hs)
        {
            int i;
            int t0;
            int t1;
            if ((w) == (1))
            {
                _out_[0] = (byte)(_out_[1] = ((byte)((3 * in_near[0] + in_far[0] + 2) >> 2)));
                return _out_;
            }

            t1 = (int)(3 * in_near[0] + in_far[0]);
            _out_[0] = ((byte)((t1 + 2) >> 2));
            for (i = 1; (i) < (w); ++i)
            {
                t0 = (int)(t1);
                t1 = (int)(3 * in_near[i] + in_far[i]);
                _out_[i * 2 - 1] = ((byte)((3 * t0 + t1 + 8) >> 4));
                _out_[i * 2] = ((byte)((3 * t1 + t0 + 8) >> 4));
            }

            _out_[w * 2 - 1] = ((byte)((t1 + 2) >> 2));
            return _out_;
        }

        public static byte* stbi__resample_row_generic(byte* _out_, byte* in_near, byte* in_far, int w, int hs)
        {
            int i;
            int j;
            for (i = 0; (i) < (w); ++i)
            {
                for (j = 0; (j) < (hs); ++j)
                {
                    _out_[i * hs + j] = (byte)(in_near[i]);
                }
            }

            return _out_;
        }

        public static void stbi__YCbCr_to_RGB_row(byte* _out_, byte* y, byte* pcb, byte* pcr, int count, int step)
        {
            for (int i = 0; (i) < (count); ++i)
            {
                int y_fixed = (int)((y[i] << 20) + (1 << 19));
                int cr = (int)(pcr[i] - 128);
                int cb = (int)(pcb[i] - 128);

                int r = (int)(y_fixed + cr * (((int)((1.40200f) * 4096.0f + 0.5f)) << 8));
                int g = (int)(y_fixed + (cr * -(((int)((0.71414f) * 4096.0f + 0.5f)) << 8)) +
                     ((cb * -(((int)((0.34414f) * 4096.0f + 0.5f)) << 8)) & 0xffff0000));
                int b = (int)(y_fixed + cb * (((int)((1.77200f) * 4096.0f + 0.5f)) << 8));

                r >>= 20;
                g >>= 20;
                b >>= 20;

                if (((uint)(r)) > (255))
                    r = r < 0 ? 0 : 255;

                if (((uint)(g)) > (255))
                    g = g < 0 ? 0 : 255;

                if (((uint)(b)) > (255))
                    b = b < 0 ? 0 : 255;

                _out_[0] = (byte)r;
                _out_[1] = (byte)g;
                _out_[2] = (byte)b;
                _out_[3] = (byte)255;
                _out_ += step;
            }
        }

        public static void stbi__cleanup_jpeg(JpegContext j)
        {
            stbi__free_jpeg_components(j, (int)(j.s.N), 0);
        }

        public static byte stbi__blinn_8x8(byte x, byte y)
        {
            uint t = (uint)(x * y + 128);
            return (byte)((t + (t >> 8)) >> 8);
        }

        public static byte* load_jpeg_image(JpegContext z, ref ReadState ri)
        {
            if (ri.RequestedComponents < 0 || ri.RequestedComponents > 4)
                return ((byte*)((ulong)((stbi__err("bad req_comp")) != 0 ? ((byte*)null) : null)));

            z.s.N = 0;
            if (stbi__decode_jpeg_image(z) == 0)
            {
                stbi__cleanup_jpeg(z);
                return null;
            }

            int n = ri.RequestedComponents != 0 ? ri.RequestedComponents : z.s.N >= 3 ? 3 : 1;
            int is_rgb = z.s.N == 3 && (z.rgb == 3 || (z.app14_color_transform == 0 && z.jfif == 0)) ? 1 : 0;
            int decode_n = (z.s.N == 3 && n < 3 && is_rgb == 0) ? 1 : z.s.N;

            int k;
            uint i;
            uint j;
            byte* output;
            byte** coutput = stackalloc byte*[4];
            var res_comp = new stbi__resample[4];

            for (k = 0; (k) < (decode_n); ++k)
            {
                ref stbi__resample r = ref res_comp[k];
                z.img_comp[k].linebuf = (byte*)(CRuntime.malloc((ulong)(z.s.W + 3)));
                if (z.img_comp[k].linebuf == null)
                {
                    stbi__cleanup_jpeg(z);
                    return ((byte*)((ulong)((stbi__err("outofmem")) != 0 ? ((byte*)null) : null)));
                }

                r.hs = (int)(z.img_h_max / z.img_comp[k].h);
                r.vs = (int)(z.img_v_max / z.img_comp[k].v);
                r.ystep = (int)(r.vs >> 1);
                r.w_lores = (int)((z.s.W + r.hs - 1) / r.hs);
                r.ypos = 0;
                r.line0 = r.line1 = z.img_comp[k].data;

                if (((r.hs) == (1)) && ((r.vs) == (1)))
                    r.Resample = resample_row_1;
                else if (((r.hs) == (1)) && ((r.vs) == (2)))
                    r.Resample = stbi__resample_row_v_2;
                else if (((r.hs) == (2)) && ((r.vs) == (1)))
                    r.Resample = stbi__resample_row_h_2;
                else if (((r.hs) == (2)) && ((r.vs) == (2)))
                    r.Resample = z.resample_row_hv_2_kernel;
                else
                    r.Resample = stbi__resample_row_generic;
            }

            output = (byte*)(stbi__malloc_mad3((int)(n), (int)(z.s.W), (int)(z.s.H), 1));
            if (output == null)
            {
                stbi__cleanup_jpeg(z);
                return ((byte*)((ulong)((stbi__err("outofmem")) != 0 ? ((byte*)null) : null)));
            }

            for (j = (uint)(0); (j) < (z.s.H); ++j)
            {
                byte* _out_ = output + n * z.s.W * j;
                for (k = 0; (k) < (decode_n); ++k)
                {
                    ref stbi__resample r = ref res_comp[k];
                    int y_bot = (int)((r.ystep) >= (r.vs >> 1) ? 1 : 0);

                    coutput[k] = r.Resample(
                        z.img_comp[k].linebuf,
                        (y_bot) != 0 ? r.line1 : r.line0,
                        (y_bot) != 0 ? r.line0 : r.line1,
                        r.w_lores,
                        r.hs);

                    if ((++r.ystep) >= (r.vs))
                    {
                        r.ystep = 0;
                        r.line0 = r.line1;
                        if ((++r.ypos) < (z.img_comp[k].y))
                            r.line1 += z.img_comp[k].w2;
                    }
                }

                if ((n) >= (3))
                {
                    byte* y = coutput[0];
                    if ((z.s.N) == (3))
                    {
                        if ((is_rgb) != 0)
                        {
                            for (i = (uint)(0); (i) < (z.s.W); ++i)
                            {
                                _out_[0] = y[i];
                                _out_[1] = coutput[1][i];
                                _out_[2] = coutput[2][i];
                                _out_[3] = 255;
                                _out_ += n;
                            }
                        }
                        else
                        {
                            z.YCbCr_to_RGB_kernel(_out_, y, coutput[1], coutput[2], (int)(z.s.W), (int)(n));
                        }
                    }
                    else if ((z.s.N) == (4))
                    {
                        if ((z.app14_color_transform) == 0)
                        {
                            for (i = (uint)(0); (i) < (z.s.W); ++i)
                            {
                                byte m = (byte)(coutput[3][i]);
                                _out_[0] = stbi__blinn_8x8(coutput[0][i], m);
                                _out_[1] = stbi__blinn_8x8(coutput[1][i], m);
                                _out_[2] = stbi__blinn_8x8(coutput[2][i], m);
                                _out_[3] = 255;
                                _out_ += n;
                            }
                        }
                        else if ((z.app14_color_transform) == (2))
                        {
                            z.YCbCr_to_RGB_kernel(_out_, y, coutput[1], coutput[2], (int)(z.s.W), (int)(n));
                            for (i = (uint)(0); (i) < (z.s.W); ++i)
                            {
                                byte m = (byte)(coutput[3][i]);
                                _out_[0] = stbi__blinn_8x8((byte)(255 - _out_[0]), m);
                                _out_[1] = stbi__blinn_8x8((byte)(255 - _out_[1]), m);
                                _out_[2] = stbi__blinn_8x8((byte)(255 - _out_[2]), m);
                                _out_ += n;
                            }
                        }
                        else
                        {
                            z.YCbCr_to_RGB_kernel(_out_, y, coutput[1], coutput[2], (int)(z.s.W), (int)(n));
                        }
                    }
                    else
                        for (i = (uint)(0); (i) < (z.s.W); ++i)
                        {
                            _out_[0] = _out_[1] = _out_[2] = y[i];
                            _out_[3] = 255;
                            _out_ += n;
                        }
                }
                else
                {
                    i = 0;
                    if ((is_rgb) != 0)
                    {
                        if ((n) == (1))
                        {
                            for (; (i) < (z.s.W); ++i)
                                *_out_++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
                        }
                        else
                        {
                            for (; (i) < (z.s.W); ++i)
                            {
                                _out_[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
                                _out_[1] = 255;
                                _out_ += 2;
                            }
                        }
                    }
                    else if (((z.s.N) == (4)) && ((z.app14_color_transform) == 0))
                    {
                        for (; (i) < (z.s.W); ++i)
                        {
                            byte m = coutput[3][i];
                            byte r = stbi__blinn_8x8(coutput[0][i], m);
                            byte g = stbi__blinn_8x8(coutput[1][i], m);
                            byte b = stbi__blinn_8x8(coutput[2][i], m);
                            _out_[0] = stbi__compute_y(r, g, b);
                            _out_[1] = 255;
                            _out_ += n;
                        }
                    }
                    else if (((z.s.N) == (4)) && ((z.app14_color_transform) == (2)))
                    {
                        for (; (i) < (z.s.W); ++i)
                        {
                            _out_[0] = stbi__blinn_8x8((byte)(255 - coutput[0][i]), coutput[3][i]);
                            _out_[1] = (byte)(255);
                            _out_ += n;
                        }
                    }
                    else
                    {
                        byte* y = coutput[0];
                        i = 0;
                        if ((n) == (1))
                        {
                            for (; (i) < (z.s.W); ++i)
                                _out_[i] = (byte)(y[i]);
                        }
                        else
                        {
                            for (; (i) < (z.s.W); ++i)
                            {
                                *_out_++ = (byte)(y[i]);
                                *_out_++ = (byte)(255);
                            }
                        }
                    }
                }
            }

            stbi__cleanup_jpeg(z);

            ri.Width = (int)z.s.W;
            ri.Height = (int)z.s.H;
            ri.Components = z.s.N >= 3 ? 3 : 1;

            return output;
        }

        public static void* stbi__jpeg_load(ReadContext s, ref ReadState ri)
        {
            var j = new JpegContext(s);
            return load_jpeg_image(j, ref ri);
        }

        public static int stbi__jpeg_test(ReadContext s)
        {
            var j = new JpegContext(s);
            int r = (int)(stbi__decode_jpeg_header(j, (int)(STBI__SCAN_type)));
            stbi__rewind(s);
            return r;
        }

        public static int stbi__jpeg_info_raw(JpegContext j, out int x, out int y, out int comp)
        {
            x = 0;
            y = 0;
            comp = 0;

            if (stbi__decode_jpeg_header(j, (int)(STBI__SCAN_header)) == 0)
            {
                stbi__rewind(j.s);
                return 0;
            }

            x = (int)(j.s.W);
            y = (int)(j.s.H);
            comp = (int)((j.s.N) >= (3) ? 3 : 1);
            return 1;
        }

        public static int stbi__jpeg_info(ReadContext s, out int x, out int y, out int comp)
        {
            JpegContext j = new JpegContext(s);
            return stbi__jpeg_info_raw(j, out x, out y, out comp);
        }

        public static int stbi__bitreverse16(int n)
        {
            n = (int)(((n & 0xAAAA) >> 1) | ((n & 0x5555) << 1));
            n = (int)(((n & 0xCCCC) >> 2) | ((n & 0x3333) << 2));
            n = (int)(((n & 0xF0F0) >> 4) | ((n & 0x0F0F) << 4));
            n = (int)(((n & 0xFF00) >> 8) | ((n & 0x00FF) << 8));
            return (int)(n);
        }

        public static int stbi__bit_reverse(int v, int bits)
        {
            return (int)(stbi__bitreverse16((int)(v)) >> (16 - bits));
        }

        public static PngChunkHeader stbi__get_chunk_header(ReadContext s)
        {
            return new PngChunkHeader(
                length: (uint)(stbi__get32be(s)),
                type: (uint)(stbi__get32be(s)));
        }

        public static int stbi__check_png_header(ReadContext s)
        {
            for (int i = 0; (i) < (8); ++i)
                if (stbi__get8(s) != png_sig[i])
                    return 0;
            return 1;
        }

        public static int stbi__create_png_image_raw(
            ref PngContext a, byte* raw, uint raw_len, int out_n, uint x, uint y,
            int depth, int color)
        {
            int bytes = (int)((depth) == (16) ? 2 : 1);
            uint i;
            uint j;
            uint stride = (uint)(x * out_n * bytes);
            uint img_len;
            uint img_width_bytes;
            int k;
            int img_n = (int)(a.s.N);
            int out_bytes = (int)(out_n * bytes);
            int filter_bytes = (int)(img_n * bytes);
            int width = (int)(x);

            a._out_ = (byte*)(stbi__malloc_mad3((int)(x), (int)(y), (int)(out_bytes), 0));
            if (a._out_ == null)
                return (int)(stbi__err("outofmem"));

            img_width_bytes = (uint)(((img_n * x * depth) + 7) >> 3);
            img_len = (uint)((img_width_bytes + 1) * y);
            if ((raw_len) < (img_len))
                return (int)(stbi__err("not enough pixels"));

            for (j = (uint)(0); (j) < (y); ++j)
            {
                byte* cur = a._out_ + stride * j;
                byte* prior;
                int filter = (int)(*raw++);
                if ((filter) > (4))
                    return (int)(stbi__err("invalid filter"));

                if ((depth) < (8))
                {
                    cur += x * out_n - img_width_bytes;
                    filter_bytes = 1;
                    width = (int)(img_width_bytes);
                }

                prior = cur - stride;
                if ((j) == 0)
                    filter = (int)(first_row_filter[filter]);

                k = 0;
                switch (filter)
                {
                    case STBI__F_none:
                    case STBI__F_sub:
                    case STBI__F_avg_first:
                    case STBI__F_paeth_first:
                        for (; k < filter_bytes; ++k)
                            cur[k] = (byte)(raw[k]);
                        break;

                    case STBI__F_up:
                        for (; k < filter_bytes; ++k)
                            cur[k] = ((byte)((raw[k] + prior[k]) & 255));
                        break;

                    case STBI__F_avg:
                        for (; k < filter_bytes; ++k)
                            cur[k] = ((byte)((raw[k] + (prior[k] >> 1)) & 255));
                        break;

                    case STBI__F_paeth:
                        for (; k < filter_bytes; ++k)
                            cur[k] = ((byte)((raw[k] + CRuntime.Paeth32(0, (int)(prior[k]), 0)) & 255));
                        break;
                }

                if ((depth) == (8))
                {
                    if (img_n != out_n)
                        cur[img_n] = (byte)(255);
                    raw += img_n;
                    cur += out_n;
                    prior += out_n;
                }
                else if ((depth) == (16))
                {
                    if (img_n != out_n)
                    {
                        cur[filter_bytes] = (byte)(255);
                        cur[filter_bytes + 1] = (byte)(255);
                    }

                    raw += filter_bytes;
                    cur += out_bytes;
                    prior += out_bytes;
                }
                else
                {
                    raw += 1;
                    cur += 1;
                    prior += 1;
                }

                if (((depth) < (8)) || ((img_n) == (out_n)))
                {
                    int nk = (int)((width - 1) * filter_bytes);
                    k = 0;
                    switch (filter)
                    {
                        case STBI__F_none:
                            CRuntime.memcpy(cur, raw, (ulong)(nk));
                            break;

                        case STBI__F_sub:
                            for (; (k) < (nk); ++k)
                                cur[k] = ((byte)((raw[k] + cur[k - filter_bytes]) & 255));
                            break;

                        case STBI__F_up:
                            for (; (k) < (nk); ++k)
                                cur[k] = ((byte)((raw[k] + prior[k]) & 255));
                            break;

                        case STBI__F_avg:
                            for (; (k) < (nk); ++k)
                                cur[k] = (byte)((raw[k] + ((prior[k] + cur[k - filter_bytes]) >> 1)) & 255);
                            break;

                        case STBI__F_paeth:
                            for (; (k) < (nk); ++k)
                                cur[k] = (byte)(raw[k] + CRuntime.Paeth32(
                                    cur[k - filter_bytes], prior[k], prior[k - filter_bytes]) & 255);
                            break;

                        case STBI__F_avg_first:
                            for (; (k) < (nk); ++k)
                                cur[k] = ((byte)((raw[k] + (cur[k - filter_bytes] >> 1)) & 255));
                            break;

                        case STBI__F_paeth_first:
                            for (; (k) < (nk); ++k)
                                cur[k] = (byte)(raw[k] + CRuntime.Paeth32(cur[k - filter_bytes], 0, 0) & 255);
                            break;
                    }
                    raw += nk;
                }
                else
                {
                    i = (uint)(x - 1);
                    switch (filter)
                    {
                        case STBI__F_none:
                            for (; (i) >= (1); --i, cur[filter_bytes] = (byte)(255),
                                raw += filter_bytes, cur += out_bytes, prior += out_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                    cur[k] = (byte)(raw[k]);
                            }
                            break;

                        case STBI__F_sub:
                            for (; (i) >= (1); --i, cur[filter_bytes] = (byte)(255),
                                raw += filter_bytes, cur += out_bytes, prior += out_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                    cur[k] = ((byte)((raw[k] + cur[k - out_bytes]) & 255));
                            }
                            break;

                        case STBI__F_up:
                            for (; (i) >= (1); --i, cur[filter_bytes] = (byte)(255),
                                raw += filter_bytes, cur += out_bytes, prior += out_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                    cur[k] = ((byte)((raw[k] + prior[k]) & 255));
                            }
                            break;

                        case STBI__F_avg:
                            for (; (i) >= (1); --i, cur[filter_bytes] = (byte)(255),
                                raw += filter_bytes, cur += out_bytes, prior += out_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                    cur[k] = ((byte)((raw[k] + ((prior[k] + cur[k - out_bytes]) >> 1)) & 255));
                            }
                            break;

                        case STBI__F_paeth:
                            for (; (i) >= (1); --i, cur[filter_bytes] = (byte)(255),
                                raw += filter_bytes, cur += out_bytes, prior += out_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                    cur[k] = (byte)(raw[k] + CRuntime.Paeth32(
                                        (int)(cur[k - out_bytes]), (int)(prior[k]),
                                        (int)(prior[k - out_bytes])) & 255);
                            }
                            break;

                        case STBI__F_avg_first:
                            for (; (i) >= (1); --i, cur[filter_bytes] = (byte)(255),
                                raw += filter_bytes, cur += out_bytes, prior += out_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                    cur[k] = ((byte)((raw[k] + (cur[k - out_bytes] >> 1)) & 255));
                            }
                            break;

                        case STBI__F_paeth_first:
                            for (; (i) >= (1); --i, cur[filter_bytes] = (byte)(255),
                                raw += filter_bytes, cur += out_bytes, prior += out_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                    cur[k] = ((byte)((raw[k] + CRuntime.Paeth32(
                                        (int)(cur[k - out_bytes]), 0, 0)) & 255));
                            }
                            break;
                    }

                    if ((depth) == (16))
                    {
                        cur = a._out_ + stride * j;
                        for (i = (uint)(0); (i) < (x); ++i, cur += out_bytes)
                            cur[filter_bytes + 1] = (byte)(255);
                    }
                }
            }

            if ((depth) < (8))
            {
                for (j = (uint)(0); (j) < (y); ++j)
                {
                    byte* cur = a._out_ + stride * j;
                    byte* _in_ = a._out_ + stride * j + x * out_n - img_width_bytes;
                    byte scale = (byte)(((color) == 0) ? stbi__depth_scale_table[depth] : 1);
                    if ((depth) == (4))
                    {
                        for (k = (int)(x * img_n); (k) >= (2); k -= (int)(2), ++_in_)
                        {
                            *cur++ = (byte)(scale * (*_in_ >> 4));
                            *cur++ = (byte)(scale * ((*_in_) & 0x0f));
                        }
                        if ((k) > (0))
                            *cur++ = (byte)(scale * (*_in_ >> 4));
                    }
                    else if ((depth) == (2))
                    {
                        for (k = (int)(x * img_n); (k) >= (4); k -= (int)(4), ++_in_)
                        {
                            *cur++ = (byte)(scale * (*_in_ >> 6));
                            *cur++ = (byte)(scale * ((*_in_ >> 4) & 0x03));
                            *cur++ = (byte)(scale * ((*_in_ >> 2) & 0x03));
                            *cur++ = (byte)(scale * ((*_in_) & 0x03));
                        }

                        if ((k) > (0))
                            *cur++ = (byte)(scale * (*_in_ >> 6));
                        if ((k) > (1))
                            *cur++ = (byte)(scale * ((*_in_ >> 4) & 0x03));
                        if ((k) > (2))
                            *cur++ = (byte)(scale * ((*_in_ >> 2) & 0x03));
                    }
                    else if ((depth) == (1))
                    {
                        for (k = (int)(x * img_n); (k) >= (8); k -= (int)(8), ++_in_)
                        {
                            *cur++ = (byte)(scale * (*_in_ >> 7));
                            *cur++ = (byte)(scale * ((*_in_ >> 6) & 0x01));
                            *cur++ = (byte)(scale * ((*_in_ >> 5) & 0x01));
                            *cur++ = (byte)(scale * ((*_in_ >> 4) & 0x01));
                            *cur++ = (byte)(scale * ((*_in_ >> 3) & 0x01));
                            *cur++ = (byte)(scale * ((*_in_ >> 2) & 0x01));
                            *cur++ = (byte)(scale * ((*_in_ >> 1) & 0x01));
                            *cur++ = (byte)(scale * ((*_in_) & 0x01));
                        }
                        if ((k) > (0))
                            *cur++ = (byte)(scale * (*_in_ >> 7));
                        if ((k) > (1))
                            *cur++ = (byte)(scale * ((*_in_ >> 6) & 0x01));
                        if ((k) > (2))
                            *cur++ = (byte)(scale * ((*_in_ >> 5) & 0x01));
                        if ((k) > (3))
                            *cur++ = (byte)(scale * ((*_in_ >> 4) & 0x01));
                        if ((k) > (4))
                            *cur++ = (byte)(scale * ((*_in_ >> 3) & 0x01));
                        if ((k) > (5))
                            *cur++ = (byte)(scale * ((*_in_ >> 2) & 0x01));
                        if ((k) > (6))
                            *cur++ = (byte)(scale * ((*_in_ >> 1) & 0x01));
                    }

                    if (img_n != out_n)
                    {
                        int q;
                        cur = a._out_ + stride * j;
                        if ((img_n) == (1))
                        {
                            for (q = (int)(x - 1); (q) >= (0); --q)
                            {
                                cur[q * 2 + 1] = (byte)(255);
                                cur[q * 2 + 0] = (byte)(cur[q]);
                            }
                        }
                        else
                        {
                            for (q = (int)(x - 1); (q) >= (0); --q)
                            {
                                cur[q * 4 + 3] = (byte)(255);
                                cur[q * 4 + 2] = (byte)(cur[q * 3 + 2]);
                                cur[q * 4 + 1] = (byte)(cur[q * 3 + 1]);
                                cur[q * 4 + 0] = (byte)(cur[q * 3 + 0]);
                            }
                        }
                    }
                }
            }
            else if ((depth) == (16))
            {
                byte* cur = a._out_;
                ushort* cur16 = (ushort*)(cur);
                for (i = (uint)(0); (i) < (x * y * out_n); ++i, cur16++, cur += 2)
                    *cur16 = (ushort)((cur[0] << 8) | cur[1]);
            }

            return 1;
        }

        public static int stbi__create_png_image(
            ref PngContext a, byte* image_data, uint image_data_len, int out_n,
            int depth, int color, int interlaced)
        {
            int bytes = (int)((depth) == (16) ? 2 : 1);
            int out_bytes = (int)(out_n * bytes);

            if (interlaced == 0)
                return (int)(stbi__create_png_image_raw(
                    ref a, image_data, (uint)(image_data_len), (int)(out_n),
                    (uint)(a.s.W), (uint)(a.s.H), (int)(depth), (int)(color)));

            byte* final = (byte*)(stbi__malloc_mad3((int)(a.s.W), (int)(a.s.H), (int)(out_bytes), 0));

            int* xorig = stackalloc int[7];
            xorig[0] = 0;
            xorig[1] = (int)(4);
            xorig[2] = 0;
            xorig[3] = (int)(2);
            xorig[4] = 0;
            xorig[5] = 1;
            xorig[6] = 0;

            int* yorig = stackalloc int[7];
            yorig[0] = 0;
            yorig[1] = 0;
            yorig[2] = (int)(4);
            yorig[3] = 0;
            yorig[4] = (int)(2);
            yorig[5] = 0;
            yorig[6] = 1;

            int* xspc = stackalloc int[7];
            xspc[0] = (int)(8);
            xspc[1] = (int)(8);
            xspc[2] = (int)(4);
            xspc[3] = (int)(4);
            xspc[4] = (int)(2);
            xspc[5] = (int)(2);
            xspc[6] = 1;

            int* yspc = stackalloc int[7];
            yspc[0] = (int)(8);
            yspc[1] = (int)(8);
            yspc[2] = (int)(8);
            yspc[3] = (int)(4);
            yspc[4] = (int)(4);
            yspc[5] = (int)(2);
            yspc[6] = (int)(2);

            for (int p = 0; (p) < (7); ++p)
            {
                int i;
                int j;
                int x = (int)((a.s.W - xorig[p] + xspc[p] - 1) / xspc[p]);
                int y = (int)((a.s.H - yorig[p] + yspc[p] - 1) / yspc[p]);
                if (((x) != 0) && ((y) != 0))
                {
                    uint img_len = (uint)(((((a.s.N * x * depth) + 7) >> 3) + 1) * y);
                    if (stbi__create_png_image_raw(
                        ref a, image_data, (uint)(image_data_len), (int)(out_n),
                        (uint)(x), (uint)(y), (int)(depth), (int)(color)) == 0)
                    {
                        CRuntime.free(final);
                        return 0;
                    }

                    for (j = 0; (j) < (y); ++j)
                    {
                        for (i = 0; (i) < (x); ++i)
                        {
                            int out_y = (int)(j * yspc[p] + yorig[p]);
                            int out_x = (int)(i * xspc[p] + xorig[p]);
                            CRuntime.memcpy(
                                final + out_y * a.s.W * out_bytes + out_x * out_bytes,
                                a._out_ + (j * x + i) * out_bytes,
                                (ulong)(out_bytes));
                        }
                    }

                    CRuntime.free(a._out_);
                    image_data += img_len;
                    image_data_len -= (uint)(img_len);
                }
            }

            a._out_ = final;
            return 1;
        }

        public static int stbi__compute_transparency(ref PngContext z, byte* tc, int out_n)
        {
            ReadContext s = z.s;
            uint i;
            uint pixel_count = (uint)(s.W * s.H);
            byte* p = z._out_;
            if ((out_n) == (2))
            {
                for (i = (uint)(0); (i) < (pixel_count); ++i)
                {
                    p[1] = (byte)((p[0]) == (tc[0]) ? 0 : 255);
                    p += 2;
                }
            }
            else
            {
                for (i = (uint)(0); (i) < (pixel_count); ++i)
                {
                    if ((((p[0]) == (tc[0])) && ((p[1]) == (tc[1]))) && ((p[2]) == (tc[2])))
                        p[3] = (byte)(0);
                    p += 4;
                }
            }

            return 1;
        }

        public static int stbi__compute_transparency16(ref PngContext z, ushort* tc, int out_n)
        {
            ReadContext s = z.s;
            uint i;
            uint pixel_count = (uint)(s.W * s.H);
            ushort* p = (ushort*)(z._out_);
            if ((out_n) == (2))
            {
                for (i = (uint)(0); (i) < (pixel_count); ++i)
                {
                    p[1] = (ushort)((p[0]) == (tc[0]) ? 0 : 65535);
                    p += 2;
                }
            }
            else
            {
                for (i = (uint)(0); (i) < (pixel_count); ++i)
                {
                    if ((((p[0]) == (tc[0])) && ((p[1]) == (tc[1]))) && ((p[2]) == (tc[2])))
                        p[3] = (ushort)(0);
                    p += 4;
                }
            }

            return 1;
        }

        public static int stbi__expand_png_palette(ref PngContext a, byte* palette, int len, int pal_img_n)
        {
            uint i;
            uint pixel_count = (uint)(a.s.W * a.s.H);
            byte* p;
            byte* temp_out;
            byte* orig = a._out_;
            p = (byte*)(stbi__malloc_mad2((int)(pixel_count), (int)(pal_img_n), 0));
            if ((p) == null)
                return (int)(stbi__err("outofmem"));
            temp_out = p;
            if ((pal_img_n) == (3))
            {
                for (i = (uint)(0); (i) < (pixel_count); ++i)
                {
                    int n = (int)(orig[i] * 4);
                    p[0] = (byte)(palette[n]);
                    p[1] = (byte)(palette[n + 1]);
                    p[2] = (byte)(palette[n + 2]);
                    p += 3;
                }
            }
            else
            {
                for (i = (uint)(0); (i) < (pixel_count); ++i)
                {
                    int n = (int)(orig[i] * 4);
                    p[0] = (byte)(palette[n]);
                    p[1] = (byte)(palette[n + 1]);
                    p[2] = (byte)(palette[n + 2]);
                    p[3] = (byte)(palette[n + 3]);
                    p += 4;
                }
            }

            CRuntime.free(a._out_);
            a._out_ = temp_out;
            return 1;
        }

        public static void stbi__de_iphone(ref PngContext z)
        {
            ReadContext s = z.s;
            uint i;
            uint pixel_count = (uint)(s.W * s.H);
            byte* p = z._out_;
            if ((s.OutN) == (3))
            {
                for (i = (uint)(0); (i) < (pixel_count); ++i)
                {
                    byte t = (byte)(p[0]);
                    p[0] = (byte)(p[2]);
                    p[2] = (byte)(t);
                    p += 3;
                }
            }
            else
            {
                if ((stbi__unpremultiply_on_load) != 0)
                {
                    for (i = (uint)(0); (i) < (pixel_count); ++i)
                    {
                        byte a = (byte)(p[3]);
                        byte t = (byte)(p[0]);
                        if ((a) != 0)
                        {
                            byte half = (byte)(a / 2);
                            p[0] = (byte)((p[2] * 255 + half) / a);
                            p[1] = (byte)((p[1] * 255 + half) / a);
                            p[2] = (byte)((t * 255 + half) / a);
                        }
                        else
                        {
                            p[0] = (byte)(p[2]);
                            p[2] = (byte)(t);
                        }
                        p += 4;
                    }
                }
                else
                {
                    for (i = (uint)(0); (i) < (pixel_count); ++i)
                    {
                        byte t = (byte)(p[0]);
                        p[0] = (byte)(p[2]);
                        p[2] = (byte)(t);
                        p += 4;
                    }
                }
            }

        }

        public static int stbi__parse_png_file(ref PngContext z, int scan, int req_comp)
        {
            ReadContext s = z.s;
            z.idata = null;
            z._out_ = null;

            if (stbi__check_png_header(s) == 0)
                return scan == STBI__SCAN_type ? 0 : (int)(stbi__err("bad png sig"));
            if ((scan) == (STBI__SCAN_type))
                return 1;

            byte* palette = stackalloc byte[1024];
            byte pal_img_n = (byte)(0);
            byte has_transparency = (byte)(0);
            byte* tc = stackalloc byte[3];
            ushort* tc16 = stackalloc ushort[3];
            uint ioff = (uint)(0);
            uint idata_limit = (uint)(0);
            uint i;
            uint pal_len = (uint)(0);
            int first = 1;
            int k;
            int interlace = 0;
            int color = 0;
            bool is_iphone = false;

            for (; ; )
            {
                PngChunkHeader c = stbi__get_chunk_header(s);
                switch (c.Type)
                {
                    case PngChunkHeader.CgBI:
                        is_iphone = true;
                        stbi__skip(s, (int)(c.Length));
                        break;

                    case PngChunkHeader.IHDR:
                    {
                        int comp;
                        int filter;
                        if (first == 0)
                            return (int)(stbi__err("multiple IHDR"));
                        first = 0;

                        if (c.Length != 13)
                            return (int)(stbi__err("bad IHDR length"));

                        s.W = (uint)(stbi__get32be(s));
                        if ((s.W) > (1 << 24))
                            return (int)(stbi__err("too large"));

                        s.H = (uint)(stbi__get32be(s));
                        if ((s.H) > (1 << 24))
                            return (int)(stbi__err("too large"));

                        if ((s.W == 0) || (s.H == 0))
                            return (int)(stbi__err("0-pixel image"));

                        z.depth = (int)(stbi__get8(s));
                        if (((((z.depth != 1) && (z.depth != 2)) && (z.depth != 4)) && (z.depth != 8)) &&
                            (z.depth != 16))
                            return (int)(stbi__err("1/2/4/8/16-bit only"));

                        color = (int)(stbi__get8(s));
                        if ((color) > (6))
                            return (int)(stbi__err("bad ctype"));
                        if (((color) == (3)) && ((z.depth) == (16)))
                            return (int)(stbi__err("bad ctype"));

                        if ((color) == (3))
                            pal_img_n = (byte)(3);
                        else if ((color & 1) != 0)
                            return (int)(stbi__err("bad ctype"));

                        comp = (int)(stbi__get8(s));
                        if ((comp) != 0)
                            return (int)(stbi__err("bad comp method"));

                        filter = (int)(stbi__get8(s));
                        if ((filter) != 0)
                            return (int)(stbi__err("bad filter method"));

                        interlace = (int)(stbi__get8(s));
                        if ((interlace) > (1))
                            return (int)(stbi__err("bad interlace method"));

                        if (pal_img_n == 0)
                        {
                            s.N = (int)(((color & 2) != 0 ? 3 : 1) + ((color & 4) != 0 ? 1 : 0));
                            if (((1 << 30) / s.W / s.N) < (s.H))
                                return (int)(stbi__err("too large"));
                            if ((scan) == (STBI__SCAN_header))
                                return 1;
                        }
                        else
                        {
                            s.N = 1;
                            if (((1 << 30) / s.W / 4) < (s.H))
                                return (int)(stbi__err("too large"));
                        }
                        break;
                    }

                    case PngChunkHeader.PLTE:
                    {
                        if ((first) != 0)
                            return (int)(stbi__err("first not IHDR"));
                        if ((c.Length) > (256 * 3))
                            return (int)(stbi__err("invalid PLTE"));

                        pal_len = (uint)(c.Length / 3);
                        if (pal_len * 3 != c.Length)
                            return (int)(stbi__err("invalid PLTE"));

                        for (i = (uint)(0); (i) < (pal_len); ++i)
                        {
                            palette[i * 4 + 0] = (byte)(stbi__get8(s));
                            palette[i * 4 + 1] = (byte)(stbi__get8(s));
                            palette[i * 4 + 2] = (byte)(stbi__get8(s));
                            palette[i * 4 + 3] = (byte)(255);
                        }
                        break;
                    }

                    case PngChunkHeader.tRNS:
                    {
                        if ((first) != 0)
                            return (int)(stbi__err("first not IHDR"));
                        if ((z.idata) != null)
                            return (int)(stbi__err("tRNS after IDAT"));

                        if ((pal_img_n) != 0)
                        {
                            if ((scan) == (STBI__SCAN_header))
                            {
                                s.N = (int)(4);
                                return 1;
                            }

                            if ((pal_len) == 0)
                                return (int)(stbi__err("tRNS before PLTE"));
                            if ((c.Length) > (pal_len))
                                return (int)(stbi__err("bad tRNS len"));
                            pal_img_n = (byte)(4);
                            for (i = (uint)(0); (i) < (c.Length); ++i)
                                palette[i * 4 + 3] = (byte)(stbi__get8(s));
                        }
                        else
                        {
                            if ((s.N & 1) == 0)
                                return (int)(stbi__err("tRNS with alpha"));
                            if (c.Length != (uint)(s.N) * 2)
                                return (int)(stbi__err("bad tRNS len"));
                            has_transparency = (byte)(1);

                            if ((z.depth) == (16))
                            {
                                for (k = 0; (k) < (s.N); ++k)
                                    tc16[k] = ((ushort)(stbi__get16be(s)));
                            }
                            else
                            {
                                for (k = 0; (k) < (s.N); ++k)
                                    tc[k] = (byte)((byte)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z.depth]);
                            }
                        }
                        break;
                    }

                    case PngChunkHeader.IDAT:
                    {
                        if ((first) != 0)
                            return (int)(stbi__err("first not IHDR"));
                        if (((pal_img_n) != 0) && (pal_len == 0))
                            return (int)(stbi__err("no PLTE"));
                        if ((scan) == (STBI__SCAN_header))
                        {
                            s.N = (int)(pal_img_n);
                            return 1;
                        }

                        if (((int)(ioff + c.Length)) < ((int)(ioff)))
                            return 0;

                        if ((ioff + c.Length) > (idata_limit))
                        {
                            uint idata_limit_old = (uint)(idata_limit);
                            if ((idata_limit) == 0)
                                idata_limit = (uint)((c.Length) > (4096) ? c.Length : 4096);
                            while ((ioff + c.Length) > (idata_limit))
                                idata_limit *= (uint)(2);

                            byte* p = (byte*)(CRuntime.realloc(z.idata, (ulong)(idata_limit)));
                            if ((p) == null)
                                return (int)(stbi__err("outofmem"));
                            z.idata = p;
                        }

                        if (stbi__getn(s, z.idata + ioff, (int)(c.Length)) == 0)
                            return (int)(stbi__err("outofdata"));

                        ioff += (uint)(c.Length);
                        break;
                    }

                    case PngChunkHeader.IEND:
                    {
                        if ((first) != 0)
                            return (int)(stbi__err("first not IHDR"));
                        if (scan != STBI__SCAN_load)
                            return 1;
                        if ((z.idata) == null)
                            return (int)(stbi__err("no IDAT"));

                        uint bpl = (uint)((s.W * z.depth + 7) / 8);
                        int raw_len = (int)(bpl * s.H * s.N + s.H);
                        bool parseHeader = !is_iphone;

                        IMemoryResult decompressed;
                        try
                        {
                            var data = new ReadOnlySpan<byte>(z.idata, (int)ioff);
                            decompressed = zlib_deflate_decompress(data, raw_len, parseHeader);
                            if (decompressed == null)
                                return 0;
                        }
                        finally
                        {
                            CRuntime.free(z.idata);
                            z.idata = null;
                        }

                        try
                        {
                            if (req_comp == s.N + 1 && req_comp != 3 && pal_img_n == 0 || has_transparency != 0)
                                s.OutN = (int)(s.N + 1);
                            else
                                s.OutN = (int)(s.N);

                            if (stbi__create_png_image(
                                ref z, (byte*)decompressed.Pointer, (uint)decompressed.Length, 
                                s.OutN, z.depth, color, interlace) == 0)
                                return 0;

                            if ((has_transparency) != 0)
                            {
                                if ((z.depth) == (16))
                                    if (stbi__compute_transparency16(ref z, tc16, (int)(s.OutN)) == 0)
                                        return 0;
                                    else if (stbi__compute_transparency(ref z, tc, (int)(s.OutN)) == 0)
                                        return 0;
                            }

                            if (is_iphone && stbi__de_iphone_flag != 0 && s.OutN > 2)
                                stbi__de_iphone(ref z);

                            if ((pal_img_n) != 0)
                            {
                                s.N = (int)(pal_img_n);
                                s.OutN = (int)(pal_img_n);
                                if ((req_comp) >= (3))
                                    s.OutN = (int)(req_comp);

                                if (stbi__expand_png_palette(ref z, palette, (int)(pal_len), (int)(s.OutN)) == 0)
                                    return 0;
                            }
                            else if ((has_transparency) != 0)
                                s.N++;

                            return 1;
                        }
                        finally
                        {
                            decompressed.Dispose();
                        }
                    }

                    default:
                        if ((first) != 0)
                            return (int)(stbi__err("first not IHDR"));

                        if ((c.Type & (1 << 29)) == 0)
                        {
                            string invalid_chunk = "XXXX PNG chunk not known";
                            return (int)(stbi__err(invalid_chunk));
                        }

                        stbi__skip(s, (int)(c.Length));
                        break;
                }

                stbi__get32be(s);
            }
        }

        /// <summary>
        /// Delegate for a zlib deflate (RFC 1951) decompression implementation.
        /// </summary>
        public delegate IMemoryResult ZlibDeflateDecompressDelegate(
            ReadOnlySpan<byte> data, int expectedSize, bool parseHeader);

        /// <summary>
        /// Custom zlib deflate (RFC 1951) decompression implementation 
        /// that replaces the default <see cref="zlib_deflate_decompress"/>.
        /// </summary>
        public static ZlibDeflateDecompressDelegate CustomZlibDeflateDecompress;

        /// <summary>
        /// Decompresses data using a <see cref="DeflateStream"/>,
        /// optionally skipping the zlib (RFC 1951) headers.
        /// <para>Can be replaced by assigning <see cref="CustomZlibDeflateDecompress"/>.</para>
        /// </summary>
        private static IMemoryResult zlib_deflate_decompress(
            ReadOnlySpan<byte> compressed, int expectedSize, bool skipHeader)
        {
            int srcOffset = skipHeader ? 2 : 0;
            var resultPtr = (byte*)CRuntime.malloc(expectedSize);
            int resultLength;
            fixed (byte* dataPtr = &MemoryMarshal.GetReference(compressed))
            {
                using (var src = new UnmanagedMemoryStream(dataPtr + srcOffset, compressed.Length - srcOffset))
                using (var dst = new UnmanagedMemoryStream(resultPtr, 0, expectedSize, FileAccess.Write))
                {
                    using (var ds = new DeflateStream(src, CompressionMode.Decompress, false))
                        ds.CopyTo(dst, Math.Min(expectedSize, 1024 * 80));

                    resultLength = (int)dst.Length;
                }
            }
            return new HGlobalMemoryResult((IntPtr)resultPtr, resultLength);
        }

        public static void* stbi__do_png(
            ref PngContext p, ref ReadState ri)
        {
            if (((ri.RequestedComponents) < (0)) || ((ri.RequestedComponents) > (4)))
                return ((byte*)((ulong)((stbi__err("bad comp request")) != 0 ? ((byte*)null) : null)));

            void* result = null;
            if ((stbi__parse_png_file(ref p, (int)(STBI__SCAN_load), (int)(ri.RequestedComponents))) != 0)
            {
                if ((p.depth) < (8))
                    ri.BitsPerChannel = (int)(8);
                else
                    ri.BitsPerChannel = (int)(p.depth);

                result = p._out_;
                p._out_ = null;
                if (((ri.RequestedComponents) != 0) && (ri.RequestedComponents != p.s.OutN))
                {
                    if (ri.BitsPerChannel == 8)
                        result = stbi__convert_format((byte*)result, p.s.OutN, ri.RequestedComponents, p.s.W, p.s.H);
                    else
                        result = stbi__convert_format16((ushort*)result, p.s.OutN, ri.RequestedComponents, p.s.W, p.s.H);

                    p.s.OutN = (int)(ri.RequestedComponents);
                    if ((result) == null)
                        return result;
                }

                ri.Width = (int)(p.s.W);
                ri.Height = (int)(p.s.H);
                ri.Components = (int)(p.s.N);
            }

            CRuntime.free(p._out_);
            p._out_ = null;
            CRuntime.free(p.idata);
            p.idata = null;
            return result;
        }

        public static void* stbi__png_load(ReadContext s, ref ReadState ri)
        {
            var p = new PngContext(s);
            return stbi__do_png(ref p, ref ri);
        }

        public static int stbi__png_test(ReadContext s)
        {
            int r = (int)(stbi__check_png_header(s));
            stbi__rewind(s);
            return (int)(r);
        }

        public static bool stbi__png_info_raw(ref PngContext p, out int x, out int y, out int comp)
        {
            if (stbi__parse_png_file(ref p, (int)(STBI__SCAN_header), 0) == 0)
            {
                stbi__rewind(p.s);
                x = 0;
                y = 0;
                comp = 0;
                return false;
            }

            x = (int)(p.s.W);
            y = (int)(p.s.H);
            comp = (int)(p.s.N);
            return true;
        }

        public static bool stbi__png_info(ReadContext s, out int x, out int y, out int comp)
        {
            var p = new PngContext(s);
            return stbi__png_info_raw(ref p, out x, out y, out comp);
        }

        public static int stbi__bmp_test_raw(ReadContext s)
        {
            if (stbi__get8(s) != 'B')
                return 0;
            if (stbi__get8(s) != 'M')
                return 0;

            stbi__get32le(s);
            stbi__get16le(s);
            stbi__get16le(s);
            stbi__get32le(s);
            int sz = (int)(stbi__get32le(s));
            bool r = sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124;
            return (int)(r ? 1 : 0);
        }

        public static int stbi__bmp_test(ReadContext s)
        {
            int r = (int)(stbi__bmp_test_raw(s));
            stbi__rewind(s);
            return (int)(r);
        }

        public static int stbi__high_bit(uint z)
        {
            int n = 0;
            if ((z) == 0)
                return (int)(-1);

            if ((z) >= (0x10000))
            {
                n += (int)(16);
                z >>= 16;
            }

            if ((z) >= (0x00100))
            {
                n += (int)(8);
                z >>= 8;
            }

            if ((z) >= (0x00010))
            {
                n += (int)(4);
                z >>= 4;
            }

            if ((z) >= (0x00004))
            {
                n += (int)(2);
                z >>= 2;
            }

            if ((z) >= (0x00002))
            {
                n += 1;
                z >>= 1;
            }

            return (int)(n);
        }

        public static int stbi__bitcount(uint a)
        {
            a = (uint)((a & 0x55555555) + ((a >> 1) & 0x55555555));
            a = (uint)((a & 0x33333333) + ((a >> 2) & 0x33333333));
            a = (uint)((a + (a >> 4)) & 0x0f0f0f0f);
            a = (uint)(a + (a >> 8));
            a = (uint)(a + (a >> 16));
            return (int)(a & 0xff);
        }

        public static int stbi__shiftsigned(int v, int shift, int bits)
        {
            int result;
            int z = 0;
            if ((shift) < (0))
                v <<= -shift;
            else
                v >>= shift;
            result = (int)(v);
            z = (int)(bits);
            while ((z) < (8))
            {
                result += (int)(v >> z);
                z += (int)(bits);
            }

            return (int)(result);
        }

        public static void* stbi__bmp_parse_header(ReadContext s, BmpInfo* info)
        {
            int hsz;
            if ((stbi__get8(s) != 'B') || (stbi__get8(s) != 'M'))
                return ((byte*)((ulong)((stbi__err("not BMP")) != 0 ? ((byte*)null) : null)));
            stbi__get32le(s);
            stbi__get16le(s);
            stbi__get16le(s);
            info->offset = (int)(stbi__get32le(s));
            info->hsz = (int)(hsz = (int)(stbi__get32le(s)));
            info->mr = (uint)(info->mg = (uint)(info->mb = (uint)(info->ma = (uint)(0))));
            if (((((hsz != 12) && (hsz != 40)) && (hsz != 56)) && (hsz != 108)) && (hsz != 124))
                return ((byte*)((ulong)((stbi__err("unknown BMP")) != 0 ? ((byte*)null) : null)));
            if ((hsz) == (12))
            {
                s.W = (uint)(stbi__get16le(s));
                s.H = (uint)(stbi__get16le(s));
            }
            else
            {
                s.W = (uint)(stbi__get32le(s));
                s.H = (uint)(stbi__get32le(s));
            }

            if (stbi__get16le(s) != 1)
                return ((byte*)((ulong)((stbi__err("bad BMP")) != 0 ? ((byte*)null) : null)));
            info->bpp = (int)(stbi__get16le(s));
            if ((info->bpp) == (1))
                return ((byte*)((ulong)((stbi__err("monochrome")) != 0 ? ((byte*)null) : null)));
            if (hsz != 12)
            {
                int compress = (int)(stbi__get32le(s));
                if (((compress) == (1)) || ((compress) == (2)))
                    return ((byte*)((ulong)((stbi__err("BMP RLE")) != 0 ? ((byte*)null) : null)));
                stbi__get32le(s);
                stbi__get32le(s);
                stbi__get32le(s);
                stbi__get32le(s);
                stbi__get32le(s);
                if (((hsz) == (40)) || ((hsz) == (56)))
                {
                    if ((hsz) == (56))
                    {
                        stbi__get32le(s);
                        stbi__get32le(s);
                        stbi__get32le(s);
                        stbi__get32le(s);
                    }

                    if (((info->bpp) == (16)) || ((info->bpp) == (32)))
                    {
                        if ((compress) == 0)
                        {
                            if ((info->bpp) == (32))
                            {
                                info->mr = (uint)(0xffu << 16);
                                info->mg = (uint)(0xffu << 8);
                                info->mb = (uint)(0xffu << 0);
                                info->ma = (uint)(0xffu << 24);
                                info->all_a = (uint)(0);
                            }
                            else
                            {
                                info->mr = (uint)(31u << 10);
                                info->mg = (uint)(31u << 5);
                                info->mb = (uint)(31u << 0);
                            }
                        }
                        else if ((compress) == (3))
                        {
                            info->mr = (uint)(stbi__get32le(s));
                            info->mg = (uint)(stbi__get32le(s));
                            info->mb = (uint)(stbi__get32le(s));
                            if (((info->mr) == (info->mg)) && ((info->mg) == (info->mb)))
                            {
                                return ((byte*)((ulong)((stbi__err("bad BMP")) != 0 ? ((byte*)null) : null)));
                            }
                        }
                        else
                            return ((byte*)((ulong)((stbi__err("bad BMP")) != 0 ? ((byte*)null) : null)));
                    }
                }
                else
                {
                    int i;
                    if ((hsz != 108) && (hsz != 124))
                        return ((byte*)((ulong)((stbi__err("bad BMP")) != 0 ? ((byte*)null) : null)));

                    info->mr = (uint)(stbi__get32le(s));
                    info->mg = (uint)(stbi__get32le(s));
                    info->mb = (uint)(stbi__get32le(s));
                    info->ma = (uint)(stbi__get32le(s));
                    stbi__get32le(s);
                    for (i = 0; (i) < (12); ++i)
                        stbi__get32le(s);

                    if ((hsz) == (124))
                    {
                        stbi__get32le(s);
                        stbi__get32le(s);
                        stbi__get32le(s);
                        stbi__get32le(s);
                    }
                }
            }

            return (void*)(1);
        }

        public static void* stbi__bmp_load(ReadContext s, ref ReadState ri)
        {
            var info = new BmpInfo();
            info.all_a = (uint)(255);
            if ((stbi__bmp_parse_header(s, &info)) == null)
                return null;
            
            s.H = (uint)(CRuntime.FastAbs((int)(s.H)));
            uint mr = (uint)(info.mr);
            uint mg = (uint)(info.mg);
            uint mb = (uint)(info.mb);
            uint ma = (uint)(info.ma);
            uint all_a = (uint)(info.all_a);

            int psize = 0;
            if ((info.hsz) == (12))
                if ((info.bpp) < (24))
                    psize = (int)((info.offset - 14 - 24) / 3);
            else
                if ((info.bpp) < (16))
                    psize = (int)((info.offset - 14 - info.hsz) >> 2);

            int target;
            s.N = (int)((ma) != 0 ? 4 : 3);
            if (((ri.RequestedComponents) != 0) && ((ri.RequestedComponents) >= (3)))
                target = (int)(ri.RequestedComponents);
            else
                target = (int)(s.N);

            if (stbi__mad3sizes_valid((int)(target), (int)(s.W), (int)(s.H), 0) == 0)
                return ((byte*)((ulong)((stbi__err("too large")) != 0 ? ((byte*)null) : null)));

            byte* _out_ = (byte*)(stbi__malloc_mad3((int)(target), (int)(s.W), (int)(s.H), 0));
            if (_out_ == null)
                return ((byte*)((ulong)((stbi__err("outofmem")) != 0 ? ((byte*)null) : null)));

            int i;
            int j;
            int width;
            int pad;
            if ((info.bpp) < (16))
            {
                int z = 0;
                if (((psize) == 0) || ((psize) > (256)))
                {
                    CRuntime.free(_out_);
                    return ((byte*)((ulong)((stbi__err("invalid")) != 0 ? ((byte*)null) : null)));
                }

                byte* pal = stackalloc byte[256 * 4];
                for (i = 0; (i) < (psize); ++i)
                {
                    pal[i * 4 + 2] = (byte)(stbi__get8(s));
                    pal[i * 4 + 1] = (byte)(stbi__get8(s));
                    pal[i * 4 + 0] = (byte)(stbi__get8(s));
                    if (info.hsz != 12)
                        stbi__get8(s);
                    pal[i * 4 + 3] = (byte)(255);
                }

                stbi__skip(s, (int)(info.offset - 14 - info.hsz - psize * ((info.hsz) == (12) ? 3 : 4)));
                if ((info.bpp) == (4))
                    width = (int)((s.W + 1) >> 1);
                else if ((info.bpp) == (8))
                    width = (int)(s.W);
                else
                {
                    CRuntime.free(_out_);
                    return ((byte*)((ulong)((stbi__err("bad bpp")) != 0 ? ((byte*)null) : null)));
                }

                pad = (int)((-width) & 3);
                for (j = 0; (j) < ((int)(s.H)); ++j)
                {
                    for (i = 0; (i) < ((int)(s.W)); i += (int)(2))
                    {
                        int v = (int)(stbi__get8(s));
                        int v2 = 0;
                        if ((info.bpp) == (4))
                        {
                            v2 = (int)(v & 15);
                            v >>= 4;
                        }

                        _out_[z++] = (byte)(pal[v * 4 + 0]);
                        _out_[z++] = (byte)(pal[v * 4 + 1]);
                        _out_[z++] = (byte)(pal[v * 4 + 2]);
                        if ((target) == (4))
                            _out_[z++] = (byte)(255);
                        if ((i + 1) == ((int)(s.W)))
                            break;
                        v = (int)(((info.bpp) == (8)) ? stbi__get8(s) : v2);
                        _out_[z++] = (byte)(pal[v * 4 + 0]);
                        _out_[z++] = (byte)(pal[v * 4 + 1]);
                        _out_[z++] = (byte)(pal[v * 4 + 2]);
                        if ((target) == (4))
                            _out_[z++] = (byte)(255);
                    }

                    stbi__skip(s, (int)(pad));
                }
            }
            else
            {
                stbi__skip(s, (int)(info.offset - 14 - info.hsz));
                if ((info.bpp) == (24))
                    width = (int)(3 * s.W);
                else if ((info.bpp) == (16))
                    width = (int)(2 * s.W);
                else
                    width = 0;
                pad = (int)((-width) & 3);

                int easy = 0;
                if ((info.bpp) == (24))
                    easy = 1;
                else if ((info.bpp) == (32))
                    if ((((mb == 0xff) && (mg == 0xff00)) && (mr == 0x00ff0000)) && (ma == 0xff000000))
                        easy = (int)(2);

                int rshift = 0, gshift = 0, bshift = 0, ashift = 0;
                int rcount = 0, gcount = 0, bcount = 0, acount = 0;
                if (easy == 0)
                {
                    if (((mr == 0) || (mg == 0)) || (mb == 0))
                    {
                        CRuntime.free(_out_);
                        return stbi__err("bad masks") != 0 ? (byte*)null : null;
                    }

                    rshift = (int)(stbi__high_bit((uint)(mr)) - 7);
                    rcount = (int)(stbi__bitcount((uint)(mr)));
                    gshift = (int)(stbi__high_bit((uint)(mg)) - 7);
                    gcount = (int)(stbi__bitcount((uint)(mg)));
                    bshift = (int)(stbi__high_bit((uint)(mb)) - 7);
                    bcount = (int)(stbi__bitcount((uint)(mb)));
                    ashift = (int)(stbi__high_bit((uint)(ma)) - 7);
                    acount = (int)(stbi__bitcount((uint)(ma)));
                }

                int z = 0;
                j = 0;
                if ((easy) != 0)
                {
                    byte a;
                    for (; j < s.H; ++j)
                    {
                        for (i = 0; (i) < s.W; ++i)
                        {
                            _out_[z++] = stbi__get8(s);
                            _out_[z++] = stbi__get8(s);
                            _out_[z++] = stbi__get8(s);

                            a = (byte)(easy == 2 ? stbi__get8(s) : 255);
                            all_a |= (uint)(a);
                            if ((target) == (4))
                                _out_[z++] = (byte)(a);
                        }
                        stbi__skip(s, (int)(pad));
                    }
                }
                else
                {
                    uint v;
                    int a;
                    for (; j < s.H; ++j)
                    {
                        for (i = 0; (i) < s.W; ++i)
                        {
                            v = (uint)(info.bpp == 16 ? (uint)stbi__get16le(s) : stbi__get32le(s));
                            _out_[z++] = (byte)((stbi__shiftsigned((int)(v & mr), rshift, rcount)) & 255);
                            _out_[z++] = (byte)((stbi__shiftsigned((int)(v & mg), gshift, gcount)) & 255);
                            _out_[z++] = (byte)((stbi__shiftsigned((int)(v & mb), bshift, bcount)) & 255);

                            a = ma != 0 ? stbi__shiftsigned((int)(v & ma), ashift, acount) : 255;
                            all_a |= (uint)(a);
                            if ((target) == (4))
                                _out_[z++] = (byte)(a & 255);
                        }
                        stbi__skip(s, (int)(pad));
                    }
                }
            }

            if (((target) == (4)) && ((all_a) == 0))
                for (i = (int)(4 * s.W * s.H - 1); (i) >= (0); i -= 4)
                    _out_[i] = (byte)(255);

            int flip_vertically = (int)(((int)(s.H)) > (0) ? 1 : 0);
            if ((flip_vertically) != 0)
            {
                byte t;
                for (j = 0; (j) < ((int)(s.H) >> 1); ++j)
                {
                    byte* p1 = _out_ + j * s.W * target;
                    byte* p2 = _out_ + (s.H - 1 - j) * s.W * target;
                    for (i = 0; (i) < ((int)(s.W) * target); ++i)
                    {
                        t = (byte)(p1[i]);
                        p1[i] = (byte)(p2[i]);
                        p2[i] = (byte)(t);
                    }
                }
            }

            if (((ri.RequestedComponents) != 0) && (ri.RequestedComponents != target))
            {
                _out_ = stbi__convert_format(_out_, target, ri.RequestedComponents, s.W, s.H);
                if ((_out_) == null)
                    return _out_;
            }

            ri.Width = (int)(s.W);
            ri.Height = (int)(s.H);
            ri.Components = (int)(s.N);

            return _out_;
        }

        public static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
        {
            if ((is_rgb16) != null)
                *is_rgb16 = 0;

            switch (bits_per_pixel)
            {
                case 8:
                    return (int)(STBI_grey);

                case 15:
                case 16:
                    if (((bits_per_pixel) == (16)) && ((is_grey) != 0))
                        return (int)(STBI_grey_alpha);
                    if ((is_rgb16) != null)
                        *is_rgb16 = 1;
                    return (int)(STBI_rgb);

                case 24:
                case 32:
                    return (int)(bits_per_pixel / 8);

                default:
                    return 0;
            }
        }

        public static int stbi__tga_info(ReadContext s, int* x, int* y, int* comp)
        {
            stbi__get8(s);
            int tga_colormap_type = (int)(stbi__get8(s));
            if ((tga_colormap_type) > (1))
            {
                stbi__rewind(s);
                return 0;
            }

            int sz;
            int tga_colormap_bpp;
            int tga_image_type = (int)(stbi__get8(s));
            if ((tga_colormap_type) == (1))
            {
                if ((tga_image_type != 1) && (tga_image_type != 9))
                {
                    stbi__rewind(s);
                    return 0;
                }

                stbi__skip(s, (int)(4));
                sz = (int)(stbi__get8(s));
                if (((((sz != 8) && (sz != 15)) && (sz != 16)) && (sz != 24)) && (sz != 32))
                {
                    stbi__rewind(s);
                    return 0;
                }

                stbi__skip(s, (int)(4));
                tga_colormap_bpp = (int)(sz);
            }
            else
            {
                if (tga_image_type != 2 && tga_image_type != 3 && 
                    tga_image_type != 10 && tga_image_type != 11)
                {
                    stbi__rewind(s);
                    return 0;
                }

                stbi__skip(s, (int)(9));
                tga_colormap_bpp = 0;
            }

            int tga_w = (int)(stbi__get16le(s));
            if ((tga_w) < (1))
            {
                stbi__rewind(s);
                return 0;
            }

            int tga_h = (int)(stbi__get16le(s));
            if ((tga_h) < (1))
            {
                stbi__rewind(s);
                return 0;
            }

            int tga_comp;
            int tga_bits_per_pixel = (int)(stbi__get8(s));
            stbi__get8(s);
            if (tga_colormap_bpp != 0)
            {
                if ((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16))
                {
                    stbi__rewind(s);
                    return 0;
                }
                tga_comp = (int)(stbi__tga_get_comp((int)(tga_colormap_bpp), 0, null));
            }
            else
            {
                tga_comp = stbi__tga_get_comp(tga_bits_per_pixel,
                    tga_image_type == 3 || tga_image_type == 11 ? 1 : 0, null);
            }

            if (tga_comp == 0)
            {
                stbi__rewind(s);
                return 0;
            }

            if ((x) != null)
                *x = (int)(tga_w);
            if ((y) != null)
                *y = (int)(tga_h);
            if ((comp) != null)
                *comp = (int)(tga_comp);
            return 1;
        }

        public static int stbi__tga_test(ReadContext s)
        {
            int res = 0;
            stbi__get8(s);
            int tga_color_type = (int)(stbi__get8(s));
            if ((tga_color_type) > (1))
                goto ErrorEnd;

            int sz = (int)(stbi__get8(s));
            if ((tga_color_type) == (1))
            {
                if ((sz != 1) && (sz != 9))
                    goto ErrorEnd;
                stbi__skip(s, (int)(4));
                sz = (int)(stbi__get8(s));
                if (((((sz != 8) && (sz != 15)) && (sz != 16)) && (sz != 24)) && (sz != 32))
                    goto ErrorEnd;
                stbi__skip(s, (int)(4));
            }
            else
            {
                if ((((sz != 2) && (sz != 3)) && (sz != 10)) && (sz != 11))
                    goto ErrorEnd;
                stbi__skip(s, (int)(9));
            }

            if ((stbi__get16le(s)) < (1))
                goto ErrorEnd;
            if ((stbi__get16le(s)) < (1))
                goto ErrorEnd;

            sz = (int)(stbi__get8(s));
            if ((((tga_color_type) == (1)) && (sz != 8)) && (sz != 16))
                goto ErrorEnd;
            if (((((sz != 8) && (sz != 15)) && (sz != 16)) && (sz != 24)) && (sz != 32))
                goto ErrorEnd;

            res = 1;

        ErrorEnd:
            stbi__rewind(s);
            return (int)(res);
        }

        public static void stbi__tga_read_rgb16(ReadContext s, byte* _out_)
        {
            ushort px = (ushort)(stbi__get16le(s));
            ushort fiveBitMask = (ushort)(31);
            int r = (int)((px >> 10) & fiveBitMask);
            int g = (int)((px >> 5) & fiveBitMask);
            int b = (int)(px & fiveBitMask);
            _out_[0] = ((byte)((r * 255) / 31));
            _out_[1] = ((byte)((g * 255) / 31));
            _out_[2] = ((byte)((b * 255) / 31));
        }

        public static void* stbi__tga_load(ReadContext s, ref ReadState ri)
        {
            int tga_offset = (int)(stbi__get8(s));
            int tga_indexed = (int)(stbi__get8(s));
            int tga_image_type = (int)(stbi__get8(s));
            int tga_is_RLE = 0;
            int tga_palette_start = (int)(stbi__get16le(s));
            int tga_palette_len = (int)(stbi__get16le(s));
            int tga_palette_bits = (int)(stbi__get8(s));
            int tga_x_origin = (int)(stbi__get16le(s));
            int tga_y_origin = (int)(stbi__get16le(s));
            int tga_width = (int)(stbi__get16le(s));
            int tga_height = (int)(stbi__get16le(s));
            int tga_bits_per_pixel = (int)(stbi__get8(s));
            int tga_comp;
            int tga_rgb16 = 0;
            int tga_inverted = (int)(stbi__get8(s));

            if ((tga_image_type) >= (8))
            {
                tga_image_type -= (int)(8);
                tga_is_RLE = 1;
            }

            tga_inverted = (int)(1 - ((tga_inverted >> 5) & 1));
            if ((tga_indexed) != 0)
                tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
            else
                tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, tga_image_type == 3 ? 1 : 0, &tga_rgb16);

            if (tga_comp == 0)
                return ((byte*)((ulong)((stbi__err("bad format")) != 0 ? ((byte*)null) : null)));

            ri.Width = (int)(tga_width);
            ri.Height = (int)(tga_height);
            ri.Components = (int)(tga_comp);

            if (stbi__mad3sizes_valid((int)(tga_width), (int)(tga_height), (int)(tga_comp), 0) == 0)
                return ((byte*)((ulong)((stbi__err("too large")) != 0 ? ((byte*)null) : null)));

            int i;
            int j;
            byte* raw_data = stackalloc byte[4];
            raw_data[0] = (byte)(0);

            byte* tga_data = (byte*)(stbi__malloc_mad3((int)(tga_width), (int)(tga_height), (int)(tga_comp), 0));
            if (tga_data == null)
                return ((byte*)((ulong)((stbi__err("outofmem")) != 0 ? ((byte*)null) : null)));

            stbi__skip(s, (int)(tga_offset));
            if (((tga_indexed == 0) && (tga_is_RLE == 0)) && (tga_rgb16 == 0))
            {
                for (i = 0; (i) < (tga_height); ++i)
                {
                    int row = (int)((tga_inverted) != 0 ? tga_height - i - 1 : i);
                    byte* tga_row = tga_data + row * tga_width * tga_comp;
                    stbi__getn(s, tga_row, (int)(tga_width * tga_comp));
                }
            }
            else
            {
                byte* tga_palette = null;
                if ((tga_indexed) != 0)
                {
                    stbi__skip(s, (int)(tga_palette_start));
                    tga_palette = (byte*)(stbi__malloc_mad2((int)(tga_palette_len), (int)(tga_comp), 0));
                    if (tga_palette == null)
                    {
                        CRuntime.free(tga_data);
                        return ((byte*)((ulong)((stbi__err("outofmem")) != 0 ? ((byte*)null) : null)));
                    }

                    if ((tga_rgb16) != 0)
                    {
                        byte* pal_entry = tga_palette;
                        for (i = 0; (i) < (tga_palette_len); ++i)
                        {
                            stbi__tga_read_rgb16(s, pal_entry);
                            pal_entry += tga_comp;
                        }
                    }
                    else if (stbi__getn(s, tga_palette, (int)(tga_palette_len * tga_comp)) == 0)
                    {
                        CRuntime.free(tga_data);
                        CRuntime.free(tga_palette);
                        return ((byte*)((ulong)((stbi__err("bad palette")) != 0 ? ((byte*)null) : null)));
                    }
                }

                int RLE_count = 0;
                int RLE_repeating = 0;
                int read_next_pixel = 1;

                for (i = 0; (i) < (tga_width * tga_height); ++i)
                {
                    if ((tga_is_RLE) != 0)
                    {
                        if ((RLE_count) == 0)
                        {
                            int RLE_cmd = (int)(stbi__get8(s));
                            RLE_count = (int)(1 + (RLE_cmd & 127));
                            RLE_repeating = (int)(RLE_cmd >> 7);
                            read_next_pixel = 1;
                        }
                        else if (RLE_repeating == 0)
                            read_next_pixel = 1;
                    }
                    else
                        read_next_pixel = 1;

                    if ((read_next_pixel) != 0)
                    {
                        if ((tga_indexed) != 0)
                        {
                            int pal_idx = (int)(((tga_bits_per_pixel) == (8)) ? stbi__get8(s) : stbi__get16le(s));
                            if ((pal_idx) >= (tga_palette_len))
                                pal_idx = 0;

                            pal_idx *= (int)(tga_comp);
                            for (j = 0; (j) < (tga_comp); ++j)
                                raw_data[j] = (byte)(tga_palette[pal_idx + j]);
                        }
                        else if ((tga_rgb16) != 0)
                            stbi__tga_read_rgb16(s, raw_data);
                        else
                            for (j = 0; (j) < (tga_comp); ++j)
                                raw_data[j] = (byte)(stbi__get8(s));

                        read_next_pixel = 0;
                    }

                    for (j = 0; (j) < (tga_comp); ++j)
                        tga_data[i * tga_comp + j] = (byte)(raw_data[j]);

                    --RLE_count;
                }

                if ((tga_inverted) != 0)
                {
                    for (j = 0; (j * 2) < (tga_height); ++j)
                    {
                        int index1 = (int)(j * tga_width * tga_comp);
                        int index2 = (int)((tga_height - 1 - j) * tga_width * tga_comp);
                        for (i = (int)(tga_width * tga_comp); (i) > (0); --i)
                        {
                            byte temp = (byte)(tga_data[index1]);
                            tga_data[index1] = (byte)(tga_data[index2]);
                            tga_data[index2] = (byte)(temp);
                            ++index1;
                            ++index2;
                        }
                    }
                }

                if (tga_palette != null)
                    CRuntime.free(tga_palette);
            }

            if (((tga_comp) >= (3)) && (tga_rgb16 == 0))
            {
                byte* tga_pixel = tga_data;
                for (i = 0; (i) < (tga_width * tga_height); ++i)
                {
                    byte tmp = (byte)(tga_pixel[0]);
                    tga_pixel[0] = (byte)(tga_pixel[2]);
                    tga_pixel[2] = (byte)(tmp);
                    tga_pixel += tga_comp;
                }
            }

            if (((ri.RequestedComponents) != 0) && (ri.RequestedComponents != tga_comp))
                tga_data = stbi__convert_format(tga_data, tga_comp, ri.RequestedComponents, (uint)tga_width, (uint)tga_height);
            //tga_palette_start = tga_palette_len = tga_palette_bits = tga_x_origin = tga_y_origin = 0; // why
            return tga_data;
        }

        public static int stbi__psd_test(ReadContext s)
        {
            int r = (((stbi__get32be(s)) == (0x38425053))) ? 1 : 0;
            stbi__rewind(s);
            return (int)(r);
        }

        public static int stbi__psd_decode_rle(ReadContext s, byte* p, int pixelCount)
        {
            int len;
            int nleft;
            int count = 0;
            while ((nleft = (int)(pixelCount - count)) > (0))
            {
                len = (int)(stbi__get8(s));
                if ((len) == (128))
                {
                }
                else if ((len) < (128))
                {
                    len++;
                    if ((len) > (nleft))
                        return 0;

                    count += (int)(len);
                    while ((len) != 0)
                    {
                        *p = (byte)(stbi__get8(s));
                        p += 4;
                        len--;
                    }
                }
                else if ((len) > (128))
                {
                    len = (int)(257 - len);
                    if ((len) > (nleft))
                        return 0;

                    int val = (byte)(stbi__get8(s));
                    count += (int)(len);
                    while ((len) != 0)
                    {
                        *p = (byte)(val);
                        p += 4;
                        len--;
                    }
                }
            }

            return 1;
        }

        public static void* stbi__psd_load(ReadContext s, ref ReadState ri)
        {
            if (stbi__get32be(s) != 0x38425053)
                return ((byte*)((ulong)((stbi__err("not PSD")) != 0 ? ((byte*)null) : null)));
            if (stbi__get16be(s) != 1)
                return ((byte*)((ulong)((stbi__err("wrong version")) != 0 ? ((byte*)null) : null)));

            stbi__skip(s, (int)(6));
            int channelCount = (int)(stbi__get16be(s));
            if (((channelCount) < (0)) || ((channelCount) > (16)))
                return ((byte*)((ulong)((stbi__err("wrong channel count")) != 0 ? ((byte*)null) : null)));

            int h = (int)(stbi__get32be(s));
            int w = (int)(stbi__get32be(s));
            int bitdepth = (int)(stbi__get16be(s));
            if ((bitdepth != 8) && (bitdepth != 16))
                return ((byte*)((ulong)((stbi__err("unsupported bit depth")) != 0 ? ((byte*)null) : null)));
            if (stbi__get16be(s) != 3)
                return ((byte*)((ulong)((stbi__err("wrong color format")) != 0 ? ((byte*)null) : null)));

            stbi__skip(s, (int)(stbi__get32be(s)));
            stbi__skip(s, (int)(stbi__get32be(s)));
            stbi__skip(s, (int)(stbi__get32be(s)));
            int compression = (int)(stbi__get16be(s));
            if ((compression) > (1))
                return ((byte*)((ulong)((stbi__err("bad compression")) != 0 ? ((byte*)null) : null)));
            if (stbi__mad3sizes_valid((int)(4), (int)(w), (int)(h), 0) == 0)
                return ((byte*)((ulong)((stbi__err("too large")) != 0 ? ((byte*)null) : null)));

            byte* _out_;
            if (compression == 0 && bitdepth == 16 && ri.BitsPerChannel == 16)
                _out_ = (byte*)(stbi__malloc_mad3(8, w, h, 0));
            else
                _out_ = (byte*)(CRuntime.malloc((ulong)(4 * w * h)));

            if (_out_ == null)
                return ((byte*)((ulong)((stbi__err("outofmem")) != 0 ? ((byte*)null) : null)));

            int i;
            int pixelCount = (int)(w * h);
            if ((compression) != 0)
            {
                stbi__skip(s, (int)(h * channelCount * 2));
                for (int channel = 0; (channel) < (4); channel++)
                {
                    byte* p;
                    p = _out_ + channel;
                    if ((channel) >= (channelCount))
                    {
                        for (i = 0; (i) < (pixelCount); i++, p += 4)
                            *p = (byte)((channel) == (3) ? 255 : 0);
                    }
                    else
                    {
                        if (stbi__psd_decode_rle(s, p, (int)(pixelCount)) == 0)
                        {
                            CRuntime.free(_out_);
                            return ((byte*)((ulong)((stbi__err("corrupt")) != 0 ? ((byte*)null) : null)));
                        }
                    }
                }
            }
            else
            {
                for (int channel = 0; (channel) < (4); channel++)
                {
                    if ((channel) >= (channelCount))
                    {
                        if (((bitdepth) == (16)) && ((ri.BitsPerChannel) == (16)))
                        {
                            ushort* q = ((ushort*)(_out_)) + channel;
                            ushort val = (ushort)((channel) == (3) ? 65535 : 0);
                            for (i = 0; (i) < (pixelCount); i++, q += 4)
                                *q = (ushort)(val);
                        }
                        else
                        {
                            byte* p = _out_ + channel;
                            byte val = (byte)((channel) == (3) ? 255 : 0);
                            for (i = 0; (i) < (pixelCount); i++, p += 4)
                                *p = (byte)(val);
                        }
                    }
                    else
                    {
                        if ((ri.BitsPerChannel) == (16))
                        {
                            ushort* q = ((ushort*)(_out_)) + channel;
                            for (i = 0; (i) < (pixelCount); i++, q += 4)
                                *q = ((ushort)(stbi__get16be(s)));
                        }
                        else
                        {
                            byte* p = _out_ + channel;
                            if ((bitdepth) == (16))
                            {
                                for (i = 0; (i) < (pixelCount); i++, p += 4)
                                    *p = ((byte)(stbi__get16be(s) >> 8));
                            }
                            else
                            {
                                for (i = 0; (i) < (pixelCount); i++, p += 4)
                                    *p = (byte)(stbi__get8(s));
                            }
                        }
                    }
                }
            }

            if ((channelCount) >= (4))
            {
                if ((ri.BitsPerChannel) == (16))
                {
                    for (i = 0; (i) < (w * h); ++i)
                    {
                        ushort* pixel = (ushort*)(_out_) + 4 * i;
                        if ((pixel[3] != 0) && (pixel[3] != 65535))
                        {
                            float a = (float)(pixel[3] / 65535.0f);
                            float ra = (float)(1f / a);
                            float inv_a = (float)(65535.0f * (1 - ra));
                            pixel[0] = ((ushort)(pixel[0] * ra + inv_a));
                            pixel[1] = ((ushort)(pixel[1] * ra + inv_a));
                            pixel[2] = ((ushort)(pixel[2] * ra + inv_a));
                        }
                    }
                }
                else
                {
                    for (i = 0; (i) < (w * h); ++i)
                    {
                        byte* pixel = _out_ + 4 * i;
                        if ((pixel[3] != 0) && (pixel[3] != 255))
                        {
                            float a = (float)(pixel[3] / 255f);
                            float ra = (float)(1f / a);
                            float inv_a = (float)(255f * (1 - ra));
                            pixel[0] = ((byte)(pixel[0] * ra + inv_a));
                            pixel[1] = ((byte)(pixel[1] * ra + inv_a));
                            pixel[2] = ((byte)(pixel[2] * ra + inv_a));
                        }
                    }
                }
            }

            if (((ri.RequestedComponents) != 0) && (ri.RequestedComponents != 4))
            {
                if ((ri.BitsPerChannel) == (16))
                    _out_ = (byte*)(stbi__convert_format16((ushort*)_out_, 4, ri.RequestedComponents, (uint)w, (uint)h));
                else
                    _out_ = stbi__convert_format(_out_, 4, ri.RequestedComponents, (uint)w, (uint)h);

                if ((_out_) == null)
                    return null;
            }

            ri.Width = w;
            ri.Height = h;
            ri.Components = 4;
            return _out_;
        }

        public static int stbi__gif_test_raw(ReadContext s)
        {
            int sz;
            if ((((stbi__get8(s) != 'G') || (stbi__get8(s) != 'I')) || (stbi__get8(s) != 'F')) ||
                (stbi__get8(s) != '8'))
                return 0;
            sz = (int)(stbi__get8(s));
            if ((sz != '9') && (sz != '7'))
                return 0;
            if (stbi__get8(s) != 'a')
                return 0;
            return 1;
        }

        public static int stbi__gif_test(ReadContext s)
        {
            int r = (int)(stbi__gif_test_raw(s));
            stbi__rewind(s);
            return (int)(r);
        }

        public static int stbi__gif_header(
            ReadContext s, ref GifContext g, ref ReadState ri, bool skipColorTable)
        {
            byte version;
            if ((((stbi__get8(s) != 'G') || (stbi__get8(s) != 'I')) || (stbi__get8(s) != 'F')) ||
                (stbi__get8(s) != '8'))
                return (int)(stbi__err("not GIF"));
            version = (byte)(stbi__get8(s));
            if ((version != '7') && (version != '9'))
                return (int)(stbi__err("not GIF"));
            if (stbi__get8(s) != 'a')
                return (int)(stbi__err("not GIF"));

            g.w = (int)(stbi__get16le(s));
            g.h = (int)(stbi__get16le(s));
            g.flags = (int)(stbi__get8(s));
            g.bgindex = (int)(stbi__get8(s));
            g.ratio = (int)(stbi__get8(s));
            g.transparent = (int)(-1);
            ri.Components = 4;
            if (skipColorTable)
                return 1;

            if ((g.flags & 0x80) != 0)
                stbi__gif_parse_colortable(s, g.pal, (int)(2 << (g.flags & 7)), (int)(-1));
            return 1;
        }

        public static void stbi__out_gif_code(ref GifContext g, ushort code)
        {
            byte* p;
            byte* c;
            if ((g.codes[code].prefix) >= (0))
                stbi__out_gif_code(ref g, (ushort)(g.codes[code].prefix));
            if ((g.cur_y) >= (g.max_y))
                return;
            p = &g._out_[g.cur_x + g.cur_y];
            c = &g.color_table[g.codes[code].suffix * 4];
            if ((c[3]) >= (128))
            {
                p[0] = (byte)(c[2]);
                p[1] = (byte)(c[1]);
                p[2] = (byte)(c[0]);
                p[3] = (byte)(c[3]);
            }

            g.cur_x += (int)(4);
            if ((g.cur_x) >= (g.max_x))
            {
                g.cur_x = (int)(g.start_x);
                g.cur_y += (int)(g.step);
                while (((g.cur_y) >= (g.max_y)) && ((g.parse) > (0)))
                {
                    g.step = (int)((1 << g.parse) * g.line_size);
                    g.cur_y = (int)(g.start_y + (g.step >> 1));
                    --g.parse;
                }
            }

        }

        public static byte* stbi__process_gif_raster(ReadContext s, ref GifContext g)
        {
            byte lzw_cs = (byte)(stbi__get8(s));
            if ((lzw_cs) > (12))
                return null;

            int clear = (int)(1 << lzw_cs);
            uint first = (uint)(1);
            int codesize = (int)(lzw_cs + 1);
            int codemask = (int)((1 << codesize) - 1);
            int bits = 0;
            int valid_bits = 0;
            for (int init_code = 0; (init_code) < (clear); init_code++)
            {
                (g.codes)[init_code].prefix = (short)(-1);
                (g.codes)[init_code].first = ((byte)(init_code));
                (g.codes)[init_code].suffix = ((byte)(init_code));
            }

            GifLzw* p;
            int avail = (int)(clear + 2);
            int oldcode = (int)(-1);
            int len = 0;
            for (; ; )
            {
                if ((valid_bits) < (codesize))
                {
                    if ((len) == 0)
                    {
                        len = (int)(stbi__get8(s));
                        if ((len) == 0)
                            return g._out_;
                    }

                    --len;
                    bits |= (int)((int)(stbi__get8(s)) << valid_bits);
                    valid_bits += (int)(8);
                }
                else
                {
                    int code = (int)(bits & codemask);
                    bits >>= codesize;
                    valid_bits -= (int)(codesize);
                    if ((code) == (clear))
                    {
                        codesize = (int)(lzw_cs + 1);
                        codemask = (int)((1 << codesize) - 1);
                        avail = (int)(clear + 2);
                        oldcode = (int)(-1);
                        first = (uint)(0);
                    }
                    else if ((code) == (clear + 1))
                    {
                        stbi__skip(s, (int)(len));
                        while ((len = (int)(stbi__get8(s))) > (0))
                        {
                            stbi__skip(s, (int)(len));
                        }

                        return g._out_;
                    }
                    else if (code <= avail)
                    {
                        if ((first) != 0)
                            return ((byte*)((ulong)((stbi__err("no clear code")) != 0 ? ((byte*)null) : null)));
                        if ((oldcode) >= (0))
                        {
                            p = (GifLzw*)g.codes + avail++;
                            if ((avail) > (4096))
                                return ((byte*)((ulong)((stbi__err("too many codes")) != 0 ? ((byte*)null) : null)));

                            p->prefix = ((short)(oldcode));
                            p->first = (byte)(g.codes[oldcode].first);
                            p->suffix = (byte)(((code) == (avail)) ? p->first : g.codes[code].first);
                        }
                        else if ((code) == (avail))
                            return ((byte*)((ulong)((stbi__err("illegal code in raster")) != 0
                                ? ((byte*)null)
                                : null)));

                        stbi__out_gif_code(ref g, (ushort)(code));
                        if (((avail & codemask) == 0) && (avail <= 0x0FFF))
                        {
                            codesize++;
                            codemask = (int)((1 << codesize) - 1);
                        }

                        oldcode = (int)(code);
                    }
                    else
                    {
                        return ((byte*)((ulong)((stbi__err("illegal code in raster")) != 0 ? ((byte*)null) : null)));
                    }
                }
            }
        }

        public static void stbi__fill_gif_background(ref GifContext g, int x0, int y0, int x1, int y1)
        {
            int x;
            int y;
            byte* c = (byte*)g.pal + g.bgindex;
            for (y = (int)(y0); (y) < (y1); y += (int)(4 * g.w))
            {
                for (x = (int)(x0); (x) < (x1); x += (int)(4))
                {
                    byte* p = &g._out_[y + x];
                    p[0] = (byte)(c[2]);
                    p[1] = (byte)(c[1]);
                    p[2] = (byte)(c[0]);
                    p[3] = (byte)(0);
                }
            }
        }

        public static void stbi__gif_parse_colortable(ReadContext s, byte* pal, int num_entries, int transp)
        {
            for (int i = 0; (i) < (num_entries); ++i)
            {
                pal[i * 4 + 3] = (byte)(transp == i ? 0 : 255);
                pal[i * 4 + 2] = stbi__get8(s);
                pal[i * 4 + 1] = stbi__get8(s);
                pal[i * 4] = stbi__get8(s);
            }
        }

        public static byte* stbi__gif_load_next(
            ReadContext s, ref GifContext g, ref ReadState ri, byte* two_back)
        {
            int dispose = 0;
            int first_frame = 0;
            int pi = 0;
            int pcount = 0;
            first_frame = 0;
            if ((g._out_) == null)
            {
                if (stbi__gif_header(s, ref g, ref ri, skipColorTable: false) == 0)
                    return null;
                if (stbi__mad3sizes_valid((int)(4), (int)(g.w), (int)(g.h), 0) == 0)
                    return ((byte*)((ulong)((stbi__err("too large")) != 0 ? ((byte*)null) : null)));

                pcount = (int)(g.w * g.h);
                g._out_ = (byte*)(CRuntime.malloc((ulong)(4 * pcount)));
                g.background = (byte*)(CRuntime.malloc((ulong)(4 * pcount)));
                g.history = (byte*)(CRuntime.malloc((ulong)(pcount)));
                if (((g._out_ == null) || (g.background == null)) || (g.history == null))
                    return ((byte*)((ulong)((stbi__err("outofmem")) != 0 ? ((byte*)null) : null)));

                CRuntime.memset(g._out_, (int)(0x00), (ulong)(4 * pcount));
                CRuntime.memset(g.background, (int)(0x00), (ulong)(4 * pcount));
                CRuntime.memset(g.history, (int)(0x00), (ulong)(pcount));
                first_frame = 1;
            }
            else
            {
                dispose = (int)((g.eflags & 0x1C) >> 2);
                pcount = (int)(g.w * g.h);
                if (((dispose) == (3)) && ((two_back) == null))
                    dispose = (int)(2);

                if ((dispose) == (3))
                {
                    for (pi = 0; (pi) < (pcount); ++pi)
                    {
                        if ((g.history[pi]) != 0)
                            CRuntime.memcpy(&g._out_[pi * 4], &two_back[pi * 4], (ulong)(4));
                    }
                }
                else if ((dispose) == (2))
                {
                    for (pi = 0; (pi) < (pcount); ++pi)
                    {
                        if ((g.history[pi]) != 0)
                            CRuntime.memcpy(&g._out_[pi * 4], &g.background[pi * 4], (ulong)(4));
                    }
                }
                CRuntime.memcpy(g.background, g._out_, (ulong)(4 * g.w * g.h));
            }

            CRuntime.memset(g.history, (int)(0x00), (ulong)(g.w * g.h));
            for (; ; )
            {
                int tag = (int)(stbi__get8(s));
                switch (tag)
                {
                    case 0x2C:
                    {
                        int x = (int)(stbi__get16le(s));
                        int y = (int)(stbi__get16le(s));
                        int w = (int)(stbi__get16le(s));
                        int h = (int)(stbi__get16le(s));
                        if (((x + w) > (g.w)) || ((y + h) > (g.h)))
                            return ((byte*)((ulong)((stbi__err("bad Image Descriptor")) != 0 ? ((byte*)null) : null)));

                        g.line_size = (int)(g.w * 4);
                        g.start_x = (int)(x * 4);
                        g.start_y = (int)(y * g.line_size);
                        g.max_x = (int)(g.start_x + w * 4);
                        g.max_y = (int)(g.start_y + h * g.line_size);
                        g.cur_x = (int)(g.start_x);
                        g.cur_y = (int)(g.start_y);
                        if ((w) == 0)
                            g.cur_y = (int)(g.max_y);
                        g.lflags = (int)(stbi__get8(s));
                        if ((g.lflags & 0x40) != 0)
                        {
                            g.step = (int)(8 * g.line_size);
                            g.parse = (int)(3);
                        }
                        else
                        {
                            g.step = (int)(g.line_size);
                            g.parse = 0;
                        }
                        if ((g.lflags & 0x80) != 0)
                        {
                            stbi__gif_parse_colortable(s, g.lpal, (int)(2 << (g.lflags & 7)), (int)((g.eflags & 0x01) != 0 ? g.transparent : -1));
                            g.color_table = (byte*)(g.lpal);
                        }
                        else if ((g.flags & 0x80) != 0)
                        {
                            g.color_table = (byte*)(g.pal);
                        }
                        else
                            return ((byte*)((ulong)((stbi__err("missing color table")) != 0 ? ((byte*)null) : null)));

                        byte* o = stbi__process_gif_raster(s, ref g);
                        if (o == null)
                            return null;

                        pcount = (int)(g.w * g.h);
                        if (((first_frame) != 0) && ((g.bgindex) > (0)))
                        {
                            for (pi = 0; (pi) < (pcount); ++pi)
                            {
                                if ((g.history[pi]) == 0)
                                {
                                    g.pal[g.bgindex * 4 + 3] = (byte)(255);
                                    CRuntime.memcpy(&g._out_[pi * 4], &g.pal[g.bgindex], (ulong)(4));
                                }
                            }
                        }
                        return o;
                    }

                    case 0x21:
                    {
                        int len = 0;
                        int ext = (int)(stbi__get8(s));
                        if ((ext) == (0xF9))
                        {
                            len = (int)(stbi__get8(s));
                            if ((len) == (4))
                            {
                                g.eflags = (int)(stbi__get8(s));
                                g.delay = (int)(10 * stbi__get16le(s));
                                if ((g.transparent) >= (0))
                                {
                                    g.pal[g.transparent * 4 + 3] = (byte)(255);
                                }
                                if ((g.eflags & 0x01) != 0)
                                {
                                    g.transparent = (int)(stbi__get8(s));
                                    if ((g.transparent) >= (0))
                                    {
                                        g.pal[g.transparent * 4 + 3] = (byte)(0);
                                    }
                                }
                                else
                                {
                                    stbi__skip(s, 1);
                                    g.transparent = (int)(-1);
                                }
                            }
                            else
                            {
                                stbi__skip(s, (int)(len));
                                break;
                            }
                        }
                        while ((len = (int)(stbi__get8(s))) != 0)
                            stbi__skip(s, (int)(len));
                        break;
                    }

                    case 0x3B:
                        return null;

                    default:
                        return ((byte*)((ulong)((stbi__err("unknown code")) != 0 ? ((byte*)null) : null)));
                }
            }
        }

        public static void* stbi__load_gif_main(
            ReadContext s, int** delays, out int layers, ref ReadState ri)
        {
            layers = 0;
            if ((stbi__gif_test(s)) != 0)
            {
                byte* u = null;
                byte* _out_ = null;
                byte* two_back = null;
                int stride = 0;

                if ((delays) != null)
                    *delays = null;

                var g = GifContext.Create();
                try
                {
                    {
                        do
                        {
                            u = stbi__gif_load_next(s, ref g, ref ri, two_back);
                            if ((u) != null)
                            {
                                ri.Width = (int)(g.w);
                                ri.Height = (int)(g.h);
                                layers++;
                                stride = (int)(g.w * g.h * 4);
                                if ((_out_) != null)
                                {
                                    _out_ = (byte*)(CRuntime.realloc(_out_, (ulong)(layers * stride)));
                                    if ((delays) != null)
                                        *delays = (int*)(CRuntime.realloc(*delays, (ulong)(sizeof(int) * layers)));
                                }
                                else
                                {
                                    _out_ = (byte*)(CRuntime.malloc((ulong)(layers * stride)));
                                    if ((delays) != null)
                                        *delays = (int*)(CRuntime.malloc((ulong)(layers * sizeof(int))));
                                }
                                CRuntime.memcpy(_out_ + ((layers - 1) * stride), u, (ulong)(stride));
                                if ((layers) >= (2))
                                    two_back = _out_ - 2 * stride;

                                if ((delays) != null)
                                    (*delays)[layers - 1U] = (int)(g.delay);
                            }
                        }
                        while (u != null);

                        CRuntime.free(g._out_);
                        CRuntime.free(g.history);
                        CRuntime.free(g.background);

                        if (ri.RequestedComponents != 0 && ri.RequestedComponents != 4)
                            _out_ = stbi__convert_format(_out_, 4, ri.RequestedComponents, (uint)(layers * g.w), (uint)g.h);

                        return _out_;
                    }
                }
                finally
                {
                    g.Dispose();
                }
            }
            else
            {
                return ((byte*)((ulong)((stbi__err("not GIF")) != 0 ? ((byte*)null) : null)));
            }
        }

        public static void* stbi__gif_load(ReadContext s, ref ReadState ri)
        {
            var g = GifContext.Create();
            try
            {
                byte* u = stbi__gif_load_next(s, ref g, ref ri, null);
                if ((u) != null)
                {
                    ri.Width = (int)(g.w);
                    ri.Height = (int)(g.h);
                    if (ri.RequestedComponents != 0 && ri.RequestedComponents != 4)
                        u = stbi__convert_format(u, 4, ri.RequestedComponents, (uint)g.w, (uint)g.h);
                }
                else if ((g._out_) != null)
                    CRuntime.free(g._out_);
                return u;
            }
            finally
            {
                g.Dispose();
            }
        }

        public static int stbi__gif_info(ReadContext s, out int x, out int y, out int comp)
        {
            x = 0;
            y = 0;
            comp = 0;

            var g = GifContext.Create();
            try
            {
                ReadState ri = default;
                if (stbi__gif_header(s, ref g, ref ri, skipColorTable: true) == 0)
                {
                    stbi__rewind(s);
                    return 0;
                }

                x = ri.Width;
                y = ri.Height;
                comp = ri.Components;
                return 1;
            }
            finally
            {
                g.Dispose();
            }
        }

        public static bool stbi__bmp_info(ReadContext s, out int x, out int y, out int comp)
        {
            void* p;
            BmpInfo info = new BmpInfo();
            info.all_a = (uint)(255);
            p = stbi__bmp_parse_header(s, &info);
            stbi__rewind(s);

            x = (int)(s.W);
            y = (int)(s.H);
            comp = (int)((info.ma) != 0 ? 4 : 3);
            return (p) != null;
        }

        public static int stbi__psd_info(ReadContext s, int* x, int* y, int* comp)
        {
            int channelCount;
            int dummy;
            if (x == null)
                x = &dummy;
            if (y == null)
                y = &dummy;
            if (comp == null)
                comp = &dummy;
            if (stbi__get32be(s) != 0x38425053)
            {
                stbi__rewind(s);
                return 0;
            }

            if (stbi__get16be(s) != 1)
            {
                stbi__rewind(s);
                return 0;
            }

            stbi__skip(s, (int)(6));
            channelCount = (int)(stbi__get16be(s));
            if (((channelCount) < (0)) || ((channelCount) > (16)))
            {
                stbi__rewind(s);
                return 0;
            }

            *y = (int)(stbi__get32be(s));
            *x = (int)(stbi__get32be(s));
            if (stbi__get16be(s) != 8)
            {
                stbi__rewind(s);
                return 0;
            }

            if (stbi__get16be(s) != 3)
            {
                stbi__rewind(s);
                return 0;
            }

            *comp = (int)(4);
            return 1;
        }

        /*
        public static int stbi__info_main(ReadContext s, int* x, int* y, int* comp)
        {
            if ((stbi__jpeg_info(s, x, y, comp)) != 0)
                return 1;
            if ((stbi__png_info(s, x, y, comp)) != 0)
                return 1;
            if ((stbi__gif_info(s, x, y, comp)) != 0)
                return 1;
            if ((stbi__bmp_info(s, x, y, comp)) != 0)
                return 1;
            if ((stbi__psd_info(s, x, y, comp)) != 0)
                return 1;
            if ((stbi__tga_info(s, x, y, comp)) != 0)
                return 1;
            return (int)(stbi__err("unknown image type"));
        }

        public static int stbi_info_from_memory(byte* buffer, int len, int* x, int* y, int* comp)
        {
            ReadContext s = new ReadContext();
            stbi__start_mem(s, buffer, (int)(len));
            return (int)(stbi__info_main(s, x, y, comp));
        }

        public static int stbi_info_from_callbacks(
            stbi_io_callbacks c, Stream stream, byte[] buffer, int* x, int* y, int* comp)
        {
            ReadContext s = new ReadContext();
            stbi__start_callbacks(s, c, stream, buffer);
            return (int)(stbi__info_main(s, x, y, comp));
        }
        */
    }
}