// Generated by Sichem at 1/6/2018 7:16:35 PM

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Runtime.InteropServices;

namespace StbSharp
{
    public static unsafe partial class StbImage
    {
        // TODO move to the ReadContext
        public static int stbi__unpremultiply_on_load = 1;
        public static int stbi__de_iphone_flag = 1;

        [StructLayout(LayoutKind.Sequential)]
        public struct stbi__huffman
        {
            public const int len_fast = 1 << 9;

            public fixed byte fast[len_fast];
            public fixed ushort code[256];
            public fixed byte values[256];
            public fixed byte size[257];
            public fixed uint maxcode[18];
            public fixed int delta[17];
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct stbi__zhuffman
        {
            public fixed ushort fast[1 << 9];
            public fixed ushort firstcode[16];
            public fixed int maxcode[17];
            public fixed ushort firstsymbol[16];
            public fixed byte size[288];
            public fixed ushort value[288];
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct stbi__zbuf
        {
            public byte* zbuffer;
            public byte* zbuffer_end;
            public int num_bits;
            public uint code_buffer;
            public byte* zout;
            public byte* zout_start;
            public byte* zout_end;
            public int z_expandable;
            public stbi__zhuffman z_length;
            public stbi__zhuffman z_distance;
        }

        [StructLayout(LayoutKind.Sequential)]
        public readonly struct PngChunkHeader
        {
            public const uint CgBI = ('C' << 24) + ('g' << 16) + ('B' << 8) + 'I';
            public const uint IHDR = ('I' << 24) + ('H' << 16) + ('D' << 8) + 'R';
            public const uint PLTE = ('P' << 24) + ('L' << 16) + ('T' << 8) + 'E';
            public const uint tRNS = ('t' << 24) + ('R' << 16) + ('N' << 8) + 'S';
            public const uint IDAT = ('I' << 24) + ('D' << 16) + ('A' << 8) + 'T';
            public const uint IEND = ('I' << 24) + ('E' << 16) + ('N' << 8) + 'D';

            public readonly uint Length;
            public readonly uint Type;

            public PngChunkHeader(uint length, uint type)
            {
                Length = length;
                Type = type;
            }
        }

        public struct PngContext
        {
            public readonly ReadContext s;

            public byte* idata;
            public byte* _out_;

            public PngContext(ReadContext s) : this()
            {
                this.s = s;
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct BmpInfo
        {
            public int bpp;
            public int offset;
            public int hsz;
            public uint mr;
            public uint mg;
            public uint mb;
            public uint ma;
            public uint all_a;
        }

        public const int STBI_default = 0;
        public const int STBI_grey = 1;
        public const int STBI_grey_alpha = 2;
        public const int STBI_rgb = 3;
        public const int STBI_rgb_alpha = 4;

        public const int STBI__SCAN_load = 0;
        public const int STBI__SCAN_type = 1;
        public const int STBI__SCAN_header = 2;
        public const int STBI__F_none = 0;
        public const int STBI__F_sub = 1;
        public const int STBI__F_up = 2;
        public const int STBI__F_avg = 3;
        public const int STBI__F_paeth = 4;
        public const int STBI__F_avg_first = 5;
        public const int STBI__F_paeth_first = 6;

        internal static uint[] stbi__bmask =
        {
            0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535
        };

        internal static int[] stbi__jbias =
        {
            0, -1, -3, -7, -15, -31, -63, -127, -255, -511, -1023, -2047, -4095, -8191, -16383, -32767
        };

        internal static byte[] stbi__jpeg_dezigzag =
        {
            0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40,
            48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29,
            22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54,
            47, 55, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63
        };

        internal static byte[] png_sig = { 137, 80, 78, 71, 13, 10, 26, 10 };

        internal static byte[] first_row_filter =
        {
            STBI__F_none, STBI__F_sub, STBI__F_none, STBI__F_avg_first, STBI__F_paeth_first
        };

        internal static byte[] stbi__depth_scale_table = { 0, 0xff, 0x55, 0, 0x11, 0, 0, 0, 0x01 };

        public static void stbi__rewind(ReadContext s)
        {
            s.Data = s.DataOriginal;
            s.DataEnd = s.DataOriginalEnd;
        }

        public static int stbi__addsizes_valid(int a, int b)
        {
            if ((b) < (0))
                return 0;
            return (a <= 2147483647 - b) ? 1 : 0;
        }

        public static int stbi__mul2sizes_valid(int a, int b)
        {
            if (((a) < (0)) || ((b) < (0)))
                return 0;
            if ((b) == 0)
                return 1;
            return (a <= 2147483647 / b) ? 1 : 0;
        }

        public static int stbi__mad2sizes_valid(int a, int b, int add)
        {
            return (int)
                (((stbi__mul2sizes_valid((int)(a), (int)(b))) != 0) &&
                 ((stbi__addsizes_valid((int)(a * b), (int)(add))) != 0)
                    ? 1
                    : 0);
        }

        public static int stbi__mad3sizes_valid(int a, int b, int c, int add)
        {
            return
                (int)
                ((((stbi__mul2sizes_valid((int)(a), (int)(b))) != 0) &&
                  ((stbi__mul2sizes_valid((int)(a * b), (int)(c))) != 0)) &&
                 ((stbi__addsizes_valid((int)(a * b * c), (int)(add))) != 0)
                    ? 1
                    : 0);
        }

        public static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
        {
            return
                (int)
                (((((stbi__mul2sizes_valid((int)(a), (int)(b))) != 0) &&
                   ((stbi__mul2sizes_valid((int)(a * b), (int)(c))) != 0)) &&
                  ((stbi__mul2sizes_valid((int)(a * b * c), (int)(d))) != 0)) &&
                 ((stbi__addsizes_valid((int)(a * b * c * d), (int)(add))) != 0)
                    ? 1
                    : 0);
        }

        public static void* stbi__malloc_mad2(int a, int b, int add)
        {
            if (stbi__mad2sizes_valid((int)(a), (int)(b), (int)(add)) == 0)
                return null;
            return CRuntime.MAlloc(a * b + add);
        }

        public static void* stbi__malloc_mad3(int a, int b, int c, int add)
        {
            int length;

            if (stbi__mad3sizes_valid((int)(a), (int)(b), (int)(c), (int)(add)) == 0)
            {
                length = 0;
                return null;
            }
            length = a * b * c + add;
            return CRuntime.MAlloc(length);
        }

        public static void* stbi__malloc_mad4(int a, int b, int c, int d, int add)
        {
            if (stbi__mad4sizes_valid((int)(a), (int)(b), (int)(c), (int)(d), (int)(add)) == 0)
                return null;
            return CRuntime.MAlloc(a * b * c * d + add);
        }

        public static void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
        {
            stbi__vertically_flip_on_load = (int)(flag_true_if_should_flip);
        }

        public static IMemoryResult stbi__load_main(ReadContext s, ref ReadState ri)
        {
            if ((stbi__jpeg_test(s)) != 0)
                return stbi__jpeg_load(s, ref ri);
            if ((stbi__png_test(s)) != 0)
                return stbi__png_load(s, ref ri);
            if ((stbi__bmp_test(s)) != 0)
                return stbi__bmp_load(s, ref ri);
            if ((stbi__gif_test(s)) != 0)
                return stbi__gif_load(s, ref ri);
            if ((stbi__psd_test(s)) != 0)
                return stbi__psd_load(s, ref ri);
            if ((stbi__tga_test(s)) != 0)
                return stbi__tga_load(s, ref ri);

            stbi__err("unknown image type");
            return null;
        }

        public static IMemoryResult stbi__convert_16_to_8(IMemoryResult orig, int w, int h, int components)
        {
            int img_len = (int)(w * h * components);
            if (orig.Length != img_len * 2)
            {
                stbi__err("invalid image length");
                return null;
            }

            byte* reduced = (byte*)(CRuntime.MAlloc(img_len));
            if ((reduced) == null)
            {
                stbi__err("outofmem");
                return null;
            }

            using (orig)
            {
                var origPtr = (ushort*)orig.Pointer;
                for (int i = 0; (i) < (img_len); ++i)
                    reduced[i] = ((byte)((origPtr[i] >> 8) & 0xFF));
            }
            return new HGlobalMemoryResult(reduced, img_len);
        }

        public static IMemoryResult stbi__convert_8_to_16(IMemoryResult orig, int w, int h, int components)
        {
            int img_len = (int)(w * h * components);
            if (orig.Length != img_len)
            {
                stbi__err("invalid image length");
                return null;
            }

            int enlarged_len = img_len * 2;
            ushort* enlarged = (ushort*)(CRuntime.MAlloc(enlarged_len));
            if ((enlarged) == null)
            {
                stbi__err("outofmem");
                return null;
            }

            using (orig)
            {
                var origPtr = (byte*)orig.Pointer;
                for (int i = 0; (i) < (img_len); ++i)
                    enlarged[i] = ((ushort)((origPtr[i] << 8) + origPtr[i]));

                return new HGlobalMemoryResult(enlarged, enlarged_len);
            }
        }

        public static void stbi__vertical_flip(byte* imageBytes, int w, int h, int bytesPerComp)
        {
            int bytes_per_row = w * bytesPerComp;
            byte* tmp = stackalloc byte[2048];
            for (int row = 0; (row) < (h >> 1); row++)
            {
                byte* row0 = imageBytes + row * bytes_per_row;
                byte* row1 = imageBytes + (h - row - 1) * bytes_per_row;
                int bytes_left = bytes_per_row;
                while ((bytes_left) != 0)
                {
                    int bytes_copy = bytes_left < 2048 ? bytes_left : 2048;
                    CRuntime.MemCopy(tmp, row0, bytes_copy);
                    CRuntime.MemCopy(row0, row1, bytes_copy);
                    CRuntime.MemCopy(row1, tmp, bytes_copy);
                    row0 += bytes_copy;
                    row1 += bytes_copy;
                    bytes_left -= bytes_copy;
                }
            }
        }

        public static void stbi__vertical_flip(IMemoryResult imageBytes, int w, int h, int bytesPerComp)
        {
            stbi__vertical_flip((byte*)imageBytes.Pointer, w, h, bytesPerComp);
        }

        public static IMemoryResult stbi__load_and_postprocess_8bit(
            ReadContext s, int req_comp, out ReadState ri)
        {
            ri = new ReadState(req_comp, 8);
            var result = stbi__load_main(s, ref ri);
            if ((result) == null)
                return null;

            if (ri.OutDepth != 8)
            {
                result = stbi__convert_16_to_8(result, ri.Width, ri.Height, ri.OutComponents);
                ri.OutDepth = (int)(8);
            }

            if ((stbi__vertically_flip_on_load) != 0)
            {
                stbi__vertical_flip(result, ri.Width, ri.Height, ri.OutComponents);
            }

            return result;
        }

        public static IMemoryResult stbi__load_and_postprocess_16bit(
            ReadContext s, int req_comp, out ReadState ri)
        {
            ri = new ReadState(req_comp, 16);
            var result = stbi__load_main(s, ref ri);
            if ((result) == null)
                return null;

            if (ri.OutDepth != 16)
            {
                result = stbi__convert_8_to_16(result, ri.Width, ri.Height, ri.OutComponents);
                ri.OutDepth = 16;
            }

            if ((stbi__vertically_flip_on_load) != 0)
            {
                stbi__vertical_flip(result, ri.Width, ri.Height, ri.OutComponents * 2);
            }

            return result;
        }

        public static void stbi__refill_buffer(ReadContext s)
        {
            int n = (int)(s.Read(s, new Span<byte>(s.DataStart, (int)(s.DataLength))));
            if ((n) == 0)
            {
                s.ReadFromCallbacks = false;
                s.Data = s.DataStart;
                s.DataEnd = s.DataStart;
                s.DataEnd++;
                *s.Data = 0;
            }
            else
            {
                s.Data = s.DataStart;
                s.DataEnd = s.DataStart;
                s.DataEnd += n;
            }
        }

        public static byte stbi__get8(ReadContext s)
        {
            if ((s.Data) < (s.DataEnd))
                return (byte)(*s.Data++);

            if (s.ReadFromCallbacks)
            {
                stbi__refill_buffer(s);
                return (byte)(*s.Data++);
            }

            return 0;
        }

        public static int stbi__at_eof(ReadContext s)
        {
            if ((s.Read) != null)
            {
                if (s.Stream.CanRead)
                    return 0; // not at eof

                if (s.ReadFromCallbacks)
                    return 1;
            }

            return (int)((s.Data) >= (s.DataEnd) ? 1 : 0);
        }

        public static void stbi__skip(ReadContext s, int n)
        {
            if ((n) < (0))
            {
                s.Data = s.DataEnd;
                return;
            }

            if ((s.Read) != null)
            {
                int blen = (int)(s.DataEnd - s.Data);
                if ((blen) < (n))
                {
                    s.Data = s.DataEnd;
                    s.Skip(s, (int)(n - blen));
                    return;
                }
            }

            s.Data += n;
        }

        public static int stbi__getn(ReadContext s, byte* buffer, int n)
        {
            if ((s.Read) != null)
            {
                int blen = (int)(s.DataEnd - s.Data);
                if ((blen) < (n))
                {
                    int res;
                    int count;
                    CRuntime.MemCopy(buffer, s.Data, blen);
                    count = (int)(s.Read(s, new Span<byte>(buffer + blen, n - blen)));
                    res = (int)((count) == (n - blen) ? 1 : 0);
                    s.Data = s.DataEnd;
                    return (int)(res);
                }
            }

            if (s.Data + n <= s.DataEnd)
            {
                CRuntime.MemCopy(buffer, s.Data, n);
                s.Data += n;
                return 1;
            }
            else
                return 0;
        }

        public static int stbi__get16be(ReadContext s)
        {
            int z = (int)(stbi__get8(s));
            return (int)((z << 8) + stbi__get8(s));
        }

        public static uint stbi__get32be(ReadContext s)
        {
            uint z = (uint)(stbi__get16be(s));
            return (uint)((z << 16) + stbi__get16be(s));
        }

        public static int stbi__get16le(ReadContext s)
        {
            int z = (int)(stbi__get8(s));
            return (int)(z + (stbi__get8(s) << 8));
        }

        public static uint stbi__get32le(ReadContext s)
        {
            uint z = (uint)(stbi__get16le(s));
            return (uint)(z + (stbi__get16le(s) << 16));
        }

        public static byte stbi__compute_y(int r, int g, int b)
        {
            return (byte)(((r * 77) + (g * 150) + (29 * b)) >> 8);
        }

        public static IMemoryResult stbi__convert_format8(
            IMemoryResult data, int img_n, int req_comp, int width, int height)
        {
            if ((req_comp) == (img_n))
                return data;

            int goodLength = req_comp * width * height;
            byte* good = (byte*)(stbi__malloc_mad3((int)(req_comp), (int)(width), (int)(height), 0));
            if ((good) == null)
            {
                data.Dispose();
                stbi__err("outofmem");
                return null;
            }

            using (data)
            {
                int i;
                var dataPtr = (byte*)data.Pointer;

                for (int j = 0; (j) < ((int)(height)); ++j)
                {
                    byte* src = dataPtr + j * width * img_n;
                    byte* dest = good + j * width * req_comp;

                    switch (img_n * 8 + req_comp)
                    {
                        case ((1) * 8 + 2):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 1, dest += 2)
                            {
                                dest[0] = (byte)(src[0]);
                                dest[1] = 255;
                            }
                            break;

                        case ((1) * 8 + (3)):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 1, dest += 3)
                                dest[0] = (byte)(dest[1] = (byte)(dest[2] = (byte)(src[0])));
                            break;

                        case ((1) * 8 + (4)):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 1, dest += 4)
                            {
                                dest[0] = (byte)(dest[1] = (byte)(dest[2] = (byte)(src[0])));
                                dest[3] = 255;
                            }
                            break;

                        case (2 * 8 + (1)):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 2, dest += 1)
                                dest[0] = (byte)(src[0]);
                            break;

                        case (2 * 8 + (3)):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 2, dest += 3)
                                dest[0] = (byte)(dest[1] = (byte)(dest[2] = (byte)(src[0])));
                            break;

                        case (2 * 8 + (4)):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 2, dest += 4)
                            {
                                dest[0] = (byte)(dest[1] = (byte)(dest[2] = (byte)(src[0])));
                                dest[3] = (byte)(src[1]);
                            }
                            break;

                        case ((3) * 8 + (4)):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 3, dest += 4)
                            {
                                dest[0] = (byte)(src[0]);
                                dest[1] = (byte)(src[1]);
                                dest[2] = (byte)(src[2]);
                                dest[3] = 255;
                            }
                            break;

                        case ((3) * 8 + (1)):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 3, dest += 1)
                                dest[0] = (byte)(stbi__compute_y((int)(src[0]), (int)(src[1]), (int)(src[2])));
                            break;

                        case ((3) * 8 + 2):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 3, dest += 2)
                            {
                                dest[0] = (byte)(stbi__compute_y((int)(src[0]), (int)(src[1]), (int)(src[2])));
                                dest[1] = 255;
                            }
                            break;

                        case ((4) * 8 + (1)):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 4, dest += 1)
                                dest[0] = (byte)(stbi__compute_y((int)(src[0]), (int)(src[1]), (int)(src[2])));
                            break;

                        case ((4) * 8 + 2):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 4, dest += 2)
                                dest[0] = (byte)(stbi__compute_y((int)(src[0]), (int)(src[1]), (int)(src[2])));
                            dest[1] = (byte)(src[3]);
                            break;

                        case ((4) * 8 + (3)):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 4, dest += 3)
                                dest[0] = (byte)(src[0]);
                            dest[1] = (byte)(src[1]);
                            dest[2] = (byte)(src[2]);
                            break;

                        default:
                            stbi__err("0");
                            return null;
                    }
                }
                return new HGlobalMemoryResult(good, goodLength);
            }
        }

        public static ushort stbi__compute_y_16(int r, int g, int b)
        {
            return (ushort)(((r * 77) + (g * 150) + (29 * b)) >> 8);
        }

        public static IMemoryResult stbi__convert_format16(
            IMemoryResult data, int img_n, int req_comp, int width, int height)
        {
            if ((req_comp) == (img_n))
                return data;

            int goodLength = req_comp * width * height * 2;
            ushort* good = (ushort*)(CRuntime.MAlloc(goodLength));
            if ((good) == null)
            {
                data.Dispose();
                stbi__err("outofmem");
                return null;
            }

            using (data)
            {
                int i;
                var dataPtr = (ushort*)data.Pointer;

                for (int j = 0; (j) < ((int)(height)); ++j)
                {
                    ushort* src = dataPtr + j * width * img_n;
                    ushort* dest = good + j * width * req_comp;

                    switch (((img_n) * 8 + (req_comp)))
                    {
                        case ((1) * 8 + 2):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 1, dest += 2)
                            {
                                dest[0] = (ushort)(src[0]);
                                dest[1] = (ushort)(0xffff);
                            }
                            break;

                        case ((1) * 8 + (3)):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 1, dest += 3)
                                dest[0] = (ushort)(dest[1] = (ushort)(dest[2] = (ushort)(src[0])));
                            break;

                        case ((1) * 8 + (4)):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 1, dest += 4)
                            {
                                dest[0] = (ushort)(dest[1] = (ushort)(dest[2] = (ushort)(src[0])));
                                dest[3] = (ushort)(0xffff);
                            }
                            break;

                        case (2 * 8 + (1)):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 2, dest += 1)
                                dest[0] = (ushort)(src[0]);
                            break;

                        case (2 * 8 + (3)):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 2, dest += 3)
                                dest[0] = (ushort)(dest[1] = (ushort)(dest[2] = (ushort)(src[0])));
                            break;

                        case (2 * 8 + (4)):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 2, dest += 4)
                            {
                                dest[0] = (ushort)(dest[1] = (ushort)(dest[2] = (ushort)(src[0])));
                                dest[3] = (ushort)(src[1]);
                            }
                            break;

                        case ((3) * 8 + (4)):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 3, dest += 4)
                            {
                                dest[0] = (ushort)(src[0]);
                                dest[1] = (ushort)(src[1]);
                                dest[2] = (ushort)(src[2]);
                                dest[3] = (ushort)(0xffff);
                            }
                            break;

                        case ((3) * 8 + (1)):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 3, dest += 1)
                                dest[0] = (ushort)(stbi__compute_y_16((int)(src[0]), (int)(src[1]), (int)(src[2])));
                            break;

                        case ((3) * 8 + 2):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 3, dest += 2)
                                dest[0] = (ushort)(stbi__compute_y_16((int)(src[0]), (int)(src[1]), (int)(src[2])));
                            dest[1] = (ushort)(0xffff);
                            break;

                        case ((4) * 8 + (1)):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 4, dest += 1)
                                dest[0] = (ushort)(stbi__compute_y_16((int)(src[0]), (int)(src[1]), (int)(src[2])));
                            break;

                        case ((4) * 8 + 2):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 4, dest += 2)
                            {
                                dest[0] = (ushort)(stbi__compute_y_16((int)(src[0]), (int)(src[1]), (int)(src[2])));
                                dest[1] = (ushort)(src[3]);
                            }
                            break;

                        case ((4) * 8 + (3)):
                            for (i = (int)(width - 1); (i) >= (0); --i, src += 4, dest += 3)
                            {
                                dest[0] = (ushort)(src[0]);
                                dest[1] = (ushort)(src[1]);
                                dest[2] = (ushort)(src[2]);
                            }
                            break;

                        default:
                            stbi__err("0");
                            return null;
                    }
                }
                return new HGlobalMemoryResult(good, goodLength);
            }
        }

        public static IMemoryResult stbi__convert_format(IMemoryResult data, ref ReadState ri)
        {
            int requestedDepth = ri.RequestedDepth.GetValueOrDefault();
            if (ri.RequestedDepth.HasValue && ri.OutDepth != requestedDepth)
            {
                if (requestedDepth == 8)
                    data = stbi__convert_16_to_8(data, ri.Width, ri.Height, ri.OutComponents);
                else if (requestedDepth == 16)
                    data = stbi__convert_8_to_16(data, ri.Width, ri.Height, ri.OutComponents);

                ri.OutDepth = requestedDepth;
            }

            int requestedComponents = ri.RequestedComponents.GetValueOrDefault();
            if (ri.RequestedComponents.HasValue && ri.OutComponents != requestedComponents)
            {
                if (ri.OutDepth == 8)
                    data = stbi__convert_format8(data, ri.OutComponents, requestedComponents, ri.Width, ri.Height);
                else
                    data = stbi__convert_format16(data, ri.OutComponents, requestedComponents, ri.Width, ri.Height);

                ri.OutComponents = requestedComponents;
            }

            return data;
        }

        public static int stbi__build_huffman(ref stbi__huffman h, int* count)
        {
            int i;
            int j;
            int k = 0;
            int code = 0;
            for (i = 0; (i) < (16); ++i)
            {
                for (j = 0; (j) < (count[i]); ++j)
                    h.size[k++] = ((byte)(i + 1));
            }

            h.size[k] = 0;
            k = 0;
            for (j = 1; j <= 16; ++j)
            {
                h.delta[j] = (int)(k - code);
                if ((h.size[k]) == (j))
                {
                    while ((h.size[k]) == (j))
                    {
                        h.code[k++] = ((ushort)(code++));
                    }

                    if ((code - 1) >= (1 << j))
                        return (int)(stbi__err("bad code lengths"));
                }

                h.maxcode[j] = (uint)(code << (16 - j));
                code <<= 1;
            }

            h.maxcode[j] = (uint)(0xffffffff);
            for (i = 0; i < stbi__huffman.len_fast; ++i)
            {
                h.fast[i] = 255;
            }
            for (i = 0; (i) < (k); ++i)
            {
                int s = (int)(h.size[i]);
                if (s <= 9)
                {
                    int c = (int)(h.code[i] << (9 - s));
                    int m = (int)(1 << (9 - s));
                    for (j = 0; (j) < (m); ++j)
                    {
                        h.fast[c + j] = ((byte)(i));
                    }
                }
            }

            return 1;
        }

        public static void stbi__build_fast_ac(short[] fast_ac, ref stbi__huffman h)
        {
            int i;
            for (i = 0; (i) < (1 << 9); ++i)
            {
                byte fast = (byte)(h.fast[i]);
                fast_ac[i] = (short)(0);
                if ((fast) < (255))
                {
                    int rs = (int)(h.values[fast]);
                    int run = (int)((rs >> 4) & 15);
                    int magbits = (int)(rs & 15);
                    int len = (int)(h.size[fast]);
                    if (((magbits) != 0) && (len + magbits <= 9))
                    {
                        int k = (int)(((i << len) & ((1 << 9) - 1)) >> (9 - magbits));
                        int m = (int)(1 << (magbits - 1));
                        if ((k) < (m))
                            k += (int)((~0U << magbits) + 1);
                        if (((k) >= (-128)) && (k <= 127))
                            fast_ac[i] = ((short)((k << 8) + (run << 4) + (len + magbits)));
                    }
                }
            }
        }

        public static void stbi__grow_buffer_unsafe(JpegContext j)
        {
            do
            {
                int b = (int)((j.nomore) != 0 ? 0 : stbi__get8(j.s));
                if ((b) == (0xff))
                {
                    int c = (int)(stbi__get8(j.s));
                    while ((c) == (0xff))
                        c = (int)(stbi__get8(j.s));

                    if (c != 0)
                    {
                        j.marker = ((byte)(c));
                        j.nomore = 1;
                        return;
                    }
                }

                j.code_buffer |= (uint)(b << (24 - j.code_bits));
                j.code_bits += (int)(8);
            } while (j.code_bits <= 24);
        }

        public static int stbi__jpeg_huff_decode(JpegContext j, ref stbi__huffman h)
        {
            uint temp;
            int c;
            int k;
            if ((j.code_bits) < (16))
                stbi__grow_buffer_unsafe(j);
            c = (int)((j.code_buffer >> (32 - 9)) & ((1 << 9) - 1));
            k = (int)(h.fast[c]);
            if ((k) < (255))
            {
                int s = (int)(h.size[k]);
                if ((s) > (j.code_bits))
                    return -1;
                j.code_buffer <<= s;
                j.code_bits -= (int)(s);
                return (int)(h.values[k]);
            }

            temp = (uint)(j.code_buffer >> 16);
            for (k = (int)(9 + 1); ; ++k)
            {
                if ((temp) < (h.maxcode[k]))
                    break;
            }

            if ((k) == (17))
            {
                j.code_bits -= (int)(16);
                return -1;
            }

            if ((k) > (j.code_bits))
                return -1;
            c = (int)(((j.code_buffer >> (32 - k)) & stbi__bmask[k]) + h.delta[k]);
            j.code_bits -= (int)(k);
            j.code_buffer <<= k;
            return (int)(h.values[c]);
        }

        public static int stbi__extend_receive(JpegContext j, int n)
        {
            uint k;
            int sgn;
            if ((j.code_bits) < (n))
                stbi__grow_buffer_unsafe(j);
            sgn = (int)((int)j.code_buffer >> 31);
            k = (uint)(CRuntime.RotateBits(j.code_buffer, (int)(n)));
            j.code_buffer = (uint)(k & ~stbi__bmask[n]);
            k &= (uint)(stbi__bmask[n]);
            j.code_bits -= (int)(n);
            return (int)(k + (stbi__jbias[n] & ~sgn));
        }

        public static int stbi__jpeg_get_bits(JpegContext j, int n)
        {
            uint k;
            if ((j.code_bits) < (n))
                stbi__grow_buffer_unsafe(j);
            k = (uint)(CRuntime.RotateBits(j.code_buffer, (int)(n)));
            j.code_buffer = (uint)(k & ~stbi__bmask[n]);
            k &= (uint)(stbi__bmask[n]);
            j.code_bits -= (int)(n);
            return (int)(k);
        }

        public static int stbi__jpeg_get_bit(JpegContext j)
        {
            uint k;
            if ((j.code_bits) < (1))
                stbi__grow_buffer_unsafe(j);
            k = (uint)(j.code_buffer);
            j.code_buffer <<= 1;
            --j.code_bits;
            return (int)(k & 0x80000000);
        }

        public static int stbi__jpeg_decode_block(
            JpegContext j, short* data, ref stbi__huffman hdc, ref stbi__huffman hac,
            short[] fac, int b, ushort[] dequant)
        {
            int diff;
            int dc;
            int k;
            int t;
            if ((j.code_bits) < (16))
                stbi__grow_buffer_unsafe(j);
            t = (int)(stbi__jpeg_huff_decode(j, ref hdc));
            if ((t) < (0))
                return (int)(stbi__err("bad huffman code"));
            CRuntime.MemSet(data, 0, 64 * sizeof(short));
            diff = (int)((t) != 0 ? stbi__extend_receive(j, (int)(t)) : 0);
            dc = (int)(j.img_comp[b].dc_pred + diff);
            j.img_comp[b].dc_pred = (int)(dc);
            data[0] = ((short)(dc * dequant[0]));
            k = 1;
            do
            {
                uint zig;
                int c;
                int r;
                int s;
                if ((j.code_bits) < (16))
                    stbi__grow_buffer_unsafe(j);
                c = (int)((j.code_buffer >> (32 - 9)) & ((1 << 9) - 1));
                r = (int)(fac[c]);
                if ((r) != 0)
                {
                    k += (int)((r >> 4) & 15);
                    s = (int)(r & 15);
                    j.code_buffer <<= s;
                    j.code_bits -= (int)(s);
                    zig = (uint)(stbi__jpeg_dezigzag[k++]);
                    data[zig] = ((short)((r >> 8) * dequant[zig]));
                }
                else
                {
                    int rs = (int)(stbi__jpeg_huff_decode(j, ref hac));
                    if ((rs) < (0))
                        return (int)(stbi__err("bad huffman code"));
                    s = (int)(rs & 15);
                    r = (int)(rs >> 4);
                    if ((s) == 0)
                    {
                        if (rs != 0xf0)
                            break;
                        k += (int)(16);
                    }
                    else
                    {
                        k += (int)(r);
                        zig = (uint)(stbi__jpeg_dezigzag[k++]);
                        data[zig] = ((short)(stbi__extend_receive(j, (int)(s)) * dequant[zig]));
                    }
                }
            } while ((k) < (64));

            return 1;
        }

        public static int stbi__jpeg_decode_block_prog_dc(
            JpegContext j, short* data, ref stbi__huffman hdc, int b)
        {
            int diff;
            int dc;
            int t;
            if (j.spec_end != 0)
                return (int)(stbi__err("can't merge dc and ac"));
            if ((j.code_bits) < (16))
                stbi__grow_buffer_unsafe(j);
            if ((j.succ_high) == 0)
            {
                CRuntime.MemSet(data, 0, 64 * sizeof(short));
                t = (int)(stbi__jpeg_huff_decode(j, ref hdc));
                diff = (int)((t) != 0 ? stbi__extend_receive(j, (int)(t)) : 0);
                dc = (int)(j.img_comp[b].dc_pred + diff);
                j.img_comp[b].dc_pred = (int)(dc);
                data[0] = ((short)(dc << j.succ_low));
            }
            else
            {
                if ((stbi__jpeg_get_bit(j)) != 0)
                    data[0] += ((short)(1 << j.succ_low));
            }

            return 1;
        }

        public static int stbi__jpeg_decode_block_prog_ac(
            JpegContext j, short* data, ref stbi__huffman hac, short[] fac)
        {
            int k;
            if ((j.spec_start) == 0)
                return (int)(stbi__err("can't merge dc and ac"));
            if ((j.succ_high) == 0)
            {
                int shift = (int)(j.succ_low);
                if ((j.eob_run) != 0)
                {
                    --j.eob_run;
                    return 1;
                }

                k = (int)(j.spec_start);
                do
                {
                    uint zig;
                    int c;
                    int r;
                    int s;
                    if ((j.code_bits) < (16))
                        stbi__grow_buffer_unsafe(j);
                    c = (int)((j.code_buffer >> (32 - 9)) & ((1 << 9) - 1));
                    r = (int)(fac[c]);
                    if ((r) != 0)
                    {
                        k += (int)((r >> 4) & 15);
                        s = (int)(r & 15);
                        j.code_buffer <<= s;
                        j.code_bits -= (int)(s);
                        zig = (uint)(stbi__jpeg_dezigzag[k++]);
                        data[zig] = ((short)((r >> 8) << shift));
                    }
                    else
                    {
                        int rs = (int)(stbi__jpeg_huff_decode(j, ref hac));
                        if ((rs) < (0))
                            return (int)(stbi__err("bad huffman code"));
                        s = (int)(rs & 15);
                        r = (int)(rs >> 4);
                        if ((s) == 0)
                        {
                            if ((r) < (15))
                            {
                                j.eob_run = (int)(1 << r);
                                if ((r) != 0)
                                    j.eob_run += (int)(stbi__jpeg_get_bits(j, (int)(r)));
                                --j.eob_run;
                                break;
                            }

                            k += (int)(16);
                        }
                        else
                        {
                            k += (int)(r);
                            zig = (uint)(stbi__jpeg_dezigzag[k++]);
                            data[zig] = ((short)(stbi__extend_receive(j, (int)(s)) << shift));
                        }
                    }
                } while (k <= j.spec_end);
            }
            else
            {
                short bit = (short)(1 << j.succ_low);
                if ((j.eob_run) != 0)
                {
                    --j.eob_run;
                    for (k = (int)(j.spec_start); k <= j.spec_end; ++k)
                    {
                        short* p = &data[stbi__jpeg_dezigzag[k]];
                        if (*p != 0)
                            if ((stbi__jpeg_get_bit(j)) != 0)
                                if ((*p & bit) == 0)
                                {
                                    if ((*p) > (0))
                                        *p += (short)(bit);
                                    else
                                        *p -= (short)(bit);
                                }
                    }
                }
                else
                {
                    k = (int)(j.spec_start);
                    do
                    {
                        int r;
                        int s;
                        int rs = (int)(stbi__jpeg_huff_decode(j, ref hac));
                        if ((rs) < (0))
                            return (int)(stbi__err("bad huffman code"));
                        s = (int)(rs & 15);
                        r = (int)(rs >> 4);
                        if ((s) == 0)
                        {
                            if ((r) < (15))
                            {
                                j.eob_run = (int)((1 << r) - 1);
                                if ((r) != 0)
                                    j.eob_run += (int)(stbi__jpeg_get_bits(j, (int)(r)));
                                r = (int)(64);
                            }
                            else
                            {
                            }
                        }
                        else
                        {
                            if (s != 1)
                                return (int)(stbi__err("bad huffman code"));
                            if ((stbi__jpeg_get_bit(j)) != 0)
                                s = (int)(bit);
                            else
                                s = (int)(-bit);
                        }

                        while (k <= j.spec_end)
                        {
                            short* p = &data[stbi__jpeg_dezigzag[k++]];
                            if (*p != 0)
                            {
                                if ((stbi__jpeg_get_bit(j)) != 0)
                                    if ((*p & bit) == 0)
                                    {
                                        if ((*p) > (0))
                                            *p += (short)(bit);
                                        else
                                            *p -= (short)(bit);
                                    }
                            }
                            else
                            {
                                if ((r) == 0)
                                {
                                    *p = ((short)(s));
                                    break;
                                }

                                --r;
                            }
                        }
                    } while (k <= j.spec_end);
                }
            }

            return 1;
        }

        public static byte stbi__clamp(int x)
        {
            if (((uint)(x)) > (255))
            {
                if ((x) < (0))
                    return 0;
                if ((x) > (255))
                    return 255;
            }

            return (byte)(x);
        }

        public static void stbi__idct_block(byte* _out_, int out_stride, short* data)
        {
            int i;
            int* val = stackalloc int[64];
            int* v = val;
            byte* o;
            short* d = ((short*)data);
            for (i = 0; (i) < (8); ++i, ++d, ++v)
            {
                if ((((((((d[8]) == 0) && ((d[16]) == 0)) && ((d[24]) == 0)) && ((d[32]) == 0)) &&
                      ((d[40]) == 0)) &&
                     ((d[48]) == 0)) && ((d[56]) == 0))
                {
                    int dcterm = (int)(d[0] << 2);
                    v[0] =
                        (int)
                        (v[8] =
                            (int)(v[16] = (int)(v[24] =
                                (int)(v[32] = (int)(v[40] = (int)(v[48] = (int)(v[56] = (int)(dcterm))))))));
                }
                else
                {
                    int t0;
                    int t1;
                    int t2;
                    int t3;
                    int p1;
                    int p2;
                    int p3;
                    int p4;
                    int p5;
                    int x0;
                    int x1;
                    int x2;
                    int x3;

                    p2 = (int)(d[16]);
                    p3 = (int)(d[48]);
                    p1 = (int)((p2 + p3) * ((int)((0.5411961f) * 4096 + 0.5)));
                    t2 = (int)(p1 + p3 * ((int)((-1.847759065f) * 4096 + 0.5)));
                    t3 = (int)(p1 + p2 * ((int)((0.765366865f) * 4096 + 0.5)));
                    p2 = (int)(d[0]);
                    p3 = (int)(d[32]);
                    t0 = (int)((p2 + p3) << 12);
                    t1 = (int)((p2 - p3) << 12);
                    x0 = (int)(t0 + t3);
                    x3 = (int)(t0 - t3);
                    x1 = (int)(t1 + t2);
                    x2 = (int)(t1 - t2);
                    t0 = (int)(d[56]);
                    t1 = (int)(d[40]);
                    t2 = (int)(d[24]);
                    t3 = (int)(d[8]);
                    p3 = (int)(t0 + t2);
                    p4 = (int)(t1 + t3);
                    p1 = (int)(t0 + t3);
                    p2 = (int)(t1 + t2);
                    p5 = (int)((p3 + p4) * ((int)((1.175875602f) * 4096 + 0.5)));
                    t0 = (int)(t0 * ((int)((0.298631336f) * 4096 + 0.5)));
                    t1 = (int)(t1 * ((int)((2.053119869f) * 4096 + 0.5)));
                    t2 = (int)(t2 * ((int)((3.072711026f) * 4096 + 0.5)));
                    t3 = (int)(t3 * ((int)((1.501321110f) * 4096 + 0.5)));
                    p1 = (int)(p5 + p1 * ((int)((-0.899976223f) * 4096 + 0.5)));
                    p2 = (int)(p5 + p2 * ((int)((-2.562915447f) * 4096 + 0.5)));
                    p3 = (int)(p3 * ((int)((-1.961570560f) * 4096 + 0.5)));
                    p4 = (int)(p4 * ((int)((-0.390180644f) * 4096 + 0.5)));
                    t3 += (int)(p1 + p4);
                    t2 += (int)(p2 + p3);
                    t1 += (int)(p2 + p4);
                    t0 += (int)(p1 + p3);
                    x0 += (int)(512);
                    x1 += (int)(512);
                    x2 += (int)(512);
                    x3 += (int)(512);

                    v[0] = (int)((x0 + t3) >> 10);
                    v[8] = (int)((x1 + t2) >> 10);
                    v[16] = (int)((x2 + t1) >> 10);
                    v[24] = (int)((x3 + t0) >> 10);
                    v[32] = (int)((x3 - t0) >> 10);
                    v[40] = (int)((x2 - t1) >> 10);
                    v[48] = (int)((x1 - t2) >> 10);
                    v[56] = (int)((x0 - t3) >> 10);
                }
            }

            for (i = 0, v = val, o = _out_; (i) < (8); ++i, v += 8, o += out_stride)
            {
                int t0;
                int t1;
                int t2;
                int t3;
                int p1;
                int p2;
                int p3;
                int p4;
                int p5;
                int x0;
                int x1;
                int x2;
                int x3;

                p2 = (int)(v[2]);
                p3 = (int)(v[6]);
                p1 = (int)((p2 + p3) * ((int)((0.5411961f) * 4096 + 0.5)));
                t2 = (int)(p1 + p3 * ((int)((-1.847759065f) * 4096 + 0.5)));
                t3 = (int)(p1 + p2 * ((int)((0.765366865f) * 4096 + 0.5)));
                p2 = (int)(v[0]);
                p3 = (int)(v[4]);
                t0 = (int)((p2 + p3) << 12);
                t1 = (int)((p2 - p3) << 12);
                x0 = (int)(t0 + t3);
                x3 = (int)(t0 - t3);
                x1 = (int)(t1 + t2);
                x2 = (int)(t1 - t2);
                t0 = (int)(v[7]);
                t1 = (int)(v[5]);
                t2 = (int)(v[3]);
                t3 = (int)(v[1]);
                p3 = (int)(t0 + t2);
                p4 = (int)(t1 + t3);
                p1 = (int)(t0 + t3);
                p2 = (int)(t1 + t2);
                p5 = (int)((p3 + p4) * ((int)((1.175875602f) * 4096 + 0.5)));
                t0 = (int)(t0 * ((int)((0.298631336f) * 4096 + 0.5)));
                t1 = (int)(t1 * ((int)((2.053119869f) * 4096 + 0.5)));
                t2 = (int)(t2 * ((int)((3.072711026f) * 4096 + 0.5)));
                t3 = (int)(t3 * ((int)((1.501321110f) * 4096 + 0.5)));
                p1 = (int)(p5 + p1 * ((int)((-0.899976223f) * 4096 + 0.5)));
                p2 = (int)(p5 + p2 * ((int)((-2.562915447f) * 4096 + 0.5)));
                p3 = (int)(p3 * ((int)((-1.961570560f) * 4096 + 0.5)));
                p4 = (int)(p4 * ((int)((-0.390180644f) * 4096 + 0.5)));
                t3 += (int)(p1 + p4);
                t2 += (int)(p2 + p3);
                t1 += (int)(p2 + p4);
                t0 += (int)(p1 + p3);
                x0 += (int)(65536 + (128 << 17));
                x1 += (int)(65536 + (128 << 17));
                x2 += (int)(65536 + (128 << 17));
                x3 += (int)(65536 + (128 << 17));

                o[0] = (byte)(stbi__clamp((int)((x0 + t3) >> 17)));
                o[1] = (byte)(stbi__clamp((int)((x1 + t2) >> 17)));
                o[2] = (byte)(stbi__clamp((int)((x2 + t1) >> 17)));
                o[3] = (byte)(stbi__clamp((int)((x3 + t0) >> 17)));
                o[4] = (byte)(stbi__clamp((int)((x3 - t0) >> 17)));
                o[5] = (byte)(stbi__clamp((int)((x2 - t1) >> 17)));
                o[6] = (byte)(stbi__clamp((int)((x1 - t2) >> 17)));
                o[7] = (byte)(stbi__clamp((int)((x0 - t3) >> 17)));
            }
        }

        public static byte stbi__get_marker(JpegContext j)
        {
            byte x;
            if (j.marker != 0xff)
            {
                x = (byte)(j.marker);
                j.marker = (byte)(0xff);
                return (byte)(x);
            }

            x = (byte)(stbi__get8(j.s));
            if (x != 0xff)
                return (byte)(0xff);

            while ((x) == (0xff))
                x = (byte)(stbi__get8(j.s));

            return (byte)(x);
        }

        public static void stbi__jpeg_reset(JpegContext j)
        {
            j.code_bits = 0;
            j.code_buffer = (uint)(0);
            j.nomore = 0;
            j.img_comp[0].dc_pred = j.img_comp[1].dc_pred = j.img_comp[2].dc_pred = j.img_comp[3].dc_pred = 0;
            j.marker = (byte)(0xff);
            j.todo = (int)((j.restart_interval) != 0 ? j.restart_interval : 0x7fffffff);
            j.eob_run = 0;
        }

        public static int stbi__parse_entropy_coded_data(JpegContext z)
        {
            stbi__jpeg_reset(z);
            if (z.progressive == 0)
            {
                if ((z.scan_n) == (1))
                {
                    int i;
                    int j;
                    short* data = stackalloc short[64];
                    int n = (int)(z.order[0]);
                    int w = (int)((z.img_comp[n].x + 7) >> 3);
                    int h = (int)((z.img_comp[n].y + 7) >> 3);
                    for (j = 0; (j) < (h); ++j)
                    {
                        for (i = 0; (i) < (w); ++i)
                        {
                            int ha = (int)(z.img_comp[n].ha);
                            if (stbi__jpeg_decode_block(
                                    z, data, ref z.huff_dc[z.img_comp[n].hd], ref z.huff_ac[ha],
                                    z.fast_ac[ha], (int)(n), z.dequant[z.img_comp[n].tq]) == 0)
                                return 0;

                            z.idct_block_kernel(
                                z.img_comp[n].data + z.img_comp[n].w2 * j * 8 + i * 8,
                                (int)(z.img_comp[n].w2), data);

                            if (--z.todo <= 0)
                            {
                                if ((z.code_bits) < (24))
                                    stbi__grow_buffer_unsafe(z);
                                if (!(((z.marker) >= (0xd0)) && ((z.marker) <= 0xd7)))
                                    return 1;
                                stbi__jpeg_reset(z);
                            }
                        }
                    }

                    return 1;
                }
                else
                {
                    int i;
                    int j;
                    int k;
                    int x;
                    int y;
                    short* data = stackalloc short[64];
                    for (j = 0; (j) < (z.img_mcu_y); ++j)
                    {
                        for (i = 0; (i) < (z.img_mcu_x); ++i)
                        {
                            for (k = 0; (k) < (z.scan_n); ++k)
                            {
                                int n = (int)(z.order[k]);
                                for (y = 0; (y) < (z.img_comp[n].v); ++y)
                                {
                                    for (x = 0; (x) < (z.img_comp[n].h); ++x)
                                    {
                                        int x2 = (int)((i * z.img_comp[n].h + x) * 8);
                                        int y2 = (int)((j * z.img_comp[n].v + y) * 8);
                                        int ha = (int)(z.img_comp[n].ha);
                                        if (
                                            stbi__jpeg_decode_block(z, data,
                                                ref z.huff_dc[z.img_comp[n].hd],
                                                ref z.huff_ac[ha], z.fast_ac[ha], (int)(n),
                                                z.dequant[z.img_comp[n].tq]) == 0)
                                            return 0;
                                        z.idct_block_kernel(z.img_comp[n].data + z.img_comp[n].w2 * y2 + x2,
                                            (int)(z.img_comp[n].w2), data);
                                    }
                                }
                            }

                            if (--z.todo <= 0)
                            {
                                if ((z.code_bits) < (24))
                                    stbi__grow_buffer_unsafe(z);
                                if (!(((z.marker) >= (0xd0)) && ((z.marker) <= 0xd7)))
                                    return 1;
                                stbi__jpeg_reset(z);
                            }
                        }
                    }

                    return 1;
                }
            }
            else
            {
                if ((z.scan_n) == (1))
                {
                    int i;
                    int j;
                    int n = (int)(z.order[0]);
                    int w = (int)((z.img_comp[n].x + 7) >> 3);
                    int h = (int)((z.img_comp[n].y + 7) >> 3);
                    for (j = 0; (j) < (h); ++j)
                    {
                        for (i = 0; (i) < (w); ++i)
                        {
                            short* data = z.img_comp[n].coeff + 64 * (i + j * z.img_comp[n].coeff_w);
                            if ((z.spec_start) == 0)
                            {
                                if (stbi__jpeg_decode_block_prog_dc(z, data,
                                        ref z.huff_dc[z.img_comp[n].hd], (int)(n)) == 0)
                                    return 0;
                            }
                            else
                            {
                                int ha = (int)(z.img_comp[n].ha);
                                if (stbi__jpeg_decode_block_prog_ac(
                                    z, data, ref z.huff_ac[ha], z.fast_ac[ha]) == 0)
                                    return 0;
                            }

                            if (--z.todo <= 0)
                            {
                                if ((z.code_bits) < (24))
                                    stbi__grow_buffer_unsafe(z);
                                if (!(((z.marker) >= (0xd0)) && ((z.marker) <= 0xd7)))
                                    return 1;
                                stbi__jpeg_reset(z);
                            }
                        }
                    }

                    return 1;
                }
                else
                {
                    int i;
                    int j;
                    int k;
                    int x;
                    int y;
                    for (j = 0; (j) < (z.img_mcu_y); ++j)
                    {
                        for (i = 0; (i) < (z.img_mcu_x); ++i)
                        {
                            for (k = 0; (k) < (z.scan_n); ++k)
                            {
                                int n = (int)(z.order[k]);
                                for (y = 0; (y) < (z.img_comp[n].v); ++y)
                                {
                                    for (x = 0; (x) < (z.img_comp[n].h); ++x)
                                    {
                                        int x2 = (int)(i * z.img_comp[n].h + x);
                                        int y2 = (int)(j * z.img_comp[n].v + y);
                                        short* data = z.img_comp[n].coeff + 64 * (x2 + y2 * z.img_comp[n].coeff_w);
                                        if (stbi__jpeg_decode_block_prog_dc(
                                            z, data, ref z.huff_dc[z.img_comp[n].hd], (int)(n)) == 0)
                                            return 0;
                                    }
                                }
                            }

                            if (--z.todo <= 0)
                            {
                                if ((z.code_bits) < (24))
                                    stbi__grow_buffer_unsafe(z);
                                if (!(((z.marker) >= (0xd0)) && ((z.marker) <= 0xd7)))
                                    return 1;
                                stbi__jpeg_reset(z);
                            }
                        }
                    }

                    return 1;
                }
            }

        }

        public static void stbi__jpeg_dequantize(short* data, ushort[] dequant)
        {
            int i;
            for (i = 0; (i) < (64); ++i)
            {
                data[i] *= (short)(dequant[i]);
            }
        }

        public static void stbi__jpeg_finish(JpegContext z)
        {
            if ((z.progressive) == 0)
                return;

            int i;
            int j;
            int n;
            for (n = 0; (n) < (z.ri.Components); ++n)
            {
                int w = (int)((z.img_comp[n].x + 7) >> 3);
                int h = (int)((z.img_comp[n].y + 7) >> 3);
                for (j = 0; (j) < (h); ++j)
                {
                    for (i = 0; (i) < (w); ++i)
                    {
                        short* data = z.img_comp[n].coeff + 64 * (i + j * z.img_comp[n].coeff_w);
                        stbi__jpeg_dequantize(data, z.dequant[z.img_comp[n].tq]);
                        z.idct_block_kernel(z.img_comp[n].data + z.img_comp[n].w2 * j * 8 + i * 8,
                            (int)(z.img_comp[n].w2), data);
                    }
                }
            }
        }

        public static int stbi__process_marker(JpegContext z, int m)
        {
            int L;
            switch (m)
            {
                case 0xff:
                    return (int)(stbi__err("expected marker"));

                case 0xDD:
                    if (stbi__get16be(z.s) != 4)
                        return (int)(stbi__err("bad DRI len"));
                    z.restart_interval = (int)(stbi__get16be(z.s));
                    return 1;

                case 0xDB:
                    L = (int)(stbi__get16be(z.s) - 2);
                    while ((L) > (0))
                    {
                        int q = (int)(stbi__get8(z.s));
                        int p = (int)(q >> 4);
                        int sixteen = (p != 0) ? 1 : 0;
                        int t = (int)(q & 15);
                        int i;
                        if ((p != 0) && (p != 1))
                            return (int)(stbi__err("bad DQT type"));
                        if ((t) > (3))
                            return (int)(stbi__err("bad DQT table"));
                        for (i = 0; (i) < (64); ++i)
                        {
                            z.dequant[t][stbi__jpeg_dezigzag[i]] =
                                ((ushort)((sixteen) != 0 ? stbi__get16be(z.s) : stbi__get8(z.s)));
                        }
                        L -= (int)((sixteen) != 0 ? 129 : 65);
                    }
                    return (int)((L) == 0 ? 1 : 0);

                case 0xC4:
                    L = (int)(stbi__get16be(z.s) - 2);
                    while ((L) > (0))
                    {
                        int* sizes = stackalloc int[16];
                        int i;
                        int n = 0;
                        int q = (int)(stbi__get8(z.s));
                        int tc = (int)(q >> 4);
                        int th = (int)(q & 15);
                        if (((tc) > (1)) || ((th) > (3)))
                            return (int)(stbi__err("bad DHT header"));
                        for (i = 0; (i) < (16); ++i)
                        {
                            sizes[i] = (int)(stbi__get8(z.s));
                            n += (int)(sizes[i]);
                        }

                        stbi__huffman[] huff;

                        L -= (int)(17);
                        if ((tc) == 0)
                        {
                            if (stbi__build_huffman(ref z.huff_dc[th], sizes) == 0)
                                return 0;
                            huff = z.huff_dc;
                        }
                        else
                        {
                            if (stbi__build_huffman(ref z.huff_ac[th], sizes) == 0)
                                return 0;
                            huff = z.huff_ac;
                        }

                        for (i = 0; (i) < (n); ++i)
                            huff[th].values[i] = (byte)(stbi__get8(z.s));

                        if (tc != 0)
                            stbi__build_fast_ac(z.fast_ac[th], ref z.huff_ac[th]);
                        L -= (int)(n);
                    }
                    return (int)((L) == 0 ? 1 : 0);
            }

            if ((((m) >= (0xE0)) && (m <= 0xEF)) || ((m) == (0xFE)))
            {
                L = (int)(stbi__get16be(z.s));
                if ((L) < 2)
                {
                    if ((m) == (0xFE))
                        return (int)(stbi__err("bad COM len"));
                    else
                        return (int)(stbi__err("bad APP len"));
                }

                L -= (int)2;
                if (((m) == (0xE0)) && ((L) >= (5)))
                {
                    byte* tag = stackalloc byte[5];
                    tag[0] = (byte)('J');
                    tag[1] = (byte)('F');
                    tag[2] = (byte)('I');
                    tag[3] = (byte)('F');
                    tag[4] = (byte)('\0');
                    int ok = 1;
                    int i;
                    for (i = 0; (i) < (5); ++i)
                    {
                        if (stbi__get8(z.s) != tag[i])
                            ok = 0;
                    }

                    L -= (int)(5);
                    if ((ok) != 0)
                        z.jfif = 1;
                }
                else if (((m) == (0xEE)) && ((L) >= (12)))
                {
                    byte* tag = stackalloc byte[6];
                    tag[0] = (byte)('A');
                    tag[1] = (byte)('d');
                    tag[2] = (byte)('o');
                    tag[3] = (byte)('b');
                    tag[4] = (byte)('e');
                    tag[5] = (byte)('\0');
                    int ok = 1;
                    int i;
                    for (i = 0; (i) < (6); ++i)
                    {
                        if (stbi__get8(z.s) != tag[i])
                            ok = 0;
                    }

                    L -= (int)(6);
                    if ((ok) != 0)
                    {
                        stbi__get8(z.s);
                        stbi__get16be(z.s);
                        stbi__get16be(z.s);
                        z.app14_color_transform = (int)(stbi__get8(z.s));
                        L -= (int)(6);
                    }
                }

                stbi__skip(z.s, (int)(L));
                return 1;
            }

            return (int)(stbi__err("unknown marker"));
        }

        public static int stbi__process_scan_header(JpegContext z)
        {
            int i;
            int Ls = (int)(stbi__get16be(z.s));
            z.scan_n = (int)(stbi__get8(z.s));
            if ((((z.scan_n) < (1)) || ((z.scan_n) > (4))) || ((z.scan_n) > (z.ri.Components)))
                return (int)(stbi__err("bad SOS component count"));
            if (Ls != 6 + 2 * z.scan_n)
                return (int)(stbi__err("bad SOS len"));
            for (i = 0; (i) < (z.scan_n); ++i)
            {
                int id = (int)(stbi__get8(z.s));
                int which;
                int q = (int)(stbi__get8(z.s));
                for (which = 0; (which) < (z.ri.Components); ++which)
                {
                    if ((z.img_comp[which].id) == (id))
                        break;
                }

                if ((which) == (z.ri.Components))
                    return 0;
                z.img_comp[which].hd = (int)(q >> 4);
                if ((z.img_comp[which].hd) > (3))
                    return (int)(stbi__err("bad DC huff"));
                z.img_comp[which].ha = (int)(q & 15);
                if ((z.img_comp[which].ha) > (3))
                    return (int)(stbi__err("bad AC huff"));
                z.order[i] = (int)(which);
            }

            {
                int aa;
                z.spec_start = (int)(stbi__get8(z.s));
                z.spec_end = (int)(stbi__get8(z.s));
                aa = (int)(stbi__get8(z.s));
                z.succ_high = (int)(aa >> 4);
                z.succ_low = (int)(aa & 15);
                if ((z.progressive) != 0)
                {
                    if ((((((z.spec_start) > (63)) || ((z.spec_end) > (63))) || ((z.spec_start) > (z.spec_end))) ||
                         ((z.succ_high) > (13))) || ((z.succ_low) > (13)))
                        return (int)(stbi__err("bad SOS"));
                }
                else
                {
                    if (z.spec_start != 0)
                        return (int)(stbi__err("bad SOS"));
                    if ((z.succ_high != 0) || (z.succ_low != 0))
                        return (int)(stbi__err("bad SOS"));
                    z.spec_end = (int)(63);
                }
            }

            return 1;
        }

        public static int stbi__free_jpeg_components(JpegContext z, int ncomp, int why)
        {
            for (int i = 0; (i) < (ncomp); ++i)
            {
                if ((z.img_comp[i].raw_data) != null)
                {
                    CRuntime.Free(z.img_comp[i].raw_data);
                    z.img_comp[i].raw_data = null;
                    z.img_comp[i].data = null;
                }

                if ((z.img_comp[i].raw_coeff) != null)
                {
                    CRuntime.Free(z.img_comp[i].raw_coeff);
                    z.img_comp[i].raw_coeff = null;
                    z.img_comp[i].coeff = null;
                }

                if ((z.img_comp[i].linebuf) != null)
                {
                    CRuntime.Free(z.img_comp[i].linebuf);
                    z.img_comp[i].linebuf = null;
                }
            }

            return (int)(why);
        }

        public static int stbi__process_frame_header(JpegContext z, int scan)
        {
            ReadContext s = z.s;
            int Lf;
            int p;
            int i;
            int q;
            int h_max = 1;
            int v_max = 1;
            int c;
            Lf = (int)(stbi__get16be(s));
            if ((Lf) < (11))
                return (int)(stbi__err("bad SOF len"));
            p = (int)(stbi__get8(s));
            if (p != 8)
                return (int)(stbi__err("only 8-bit"));
            z.ri.Height = (int)(stbi__get16be(s));
            if ((z.ri.Height) == 0)
                return (int)(stbi__err("no header height"));
            z.ri.Width = (int)(stbi__get16be(s));
            if ((z.ri.Width) == 0)
                return (int)(stbi__err("0 width"));
            c = (int)(stbi__get8(s));
            if (((c != 3) && (c != 1)) && (c != 4))
                return (int)(stbi__err("bad component count"));
            z.ri.Components = (int)(c);
            for (i = 0; (i) < (c); ++i)
            {
                z.img_comp[i].data = null;
                z.img_comp[i].linebuf = null;
            }

            if (Lf != 8 + 3 * z.ri.Components)
                return (int)(stbi__err("bad SOF len"));
            z.rgb = 0;

            byte* rgb = stackalloc byte[3];
            rgb[0] = (byte)('R');
            rgb[1] = (byte)('G');
            rgb[2] = (byte)('B');
            for (i = 0; (i) < (z.ri.Components); ++i)
            {
                z.img_comp[i].id = (int)(stbi__get8(s));
                if (((z.ri.Components) == (3)) && ((z.img_comp[i].id) == (rgb[i])))
                    ++z.rgb;
                q = (int)(stbi__get8(s));
                z.img_comp[i].h = (int)(q >> 4);
                if ((z.img_comp[i].h == 0) || ((z.img_comp[i].h) > (4)))
                    return (int)(stbi__err("bad H"));
                z.img_comp[i].v = (int)(q & 15);
                if ((z.img_comp[i].v == 0) || ((z.img_comp[i].v) > (4)))
                    return (int)(stbi__err("bad V"));
                z.img_comp[i].tq = (int)(stbi__get8(s));
                if ((z.img_comp[i].tq) > (3))
                    return (int)(stbi__err("bad TQ"));
            }

            if (scan != STBI__SCAN_load)
                return 1;
            if (stbi__mad3sizes_valid((z.ri.Width), (z.ri.Height), (z.ri.Components), 0) == 0)
                return (int)(stbi__err("too large"));

            for (i = 0; (i) < (z.ri.Components); ++i)
            {
                if ((z.img_comp[i].h) > (h_max))
                    h_max = (int)(z.img_comp[i].h);
                if ((z.img_comp[i].v) > (v_max))
                    v_max = (int)(z.img_comp[i].v);
            }

            z.img_h_max = (int)(h_max);
            z.img_v_max = (int)(v_max);
            z.img_mcu_w = (int)(h_max * 8);
            z.img_mcu_h = (int)(v_max * 8);
            z.img_mcu_x = (int)((z.ri.Width + z.img_mcu_w - 1) / z.img_mcu_w);
            z.img_mcu_y = (int)((z.ri.Height + z.img_mcu_h - 1) / z.img_mcu_h);
            for (i = 0; (i) < (z.ri.Components); ++i)
            {
                z.img_comp[i].x = (int)((z.ri.Width * z.img_comp[i].h + h_max - 1) / h_max);
                z.img_comp[i].y = (int)((z.ri.Height * z.img_comp[i].v + v_max - 1) / v_max);
                z.img_comp[i].w2 = (int)(z.img_mcu_x * z.img_comp[i].h * 8);
                z.img_comp[i].h2 = (int)(z.img_mcu_y * z.img_comp[i].v * 8);
                z.img_comp[i].coeff = null;
                z.img_comp[i].raw_coeff = null;
                z.img_comp[i].linebuf = null;
                z.img_comp[i].raw_data = stbi__malloc_mad2(
                    (int)(z.img_comp[i].w2), (int)(z.img_comp[i].h2), (int)(15));
                if ((z.img_comp[i].raw_data) == null)
                    return (int)(stbi__free_jpeg_components(z, (int)(i + 1), (int)(stbi__err("outofmem"))));

                z.img_comp[i].data = (byte*)((((long)z.img_comp[i].raw_data + 15) & ~15));
                if ((z.progressive) != 0)
                {
                    z.img_comp[i].coeff_w = (int)(z.img_comp[i].w2 / 8);
                    z.img_comp[i].coeff_h = (int)(z.img_comp[i].h2 / 8);
                    z.img_comp[i].raw_coeff = stbi__malloc_mad3(
                        (int)(z.img_comp[i].w2), (int)(z.img_comp[i].h2), (int)2, (int)(15));

                    if ((z.img_comp[i].raw_coeff) == null)
                        return (int)(stbi__free_jpeg_components(z, (int)(i + 1), (int)(stbi__err("outofmem"))));
                    z.img_comp[i].coeff = (short*)((((long)z.img_comp[i].raw_coeff + 15) & ~15));
                }
            }

            return 1;
        }

        public static int stbi__decode_jpeg_header(JpegContext z, int scan)
        {
            z.jfif = 0;
            z.app14_color_transform = -1;
            z.marker = (byte)(0xff);

            int m = (int)(stbi__get_marker(z));
            if (!(m == 0xd8))
                return scan == STBI__SCAN_load ? (int)(stbi__err("no SOI")) : 0;
            if ((scan) == (STBI__SCAN_type))
                return 1;

            m = (int)(stbi__get_marker(z));
            while (!((((m) == (0xc0)) || ((m) == (0xc1))) || ((m) == (0xc2))))
            {
                if (stbi__process_marker(z, (int)(m)) == 0)
                    return 0;
                m = (int)(stbi__get_marker(z));
                while ((m) == (0xff))
                {
                    if ((stbi__at_eof(z.s)) != 0)
                        return (int)(stbi__err("no SOF"));
                    m = (int)(stbi__get_marker(z));
                }
            }

            z.progressive = (int)((m) == (0xc2) ? 1 : 0);
            if (stbi__process_frame_header(z, (int)(scan)) == 0)
                return 0;
            return 1;
        }

        public static int stbi__decode_jpeg_image(JpegContext j)
        {
            int m;
            for (m = 0; (m) < (4); m++)
            {
                j.img_comp[m].raw_data = null;
                j.img_comp[m].raw_coeff = null;
            }

            j.restart_interval = 0;
            if (stbi__decode_jpeg_header(j, (int)(STBI__SCAN_load)) == 0)
                return 0;

            m = (int)(stbi__get_marker(j));
            while (!((m) == (0xd9)))
            {
                if (((m) == (0xda)))
                {
                    if (stbi__process_scan_header(j) == 0)
                        return 0;
                    if (stbi__parse_entropy_coded_data(j) == 0)
                        return 0;
                    if ((j.marker) == (0xff))
                    {
                        while (stbi__at_eof(j.s) == 0)
                        {
                            int x = (int)(stbi__get8(j.s));
                            if ((x) == (255))
                            {
                                j.marker = (byte)(stbi__get8(j.s));
                                break;
                            }
                        }
                    }
                }
                else if (((m) == (0xdc)))
                {
                    int Ld = (int)(stbi__get16be(j.s));
                    uint NL = (uint)(stbi__get16be(j.s));
                    if (Ld != 4)
                        stbi__err("bad DNL len");
                    if (NL != j.ri.Height)
                        stbi__err("bad DNL height");
                }
                else
                {
                    if (stbi__process_marker(j, (int)(m)) == 0)
                        return 0;
                }

                m = (int)(stbi__get_marker(j));
            }

            if ((j.progressive) != 0)
                stbi__jpeg_finish(j);

            j.ri.OutComponents = j.ri.RequestedComponents ?? (j.ri.Components >= 3 ? 3 : 1);
            j.is_rgb = j.ri.Components == 3 && (j.rgb == 3 || (j.app14_color_transform == 0 && j.jfif == 0));
            j.decode_n = (j.ri.Components == 3 && j.ri.OutComponents < 3 && !j.is_rgb) ? 1 : j.ri.Components;

            return 1;
        }

        public static byte* resample_row_1(byte* _out_, byte* in_near, byte* in_far, int w, int hs)
        {
            return in_near;
        }

        public static byte* stbi__resample_row_v_2(byte* _out_, byte* in_near, byte* in_far, int w, int hs)
        {
            int i;
            for (i = 0; (i) < (w); ++i)
            {
                _out_[i] = ((byte)((3 * in_near[i] + in_far[i] + 2) >> 2));
            }

            return _out_;
        }

        public static byte* stbi__resample_row_h_2(byte* _out_, byte* in_near, byte* in_far, int w, int hs)
        {
            int i;
            byte* input = in_near;
            if ((w) == (1))
            {
                _out_[0] = (byte)(_out_[1] = (byte)(input[0]));
                return _out_;
            }

            _out_[0] = (byte)(input[0]);
            _out_[1] = ((byte)((input[0] * 3 + input[1] + 2) >> 2));
            for (i = 1; (i) < (w - 1); ++i)
            {
                int n = (int)(3 * input[i] + 2);
                _out_[i * 2 + 0] = ((byte)((n + input[i - 1]) >> 2));
                _out_[i * 2 + 1] = ((byte)((n + input[i + 1]) >> 2));
            }

            _out_[i * 2 + 0] = ((byte)((input[w - 2] * 3 + input[w - 1] + 2) >> 2));
            _out_[i * 2 + 1] = (byte)(input[w - 1]);
            return _out_;
        }

        public static byte* stbi__resample_row_hv_2(byte* _out_, byte* in_near, byte* in_far, int w, int hs)
        {
            int i;
            int t0;
            int t1;
            if ((w) == (1))
            {
                _out_[0] = (byte)(_out_[1] = ((byte)((3 * in_near[0] + in_far[0] + 2) >> 2)));
                return _out_;
            }

            t1 = (int)(3 * in_near[0] + in_far[0]);
            _out_[0] = ((byte)((t1 + 2) >> 2));
            for (i = 1; (i) < (w); ++i)
            {
                t0 = (int)(t1);
                t1 = (int)(3 * in_near[i] + in_far[i]);
                _out_[i * 2 - 1] = ((byte)((3 * t0 + t1 + 8) >> 4));
                _out_[i * 2] = ((byte)((3 * t1 + t0 + 8) >> 4));
            }

            _out_[w * 2 - 1] = ((byte)((t1 + 2) >> 2));
            return _out_;
        }

        public static byte* stbi__resample_row_generic(byte* _out_, byte* in_near, byte* in_far, int w, int hs)
        {
            int i;
            int j;
            for (i = 0; (i) < (w); ++i)
            {
                for (j = 0; (j) < (hs); ++j)
                {
                    _out_[i * hs + j] = (byte)(in_near[i]);
                }
            }

            return _out_;
        }

        public static void stbi__YCbCr_to_RGB_row(byte* _out_, byte* y, byte* pcb, byte* pcr, int count, int step)
        {
            for (int i = 0; (i) < (count); ++i)
            {
                int y_fixed = (int)((y[i] << 20) + (1 << 19));
                int cr = (int)(pcr[i] - 128);
                int cb = (int)(pcb[i] - 128);

                int r = (int)(y_fixed + cr * (((int)((1.40200f) * 4096.0f + 0.5f)) << 8));
                int g = (int)(y_fixed + (cr * -(((int)((0.71414f) * 4096.0f + 0.5f)) << 8)) +
                     ((cb * -(((int)((0.34414f) * 4096.0f + 0.5f)) << 8)) & 0xffff0000));
                int b = (int)(y_fixed + cb * (((int)((1.77200f) * 4096.0f + 0.5f)) << 8));

                r >>= 20;
                g >>= 20;
                b >>= 20;

                if (((uint)(r)) > (255))
                    r = r < 0 ? 0 : 255;

                if (((uint)(g)) > (255))
                    g = g < 0 ? 0 : 255;

                if (((uint)(b)) > (255))
                    b = b < 0 ? 0 : 255;

                _out_[0] = (byte)r;
                _out_[1] = (byte)g;
                _out_[2] = (byte)b;
                _out_[3] = (byte)255;
                _out_ += step;
            }
        }

        public static void stbi__cleanup_jpeg(JpegContext j)
        {
            stbi__free_jpeg_components(j, (int)(j.ri.Components), 0);
        }

        public static byte stbi__blinn_8x8(byte x, byte y)
        {
            uint t = (uint)(x * y + 128);
            return (byte)((t + (t >> 8)) >> 8);
        }

        public static IMemoryResult load_jpeg_image(JpegContext z)
        {
            if (z.ri.RequestedComponents < 0 || z.ri.RequestedComponents > 4)
            {
                stbi__err("bad req_comp");
                return null;
            }

            if (stbi__decode_jpeg_image(z) == 0)
            {
                stbi__cleanup_jpeg(z);
                return null;
            }

            int k;
            uint i;
            byte* output;
            byte** coutput = stackalloc byte*[4];
            var res_comp = new ResampleData[4];

            for (k = 0; (k) < z.decode_n; k++)
            {
                z.img_comp[k].linebuf = (byte*)(CRuntime.MAlloc(z.ri.Width + 3));
                if (z.img_comp[k].linebuf == null)
                {
                    stbi__cleanup_jpeg(z);
                    stbi__err("outofmem");
                    return null;
                }

                ref ResampleData r = ref res_comp[k];
                r.hs = (int)(z.img_h_max / z.img_comp[k].h);
                r.vs = (int)(z.img_v_max / z.img_comp[k].v);
                r.ystep = (int)(r.vs >> 1);
                r.w_lores = (int)((z.ri.Width + r.hs - 1) / r.hs);
                r.ypos = 0;
                r.line0 = r.line1 = z.img_comp[k].data;

                if (((r.hs) == (1)) && ((r.vs) == (1)))
                    r.Resample = resample_row_1;
                else if (((r.hs) == (1)) && ((r.vs) == 2))
                    r.Resample = stbi__resample_row_v_2;
                else if (((r.hs) == 2) && ((r.vs) == (1)))
                    r.Resample = stbi__resample_row_h_2;
                else if (((r.hs) == 2) && ((r.vs) == 2))
                    r.Resample = z.resample_row_hv_2_kernel;
                else
                    r.Resample = stbi__resample_row_generic;
            }

            output = (byte*)(stbi__malloc_mad3(z.ri.OutComponents, (int)(z.ri.Width), (int)(z.ri.Height), 1));
            if (output == null)
            {
                stbi__cleanup_jpeg(z);
                stbi__err("outofmem");
                return null;
            }

            for (int j = 0; (j) < (z.ri.Height); ++j)
            {
                byte* _out_ = output + z.ri.OutComponents * z.ri.Width * j;
                for (k = 0; (k) < z.decode_n; ++k)
                {
                    ref ResampleData r = ref res_comp[k];
                    int y_bot = (int)((r.ystep) >= (r.vs >> 1) ? 1 : 0);

                    coutput[k] = r.Resample(
                        z.img_comp[k].linebuf,
                        (y_bot) != 0 ? r.line1 : r.line0,
                        (y_bot) != 0 ? r.line0 : r.line1,
                        r.w_lores,
                        r.hs);

                    if ((++r.ystep) >= (r.vs))
                    {
                        r.ystep = 0;
                        r.line0 = r.line1;
                        if ((++r.ypos) < (z.img_comp[k].y))
                            r.line1 += z.img_comp[k].w2;
                    }
                }

                if (z.ri.OutComponents >= (3))
                {
                    byte* y = coutput[0];
                    if ((z.ri.Components) == (3))
                    {
                        if (z.is_rgb)
                        {
                            for (i = (uint)(0); (i) < (z.ri.Width); ++i)
                            {
                                _out_[0] = y[i];
                                _out_[1] = coutput[1][i];
                                _out_[2] = coutput[2][i];
                                _out_[3] = 255;
                                _out_ += z.ri.OutComponents;
                            }
                        }
                        else
                        {
                            z.YCbCr_to_RGB_kernel(_out_, y, coutput[1], coutput[2], z.ri.Width, z.ri.OutComponents);
                        }
                    }
                    else if ((z.ri.Components) == (4))
                    {
                        if ((z.app14_color_transform) == 0)
                        {
                            for (i = (uint)(0); (i) < (z.ri.Width); ++i)
                            {
                                byte m = (byte)(coutput[3][i]);
                                _out_[0] = stbi__blinn_8x8(coutput[0][i], m);
                                _out_[1] = stbi__blinn_8x8(coutput[1][i], m);
                                _out_[2] = stbi__blinn_8x8(coutput[2][i], m);
                                _out_[3] = 255;
                                _out_ += z.ri.OutComponents;
                            }
                        }
                        else if ((z.app14_color_transform) == 2)
                        {
                            z.YCbCr_to_RGB_kernel(_out_, y, coutput[1], coutput[2], z.ri.Width, z.ri.OutComponents);
                            for (i = (uint)(0); (i) < (z.ri.Width); ++i)
                            {
                                byte m = (byte)(coutput[3][i]);
                                _out_[0] = stbi__blinn_8x8((byte)(255 - _out_[0]), m);
                                _out_[1] = stbi__blinn_8x8((byte)(255 - _out_[1]), m);
                                _out_[2] = stbi__blinn_8x8((byte)(255 - _out_[2]), m);
                                _out_ += z.ri.OutComponents;
                            }
                        }
                        else
                        {
                            z.YCbCr_to_RGB_kernel(_out_, y, coutput[1], coutput[2], z.ri.Width, z.ri.OutComponents);
                        }
                    }
                    else
                        for (i = (uint)(0); (i) < (z.ri.Width); ++i)
                        {
                            _out_[0] = _out_[1] = _out_[2] = y[i];
                            _out_[3] = 255;
                            _out_ += z.ri.OutComponents;
                        }
                }
                else
                {
                    i = 0;
                    if (z.is_rgb)
                    {
                        if (z.ri.OutComponents == 1)
                        {
                            for (; (i) < (z.ri.Width); ++i)
                                *_out_++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
                        }
                        else
                        {
                            for (; (i) < (z.ri.Width); ++i)
                            {
                                _out_[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
                                _out_[1] = 255;
                                _out_ += 2;
                            }
                        }
                    }
                    else if (((z.ri.Components) == (4)) && ((z.app14_color_transform) == 0))
                    {
                        for (; (i) < (z.ri.Width); ++i)
                        {
                            byte m = coutput[3][i];
                            byte r = stbi__blinn_8x8(coutput[0][i], m);
                            byte g = stbi__blinn_8x8(coutput[1][i], m);
                            byte b = stbi__blinn_8x8(coutput[2][i], m);
                            _out_[0] = stbi__compute_y(r, g, b);
                            _out_[1] = 255;
                            _out_ += z.ri.OutComponents;
                        }
                    }
                    else if (((z.ri.Components) == (4)) && ((z.app14_color_transform) == 2))
                    {
                        for (; (i) < (z.ri.Width); ++i)
                        {
                            _out_[0] = stbi__blinn_8x8((byte)(255 - coutput[0][i]), coutput[3][i]);
                            _out_[1] = 255;
                            _out_ += z.ri.OutComponents;
                        }
                    }
                    else
                    {
                        byte* y = coutput[0];
                        i = 0;
                        if (z.ri.OutComponents == (1))
                        {
                            for (; (i) < (z.ri.Width); ++i)
                                _out_[i] = (byte)(y[i]);
                        }
                        else
                        {
                            for (; (i) < (z.ri.Width); ++i)
                            {
                                *_out_++ = (byte)(y[i]);
                                *_out_++ = 255;
                            }
                        }
                    }
                }
            }

            stbi__cleanup_jpeg(z);

            return new HGlobalMemoryResult(output, z.ri.OutComponents * z.ri.Width * z.ri.Height);
        }

        public static IMemoryResult stbi__jpeg_load(ReadContext s, ref ReadState ri)
        {
            var j = new JpegContext(s, ri);
            var result = load_jpeg_image(j);
            ri = j.ri;
            return result;
        }

        public static int stbi__jpeg_test(ReadContext s)
        {
            var j = new JpegContext(s, new ReadState());
            int r = (int)(stbi__decode_jpeg_header(j, (int)(STBI__SCAN_type)));
            stbi__rewind(s);
            return r;
        }

        public static int stbi__jpeg_info_raw(JpegContext j)
        {
            if (stbi__decode_jpeg_header(j, (int)(STBI__SCAN_header)) == 0)
            {
                stbi__rewind(j.s);
                return 0;
            }
            return 1;
        }

        public static int stbi__jpeg_info(ReadContext s, out ReadState ri)
        {
            var j = new JpegContext(s, new ReadState());
            var result = stbi__jpeg_info_raw(j);
            ri = j.ri;
            return result;
        }

        public static int stbi__bitreverse16(int n)
        {
            n = (int)(((n & 0xAAAA) >> 1) | ((n & 0x5555) << 1));
            n = (int)(((n & 0xCCCC) >> 2) | ((n & 0x3333) << 2));
            n = (int)(((n & 0xF0F0) >> 4) | ((n & 0x0F0F) << 4));
            n = (int)(((n & 0xFF00) >> 8) | ((n & 0x00FF) << 8));
            return (int)(n);
        }

        public static int stbi__bit_reverse(int v, int bits)
        {
            return (int)(stbi__bitreverse16((int)(v)) >> (16 - bits));
        }

        public static PngChunkHeader stbi__get_chunk_header(ReadContext s)
        {
            return new PngChunkHeader(
                length: (uint)(stbi__get32be(s)),
                type: (uint)(stbi__get32be(s)));
        }

        public static int stbi__check_png_header(ReadContext s)
        {
            for (int i = 0; (i) < (8); ++i)
                if (stbi__get8(s) != png_sig[i])
                    return 0;
            return 1;
        }

        public static int stbi__create_png_image_raw(
            ref PngContext a, byte* raw, uint raw_len, int out_n,
            int width, int height, int comp, int depth, int color)
        {
            int bytes = (int)((depth) == (16) ? 2 : 1);
            int out_bytes = (int)(out_n * bytes);
            int x = (int)(width);

            a._out_ = (byte*)(stbi__malloc_mad3((int)(width), (int)(height), (int)(out_bytes), 0));
            if (a._out_ == null)
                return (int)(stbi__err("outofmem"));

            uint img_width_bytes = (uint)(((comp * width * depth) + 7) >> 3);
            uint img_len = (uint)((img_width_bytes + 1) * height);
            if ((raw_len) < (img_len))
                return (int)(stbi__err("not enough pixels"));

            uint stride = (uint)(width * out_n * bytes);
            int filter_bytes = (int)(comp * bytes);
            uint i;
            uint j;
            int k;

            for (j = (uint)(0); (j) < (height); ++j)
            {
                byte* cur = a._out_ + stride * j;
                byte* prior;
                int filter = (int)(*raw++);
                if ((filter) > (4))
                    return (int)(stbi__err("invalid filter"));

                if ((depth) < (8))
                {
                    cur += width * out_n - img_width_bytes;
                    filter_bytes = 1;
                    x = (int)(img_width_bytes);
                }

                prior = cur - stride;
                if ((j) == 0)
                    filter = (int)(first_row_filter[filter]);

                k = 0;
                switch (filter)
                {
                    case STBI__F_none:
                    case STBI__F_sub:
                    case STBI__F_avg_first:
                    case STBI__F_paeth_first:
                        for (; k < filter_bytes; ++k)
                            cur[k] = (byte)(raw[k]);
                        break;

                    case STBI__F_up:
                        for (; k < filter_bytes; ++k)
                            cur[k] = ((byte)((raw[k] + prior[k]) & 255));
                        break;

                    case STBI__F_avg:
                        for (; k < filter_bytes; ++k)
                            cur[k] = ((byte)((raw[k] + (prior[k] >> 1)) & 255));
                        break;

                    case STBI__F_paeth:
                        for (; k < filter_bytes; ++k)
                            cur[k] = ((byte)((raw[k] + CRuntime.Paeth32(0, (int)(prior[k]), 0)) & 255));
                        break;
                }

                if ((depth) == (8))
                {
                    if (comp != out_n)
                        cur[comp] = 255;
                    raw += comp;
                    cur += out_n;
                    prior += out_n;
                }
                else if ((depth) == (16))
                {
                    if (comp != out_n)
                    {
                        cur[filter_bytes] = 255;
                        cur[filter_bytes + 1] = 255;
                    }

                    raw += filter_bytes;
                    cur += out_bytes;
                    prior += out_bytes;
                }
                else
                {
                    raw += 1;
                    cur += 1;
                    prior += 1;
                }

                if (((depth) < (8)) || ((comp) == (out_n)))
                {
                    int nk = (int)((x - 1) * filter_bytes);
                    k = 0;
                    switch (filter)
                    {
                        case STBI__F_none:
                            CRuntime.MemCopy(cur, raw, nk);
                            break;

                        case STBI__F_sub:
                            for (; (k) < (nk); ++k)
                                cur[k] = ((byte)((raw[k] + cur[k - filter_bytes]) & 255));
                            break;

                        case STBI__F_up:
                            for (; (k) < (nk); ++k)
                                cur[k] = ((byte)((raw[k] + prior[k]) & 255));
                            break;

                        case STBI__F_avg:
                            for (; (k) < (nk); ++k)
                                cur[k] = (byte)((raw[k] + ((prior[k] + cur[k - filter_bytes]) >> 1)) & 255);
                            break;

                        case STBI__F_paeth:
                            for (; (k) < (nk); ++k)
                                cur[k] = (byte)(raw[k] + CRuntime.Paeth32(
                                    cur[k - filter_bytes], prior[k], prior[k - filter_bytes]) & 255);
                            break;

                        case STBI__F_avg_first:
                            for (; (k) < (nk); ++k)
                                cur[k] = ((byte)((raw[k] + (cur[k - filter_bytes] >> 1)) & 255));
                            break;

                        case STBI__F_paeth_first:
                            for (; (k) < (nk); ++k)
                                cur[k] = (byte)(raw[k] + CRuntime.Paeth32(cur[k - filter_bytes], 0, 0) & 255);
                            break;
                    }
                    raw += nk;
                }
                else
                {
                    i = (uint)(width - 1);
                    switch (filter)
                    {
                        case STBI__F_none:
                            for (; (i) >= (1); --i, cur[filter_bytes] = 255,
                                raw += filter_bytes, cur += out_bytes, prior += out_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                    cur[k] = (byte)(raw[k]);
                            }
                            break;

                        case STBI__F_sub:
                            for (; (i) >= (1); --i, cur[filter_bytes] = 255,
                                raw += filter_bytes, cur += out_bytes, prior += out_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                    cur[k] = ((byte)((raw[k] + cur[k - out_bytes]) & 255));
                            }
                            break;

                        case STBI__F_up:
                            for (; (i) >= (1); --i, cur[filter_bytes] = 255,
                                raw += filter_bytes, cur += out_bytes, prior += out_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                    cur[k] = ((byte)((raw[k] + prior[k]) & 255));
                            }
                            break;

                        case STBI__F_avg:
                            for (; (i) >= (1); --i, cur[filter_bytes] = 255,
                                raw += filter_bytes, cur += out_bytes, prior += out_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                    cur[k] = ((byte)((raw[k] + ((prior[k] + cur[k - out_bytes]) >> 1)) & 255));
                            }
                            break;

                        case STBI__F_paeth:
                            for (; (i) >= (1); --i, cur[filter_bytes] = 255,
                                raw += filter_bytes, cur += out_bytes, prior += out_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                    cur[k] = (byte)(raw[k] + CRuntime.Paeth32(
                                        (int)(cur[k - out_bytes]), (int)(prior[k]),
                                        (int)(prior[k - out_bytes])) & 255);
                            }
                            break;

                        case STBI__F_avg_first:
                            for (; (i) >= (1); --i, cur[filter_bytes] = 255,
                                raw += filter_bytes, cur += out_bytes, prior += out_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                    cur[k] = ((byte)((raw[k] + (cur[k - out_bytes] >> 1)) & 255));
                            }
                            break;

                        case STBI__F_paeth_first:
                            for (; (i) >= (1); --i, cur[filter_bytes] = 255,
                                raw += filter_bytes, cur += out_bytes, prior += out_bytes)
                            {
                                for (k = 0; (k) < (filter_bytes); ++k)
                                    cur[k] = ((byte)((raw[k] + CRuntime.Paeth32(
                                        (int)(cur[k - out_bytes]), 0, 0)) & 255));
                            }
                            break;
                    }

                    if ((depth) == (16))
                    {
                        cur = a._out_ + stride * j;
                        for (i = (uint)(0); (i) < (width); ++i, cur += out_bytes)
                            cur[filter_bytes + 1] = 255;
                    }
                }
            }

            if ((depth) < (8))
            {
                for (j = (uint)(0); (j) < (height); ++j)
                {
                    byte* cur = a._out_ + stride * j;
                    byte* _in_ = a._out_ + stride * j + width * out_n - img_width_bytes;
                    byte scale = (byte)(((color) == 0) ? stbi__depth_scale_table[depth] : 1);
                    if ((depth) == (4))
                    {
                        for (k = (int)(width * comp); (k) >= 2; k -= (int)2, ++_in_)
                        {
                            *cur++ = (byte)(scale * (*_in_ >> 4));
                            *cur++ = (byte)(scale * ((*_in_) & 0x0f));
                        }
                        if ((k) > (0))
                            *cur++ = (byte)(scale * (*_in_ >> 4));
                    }
                    else if ((depth) == 2)
                    {
                        for (k = (int)(width * comp); (k) >= (4); k -= (int)(4), ++_in_)
                        {
                            *cur++ = (byte)(scale * (*_in_ >> 6));
                            *cur++ = (byte)(scale * ((*_in_ >> 4) & 0x03));
                            *cur++ = (byte)(scale * ((*_in_ >> 2) & 0x03));
                            *cur++ = (byte)(scale * ((*_in_) & 0x03));
                        }

                        if ((k) > (0))
                            *cur++ = (byte)(scale * (*_in_ >> 6));
                        if ((k) > (1))
                            *cur++ = (byte)(scale * ((*_in_ >> 4) & 0x03));
                        if ((k) > 2)
                            *cur++ = (byte)(scale * ((*_in_ >> 2) & 0x03));
                    }
                    else if ((depth) == (1))
                    {
                        for (k = (int)(width * comp); (k) >= (8); k -= (int)(8), ++_in_)
                        {
                            *cur++ = (byte)(scale * (*_in_ >> 7));
                            *cur++ = (byte)(scale * ((*_in_ >> 6) & 0x01));
                            *cur++ = (byte)(scale * ((*_in_ >> 5) & 0x01));
                            *cur++ = (byte)(scale * ((*_in_ >> 4) & 0x01));
                            *cur++ = (byte)(scale * ((*_in_ >> 3) & 0x01));
                            *cur++ = (byte)(scale * ((*_in_ >> 2) & 0x01));
                            *cur++ = (byte)(scale * ((*_in_ >> 1) & 0x01));
                            *cur++ = (byte)(scale * ((*_in_) & 0x01));
                        }
                        if ((k) > (0))
                            *cur++ = (byte)(scale * (*_in_ >> 7));
                        if ((k) > (1))
                            *cur++ = (byte)(scale * ((*_in_ >> 6) & 0x01));
                        if ((k) > 2)
                            *cur++ = (byte)(scale * ((*_in_ >> 5) & 0x01));
                        if ((k) > (3))
                            *cur++ = (byte)(scale * ((*_in_ >> 4) & 0x01));
                        if ((k) > (4))
                            *cur++ = (byte)(scale * ((*_in_ >> 3) & 0x01));
                        if ((k) > (5))
                            *cur++ = (byte)(scale * ((*_in_ >> 2) & 0x01));
                        if ((k) > (6))
                            *cur++ = (byte)(scale * ((*_in_ >> 1) & 0x01));
                    }

                    if (comp != out_n)
                    {
                        int q;
                        cur = a._out_ + stride * j;
                        if ((comp) == (1))
                        {
                            for (q = (int)(width - 1); (q) >= (0); --q)
                            {
                                cur[q * 2 + 1] = 255;
                                cur[q * 2 + 0] = (byte)(cur[q]);
                            }
                        }
                        else
                        {
                            for (q = (int)(width - 1); (q) >= (0); --q)
                            {
                                cur[q * 4 + 3] = 255;
                                cur[q * 4 + 2] = (byte)(cur[q * 3 + 2]);
                                cur[q * 4 + 1] = (byte)(cur[q * 3 + 1]);
                                cur[q * 4 + 0] = (byte)(cur[q * 3 + 0]);
                            }
                        }
                    }
                }
            }
            else if ((depth) == (16))
            {
                byte* cur = a._out_;
                ushort* cur16 = (ushort*)(cur);
                for (i = (uint)(0); (i) < (width * height * out_n); ++i, cur16++, cur += 2)
                    *cur16 = (ushort)((cur[0] << 8) | cur[1]);
            }

            return 1;
        }

        public static int stbi__create_png_image(
            ref PngContext a, byte* image_data, uint image_data_len, int out_n,
            int width, int height, int comp, int depth, int color, int interlaced)
        {
            int bytes = (int)((depth) == (16) ? 2 : 1);
            int out_bytes = (int)(out_n * bytes);

            if (interlaced == 0)
                return (int)(stbi__create_png_image_raw(
                    ref a, image_data, (uint)(image_data_len), (int)(out_n),
                    (width), (height), comp, (int)(depth), (int)(color)));

            byte* final = (byte*)(stbi__malloc_mad3((int)(width), (int)(height), (int)(out_bytes), 0));

            int* xorig = stackalloc int[7];
            xorig[0] = 0;
            xorig[1] = (int)(4);
            xorig[2] = 0;
            xorig[3] = (int)2;
            xorig[4] = 0;
            xorig[5] = 1;
            xorig[6] = 0;

            int* yorig = stackalloc int[7];
            yorig[0] = 0;
            yorig[1] = 0;
            yorig[2] = (int)(4);
            yorig[3] = 0;
            yorig[4] = (int)2;
            yorig[5] = 0;
            yorig[6] = 1;

            int* xspc = stackalloc int[7];
            xspc[0] = (int)(8);
            xspc[1] = (int)(8);
            xspc[2] = (int)(4);
            xspc[3] = (int)(4);
            xspc[4] = (int)2;
            xspc[5] = (int)2;
            xspc[6] = 1;

            int* yspc = stackalloc int[7];
            yspc[0] = (int)(8);
            yspc[1] = (int)(8);
            yspc[2] = (int)(8);
            yspc[3] = (int)(4);
            yspc[4] = (int)(4);
            yspc[5] = (int)2;
            yspc[6] = (int)2;

            for (int p = 0; (p) < (7); ++p)
            {
                int i;
                int j;
                int x = (int)((width - xorig[p] + xspc[p] - 1) / xspc[p]);
                int y = (int)((height - yorig[p] + yspc[p] - 1) / yspc[p]);
                if (((x) != 0) && ((y) != 0))
                {
                    uint img_len = (uint)(((((comp * x * depth) + 7) >> 3) + 1) * y);
                    if (stbi__create_png_image_raw(
                        ref a, image_data, (uint)(image_data_len), (int)(out_n),
                        x, y, comp, (int)(depth), (int)(color)) == 0)
                    {
                        CRuntime.Free(final);
                        return 0;
                    }

                    for (j = 0; (j) < (y); ++j)
                    {
                        for (i = 0; (i) < (x); ++i)
                        {
                            int out_y = (int)(j * yspc[p] + yorig[p]);
                            int out_x = (int)(i * xspc[p] + xorig[p]);
                            CRuntime.MemCopy(
                                final + out_y * width * out_bytes + out_x * out_bytes,
                                a._out_ + (j * x + i) * out_bytes,
                                out_bytes);
                        }
                    }

                    CRuntime.Free(a._out_);
                    image_data += img_len;
                    image_data_len -= (uint)(img_len);
                }
            }

            a._out_ = final;
            return 1;
        }

        public static int stbi__compute_transparency(
            ref PngContext z, int width, int height, byte* tc, int out_n)
        {
            uint i;
            uint pixel_count = (uint)(width * height);
            byte* p = z._out_;
            if ((out_n) == 2)
            {
                for (i = (uint)(0); (i) < (pixel_count); ++i)
                {
                    p[1] = (byte)((p[0]) == (tc[0]) ? 0 : 255);
                    p += 2;
                }
            }
            else
            {
                for (i = (uint)(0); (i) < (pixel_count); ++i)
                {
                    if ((((p[0]) == (tc[0])) && ((p[1]) == (tc[1]))) && ((p[2]) == (tc[2])))
                        p[3] = 0;
                    p += 4;
                }
            }

            return 1;
        }

        public static int stbi__compute_transparency16(
            ref PngContext z, int width, int height, ushort* tc, int out_n)
        {
            uint i;
            uint pixel_count = (uint)(width * height);
            ushort* p = (ushort*)(z._out_);
            if ((out_n) == 2)
            {
                for (i = (uint)(0); (i) < (pixel_count); ++i)
                {
                    p[1] = (ushort)((p[0]) == (tc[0]) ? 0 : 65535);
                    p += 2;
                }
            }
            else
            {
                for (i = (uint)(0); (i) < (pixel_count); ++i)
                {
                    if ((((p[0]) == (tc[0])) && ((p[1]) == (tc[1]))) && ((p[2]) == (tc[2])))
                        p[3] = (ushort)(0);
                    p += 4;
                }
            }

            return 1;
        }

        public static int stbi__expand_png_palette(
            ref PngContext a, int width, int height, byte* palette, int len, int pal_img_n)
        {
            uint i;
            uint pixel_count = (uint)(width * height);
            byte* p;
            byte* temp_out;
            byte* orig = a._out_;
            p = (byte*)(stbi__malloc_mad2((int)(pixel_count), (int)(pal_img_n), 0));
            if ((p) == null)
                return (int)(stbi__err("outofmem"));
            temp_out = p;
            if ((pal_img_n) == (3))
            {
                for (i = (uint)(0); (i) < (pixel_count); ++i)
                {
                    int n = (int)(orig[i] * 4);
                    p[0] = (byte)(palette[n]);
                    p[1] = (byte)(palette[n + 1]);
                    p[2] = (byte)(palette[n + 2]);
                    p += 3;
                }
            }
            else
            {
                for (i = (uint)(0); (i) < (pixel_count); ++i)
                {
                    int n = (int)(orig[i] * 4);
                    p[0] = (byte)(palette[n]);
                    p[1] = (byte)(palette[n + 1]);
                    p[2] = (byte)(palette[n + 2]);
                    p[3] = (byte)(palette[n + 3]);
                    p += 4;
                }
            }

            CRuntime.Free(a._out_);
            a._out_ = temp_out;
            return 1;
        }

        public static void stbi__de_iphone(ref PngContext z, ref ReadState ri)
        {
            ReadContext s = z.s;
            uint i;
            uint pixel_count = (uint)(ri.Width * ri.Height);
            byte* p = z._out_;
            if ((ri.OutComponents) == (3))
            {
                for (i = (uint)(0); (i) < (pixel_count); ++i)
                {
                    byte t = (byte)(p[0]);
                    p[0] = (byte)(p[2]);
                    p[2] = (byte)(t);
                    p += 3;
                }
            }
            else
            {
                if ((stbi__unpremultiply_on_load) != 0)
                {
                    for (i = (uint)(0); (i) < (pixel_count); ++i)
                    {
                        byte a = (byte)(p[3]);
                        byte t = (byte)(p[0]);
                        if ((a) != 0)
                        {
                            byte half = (byte)(a / 2);
                            p[0] = (byte)((p[2] * 255 + half) / a);
                            p[1] = (byte)((p[1] * 255 + half) / a);
                            p[2] = (byte)((t * 255 + half) / a);
                        }
                        else
                        {
                            p[0] = (byte)(p[2]);
                            p[2] = (byte)(t);
                        }
                        p += 4;
                    }
                }
                else
                {
                    for (i = (uint)(0); (i) < (pixel_count); ++i)
                    {
                        byte t = (byte)(p[0]);
                        p[0] = (byte)(p[2]);
                        p[2] = (byte)(t);
                        p += 4;
                    }
                }
            }

        }

        public static int stbi__parse_png_file(
            ref PngContext z, ref ReadState ri, int scan)
        {
            ReadContext s = z.s;
            z.idata = null;
            z._out_ = null;

            if (stbi__check_png_header(s) == 0)
                return scan == STBI__SCAN_type ? 0 : (int)(stbi__err("bad png sig"));
            
            if ((scan) == (STBI__SCAN_type))
                return 1;

            byte* palette = stackalloc byte[1024];
            byte pal_img_n = 0;
            byte has_transparency = 0;
            byte* tc = stackalloc byte[3];
            ushort* tc16 = stackalloc ushort[3];
            uint ioff = (uint)(0);
            uint idata_limit = (uint)(0);
            uint i;
            int pal_len = 0;
            int first = 1;
            int k;
            int interlace = 0;
            int color = 0;
            bool is_iphone = false;

            for (; ; )
            {
                PngChunkHeader c = stbi__get_chunk_header(s);
                switch (c.Type)
                {
                    case PngChunkHeader.CgBI:
                        is_iphone = true;
                        stbi__skip(s, (int)(c.Length));
                        break;

                    case PngChunkHeader.IHDR:
                    {
                        int comp;
                        int filter;
                        if (first == 0)
                            return (int)(stbi__err("multiple IHDR"));
                        first = 0;

                        if (c.Length != 13)
                            return (int)(stbi__err("bad IHDR length"));

                        ri.Width = (int)(stbi__get32be(s));
                        if ((ri.Width) > (1 << 24))
                            return (int)(stbi__err("too large"));

                        ri.Height = (int)(stbi__get32be(s));
                        if ((ri.Height) > (1 << 24))
                            return (int)(stbi__err("too large"));

                        if ((ri.Width == 0) || (ri.Height == 0))
                            return (int)(stbi__err("0-pixel image"));

                        ri.Depth = (int)(stbi__get8(s));
                        if (ri.Depth != 1 &&
                            ri.Depth != 2 &&
                            ri.Depth != 4 &&
                            ri.Depth != 8 &&
                            ri.Depth != 16)
                            return (int)(stbi__err("1/2/4/8/16-bit only"));
                        
                        if (ri.Depth < 8)
                            ri.OutDepth = 8;
                        else
                            ri.OutDepth = ri.Depth;

                        color = (int)(stbi__get8(s));
                        if ((color) > (6))
                            return (int)(stbi__err("bad ctype"));
                        if (((color) == (3)) && (ri.Depth == (16)))
                            return (int)(stbi__err("bad ctype"));

                        if ((color) == (3))
                            pal_img_n = (byte)(3);
                        else if ((color & 1) != 0)
                            return (int)(stbi__err("bad ctype"));

                        comp = (int)(stbi__get8(s));
                        if ((comp) != 0)
                            return (int)(stbi__err("bad comp method"));

                        filter = (int)(stbi__get8(s));
                        if ((filter) != 0)
                            return (int)(stbi__err("bad filter method"));

                        interlace = (int)(stbi__get8(s));
                        if ((interlace) > (1))
                            return (int)(stbi__err("bad interlace method"));

                        if (pal_img_n == 0)
                        {
                            ri.Components = (int)(((color & 2) != 0 ? 3 : 1) + ((color & 4) != 0 ? 1 : 0));
                            if (((1 << 30) / ri.Width / ri.Components) < (ri.Height))
                                return (int)(stbi__err("too large"));
                            if ((scan) == (STBI__SCAN_header))
                                return 1;
                        }
                        else
                        {
                            ri.Components = 1;
                            if (((1 << 30) / ri.Width / 4) < (ri.Height))
                                return (int)(stbi__err("too large"));
                        }
                        break;
                    }

                    case PngChunkHeader.PLTE:
                    {
                        if ((first) != 0)
                            return (int)(stbi__err("first not IHDR"));
                        if ((c.Length) > (256 * 3))
                            return (int)(stbi__err("invalid PLTE"));

                        pal_len = (int)(c.Length / 3);
                        if (pal_len * 3 != c.Length)
                            return (int)(stbi__err("invalid PLTE"));

                        for (i = (uint)(0); (i) < (pal_len); ++i)
                        {
                            palette[i * 4 + 0] = (byte)(stbi__get8(s));
                            palette[i * 4 + 1] = (byte)(stbi__get8(s));
                            palette[i * 4 + 2] = (byte)(stbi__get8(s));
                            palette[i * 4 + 3] = 255;
                        }
                        break;
                    }

                    case PngChunkHeader.tRNS:
                    {
                        if ((first) != 0)
                            return (int)(stbi__err("first not IHDR"));
                        if ((z.idata) != null)
                            return (int)(stbi__err("tRNS after IDAT"));

                        if ((pal_img_n) != 0)
                        {
                            if ((scan) == (STBI__SCAN_header))
                            {
                                ri.Components = (int)(4);
                                return 1;
                            }

                            if ((pal_len) == 0)
                                return (int)(stbi__err("tRNS before PLTE"));
                            if ((c.Length) > (pal_len))
                                return (int)(stbi__err("bad tRNS len"));
                            pal_img_n = (byte)(4);
                            for (i = (uint)(0); (i) < (c.Length); ++i)
                                palette[i * 4 + 3] = (byte)(stbi__get8(s));
                        }
                        else
                        {
                            if ((ri.Components & 1) == 0)
                                return (int)(stbi__err("tRNS with alpha"));
                            if (c.Length != (uint)(ri.Components) * 2)
                                return (int)(stbi__err("bad tRNS len"));
                            has_transparency = (byte)(1);

                            if (ri.Depth == (16))
                            {
                                for (k = 0; (k) < (ri.Components); ++k)
                                    tc16[k] = ((ushort)(stbi__get16be(s)));
                            }
                            else
                            {
                                for (k = 0; (k) < (ri.Components); ++k)
                                    tc[k] = (byte)((byte)(stbi__get16be(s) & 255) * stbi__depth_scale_table[ri.Depth]);
                            }
                        }
                        break;
                    }

                    case PngChunkHeader.IDAT:
                    {
                        if ((first) != 0)
                            return (int)(stbi__err("first not IHDR"));
                        if (((pal_img_n) != 0) && (pal_len == 0))
                            return (int)(stbi__err("no PLTE"));
                        if ((scan) == (STBI__SCAN_header))
                        {
                            ri.Components = (int)(pal_img_n);
                            return 1;
                        }

                        if (((int)(ioff + c.Length)) < ((int)(ioff)))
                            return 0;

                        if ((ioff + c.Length) > (idata_limit))
                        {
                            uint idata_limit_old = (uint)(idata_limit);
                            if ((idata_limit) == 0)
                                idata_limit = (uint)((c.Length) > (4096) ? c.Length : 4096);
                            while ((ioff + c.Length) > (idata_limit))
                                idata_limit *= (uint)2;

                            byte* p = (byte*)(CRuntime.ReAlloc(z.idata, idata_limit));
                            if ((p) == null)
                                return (int)(stbi__err("outofmem"));
                            z.idata = p;
                        }

                        if (stbi__getn(s, z.idata + ioff, (int)(c.Length)) == 0)
                            return (int)(stbi__err("outofdata"));

                        ioff += (uint)(c.Length);
                        break;
                    }

                    case PngChunkHeader.IEND:
                    {
                        if ((first) != 0)
                            return (int)(stbi__err("first not IHDR"));
                        if (scan != STBI__SCAN_load)
                            return 1;
                        if ((z.idata) == null)
                            return (int)(stbi__err("no IDAT"));

                        uint bpl = (uint)((ri.Width * ri.Depth + 7) / 8);
                        int raw_len = (int)(bpl * ri.Height * ri.Components + ri.Height);
                        bool parseHeader = !is_iphone;

                        IMemoryResult deflated;
                        try
                        {
                            var data = new ReadOnlySpan<byte>(z.idata, (int)ioff);
                            deflated = zlib_deflate_decompress(data, raw_len, parseHeader);
                            if (deflated == null)
                                return 0;
                        }
                        finally
                        {
                            CRuntime.Free(z.idata);
                            z.idata = null;
                        }

                        using (deflated)
                        {
                            if (ri.RequestedComponents == ri.Components + 1 &&
                                ri.RequestedComponents != 3 &&
                                pal_img_n == 0 ||
                                has_transparency != 0)
                                ri.OutComponents = (int)(ri.Components + 1);
                            else
                                ri.OutComponents = (int)(ri.Components);

                            if (stbi__create_png_image(
                                ref z, (byte*)deflated.Pointer, (uint)deflated.Length, ri.OutComponents,
                                ri.Width, ri.Height, ri.Components, ri.Depth, color, interlace) == 0)
                                return 0;

                            if ((has_transparency) != 0)
                            {
                                if (ri.Depth == (16))
                                    if (stbi__compute_transparency16(ref z, ri.Width, ri.Height, tc16, (int)(ri.OutComponents)) == 0)
                                        return 0;
                                    else if (stbi__compute_transparency(ref z, ri.Width, ri.Height, tc, (int)(ri.OutComponents)) == 0)
                                        return 0;
                            }

                            if (is_iphone && stbi__de_iphone_flag != 0 && ri.OutComponents > 2)
                                stbi__de_iphone(ref z, ref ri);

                            if ((pal_img_n) != 0)
                            {
                                ri.Components = (int)(pal_img_n);
                                ri.OutComponents = (int)(pal_img_n);

                                if (ri.RequestedComponents >= (3))
                                    ri.OutComponents = ri.RequestedComponents.Value;

                                if (stbi__expand_png_palette(
                                    ref z, ri.Width, ri.Height, palette, pal_len, ri.OutComponents) == 0)
                                    return 0;
                            }
                            else if ((has_transparency) != 0)
                            {
                                ri.Components++;
                            }
                            return 1;
                        }
                    }

                    default:
                        if ((first) != 0)
                            return (int)(stbi__err("first not IHDR"));

                        if ((c.Type & (1 << 29)) == 0)
                        {
                            string invalid_chunk = "XXXX PNG chunk not known";
                            return (int)(stbi__err(invalid_chunk));
                        }

                        stbi__skip(s, (int)(c.Length));
                        break;
                }

                stbi__get32be(s);
            }
        }

        /// <summary>
        /// Delegate for a zlib deflate (RFC 1951) decompression implementation.
        /// </summary>
        public delegate IMemoryResult ZlibDeflateDecompressDelegate(
            ReadOnlySpan<byte> data, int expectedSize, bool parseHeader);

        /// <summary>
        /// Custom zlib deflate (RFC 1951) decompression implementation 
        /// that replaces the default <see cref="zlib_deflate_decompress"/>.
        /// </summary>
        public static ZlibDeflateDecompressDelegate CustomZlibDeflateDecompress;

        /// <summary>
        /// Decompresses data using a <see cref="DeflateStream"/>,
        /// optionally skipping the zlib (RFC 1951) headers.
        /// <para>Can be replaced by assigning <see cref="CustomZlibDeflateDecompress"/>.</para>
        /// </summary>
        private static IMemoryResult zlib_deflate_decompress(
            ReadOnlySpan<byte> compressed, int expectedSize, bool skipHeader)
        {
            int srcOffset = skipHeader ? 2 : 0;
            var resultPtr = (byte*)CRuntime.MAlloc(expectedSize);
            int resultLength;
            fixed (byte* dataPtr = &MemoryMarshal.GetReference(compressed))
            {
                using (var src = new UnmanagedMemoryStream(dataPtr + srcOffset, compressed.Length - srcOffset))
                using (var dst = new UnmanagedMemoryStream(resultPtr, 0, expectedSize, FileAccess.Write))
                {
                    using (var ds = new DeflateStream(src, CompressionMode.Decompress, false))
                        ds.CopyTo(dst, Math.Min(expectedSize, 1024 * 80));

                    resultLength = (int)dst.Length;
                }
            }
            return new HGlobalMemoryResult(resultPtr, resultLength);
        }

        public static IMemoryResult stbi__do_png(ref PngContext p, ref ReadState ri)
        {
            if (((ri.RequestedComponents) < (0)) || ((ri.RequestedComponents) > (4)))
            {
                stbi__err("bad comp request");
                return null;
            }

            IMemoryResult result = null;
            if (stbi__parse_png_file(ref p, ref ri, STBI__SCAN_load) != 0)
            {
                result = new HGlobalMemoryResult(p._out_, ri.OutComponents * ri.Width * ri.Height * ri.OutDepth / 8);
                p._out_ = null;
                result = stbi__convert_format(result, ref ri);
            }

            CRuntime.Free(p._out_);
            p._out_ = null;
            CRuntime.Free(p.idata);
            p.idata = null;
            return result;
        }

        public static IMemoryResult stbi__png_load(ReadContext s, ref ReadState ri)
        {
            var p = new PngContext(s);
            return stbi__do_png(ref p, ref ri);
        }

        public static int stbi__png_test(ReadContext s)
        {
            int r = (int)(stbi__check_png_header(s));
            stbi__rewind(s);
            return (int)(r);
        }

        public static bool stbi__png_info_raw(ref PngContext p, out ReadState ri)
        {
            ri = new ReadState();
            if (stbi__parse_png_file(ref p, ref ri, (int)(STBI__SCAN_header)) == 0)
            {
                stbi__rewind(p.s);
                return false;
            }
            return true;
        }

        public static bool stbi__png_info(ReadContext s, out ReadState ri)
        {
            var p = new PngContext(s);
            return stbi__png_info_raw(ref p, out ri);
        }

        public static int stbi__bmp_test_raw(ReadContext s)
        {
            if (stbi__get8(s) != 'B')
                return 0;
            if (stbi__get8(s) != 'M')
                return 0;

            stbi__get32le(s);
            stbi__get16le(s);
            stbi__get16le(s);
            stbi__get32le(s);
            int sz = (int)(stbi__get32le(s));
            bool r = sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124;
            return (int)(r ? 1 : 0);
        }

        public static int stbi__bmp_test(ReadContext s)
        {
            int r = (int)(stbi__bmp_test_raw(s));
            stbi__rewind(s);
            return (int)(r);
        }

        public static int stbi__high_bit(uint z)
        {
            int n = 0;
            if ((z) == 0)
                return -1;

            if ((z) >= (0x10000))
            {
                n += (int)(16);
                z >>= 16;
            }

            if ((z) >= (0x00100))
            {
                n += (int)(8);
                z >>= 8;
            }

            if ((z) >= (0x00010))
            {
                n += (int)(4);
                z >>= 4;
            }

            if ((z) >= (0x00004))
            {
                n += (int)2;
                z >>= 2;
            }

            if ((z) >= (0x00002))
            {
                n += 1;
                z >>= 1;
            }

            return (int)(n);
        }

        public static int stbi__bitcount(uint a)
        {
            a = (uint)((a & 0x55555555) + ((a >> 1) & 0x55555555));
            a = (uint)((a & 0x33333333) + ((a >> 2) & 0x33333333));
            a = (uint)((a + (a >> 4)) & 0x0f0f0f0f);
            a = (uint)(a + (a >> 8));
            a = (uint)(a + (a >> 16));
            return (int)(a & 0xff);
        }

        public static int stbi__shiftsigned(int v, int shift, int bits)
        {
            int result;
            int z = 0;
            if ((shift) < (0))
                v <<= -shift;
            else
                v >>= shift;
            result = (int)(v);
            z = (int)(bits);
            while ((z) < (8))
            {
                result += (int)(v >> z);
                z += (int)(bits);
            }

            return (int)(result);
        }

        public static bool stbi__bmp_parse_header(ReadContext s, ref BmpInfo info, ref ReadState ri)
        {
            if (stbi__get8(s) != 'B' ||
                stbi__get8(s) != 'M')
            {
                stbi__err("not BMP");
                return false;
            }

            stbi__get32le(s);
            stbi__get16le(s);
            stbi__get16le(s);

            int hsz;
            info.offset = (int)(stbi__get32le(s));
            info.hsz = (int)(hsz = (int)(stbi__get32le(s)));
            info.mr = info.mg = info.mb = info.ma = (uint)(0);

            if (((((hsz != 12) && (hsz != 40)) && (hsz != 56)) && (hsz != 108)) && (hsz != 124))
            {
                stbi__err("unknown BMP");
                return false;
            }

            if ((hsz) == (12))
            {
                ri.Width = (stbi__get16le(s));
                ri.Height = (stbi__get16le(s));
            }
            else
            {
                ri.Width = (int)(stbi__get32le(s));
                ri.Height = (int)(stbi__get32le(s));
            }
            ri.Height = (CRuntime.FastAbs(ri.Height));

            if (stbi__get16le(s) != 1)
            {
                stbi__err("bad BMP");
                return false;
            }

            info.bpp = (int)(stbi__get16le(s));
            if ((info.bpp) == (1))
            {
                stbi__err("monochrome");
                return false;
            }

            if (hsz != 12)
            {
                int compress = (int)(stbi__get32le(s));
                if (((compress) == (1)) || ((compress) == 2))
                {
                    stbi__err("BMP RLE");
                    return false;
                }

                stbi__get32le(s);
                stbi__get32le(s);
                stbi__get32le(s);
                stbi__get32le(s);
                stbi__get32le(s);
                if (((hsz) == (40)) || ((hsz) == (56)))
                {
                    if ((hsz) == (56))
                    {
                        stbi__get32le(s);
                        stbi__get32le(s);
                        stbi__get32le(s);
                        stbi__get32le(s);
                    }

                    if (((info.bpp) == (16)) || ((info.bpp) == (32)))
                    {
                        if ((compress) == 0)
                        {
                            if ((info.bpp) == (32))
                            {
                                info.mr = (uint)(0xffu << 16);
                                info.mg = (uint)(0xffu << 8);
                                info.mb = (uint)(0xffu << 0);
                                info.ma = (uint)(0xffu << 24);
                                info.all_a = (uint)(0);
                            }
                            else
                            {
                                info.mr = (uint)(31u << 10);
                                info.mg = (uint)(31u << 5);
                                info.mb = (uint)(31u << 0);
                            }
                        }
                        else if ((compress) == (3))
                        {
                            info.mr = (uint)(stbi__get32le(s));
                            info.mg = (uint)(stbi__get32le(s));
                            info.mb = (uint)(stbi__get32le(s));
                            if (((info.mr) == (info.mg)) && ((info.mg) == (info.mb)))
                            {
                                stbi__err("bad BMP");
                                return false;
                            }
                        }
                        else
                        {
                            stbi__err("bad BMP");
                            return false;
                        }
                    }
                }
                else
                {
                    int i;
                    if ((hsz != 108) && (hsz != 124))
                    {
                        stbi__err("bad BMP");
                        return false;
                    }

                    info.mr = (uint)(stbi__get32le(s));
                    info.mg = (uint)(stbi__get32le(s));
                    info.mb = (uint)(stbi__get32le(s));
                    info.ma = (uint)(stbi__get32le(s));
                    stbi__get32le(s);
                    for (i = 0; (i) < (12); ++i)
                        stbi__get32le(s);

                    if ((hsz) == (124))
                    {
                        stbi__get32le(s);
                        stbi__get32le(s);
                        stbi__get32le(s);
                        stbi__get32le(s);
                    }
                }
            }

            ri.OutComponents = ri.Components = (int)((info.ma) != 0 ? 4 : 3);
            
            ri.OutDepth = ri.Depth = info.bpp / ri.Components;
            
            return true;
        }

        public static IMemoryResult stbi__bmp_load(ReadContext s, ref ReadState ri)
        {
            var info = new BmpInfo();
            info.all_a = (uint)(255);
            if (!stbi__bmp_parse_header(s, ref info, ref ri))
                return null;

            uint mr = (uint)(info.mr);
            uint mg = (uint)(info.mg);
            uint mb = (uint)(info.mb);
            uint ma = (uint)(info.ma);
            uint all_a = (uint)(info.all_a);

            int psize = 0;
            if ((info.hsz) == (12))
            {
                if ((info.bpp) < (24))
                    psize = (int)((info.offset - 14 - 24) / 3);
            }
            else
            {
                if ((info.bpp) < (16))
                    psize = (int)((info.offset - 14 - info.hsz) >> 2);
            }

            if (info.bpp == 24 && ma == 0xff000000)
                ri.Components = 3;
            else
                ri.Components = ma != 0 ? 4 : 3;

            if (((ri.RequestedComponents) != 0) && ((ri.RequestedComponents) >= (3)))
                ri.OutComponents = (int)(ri.RequestedComponents);
            else
                ri.OutComponents = ri.Components;

            if (stbi__mad3sizes_valid(ri.OutComponents, (int)(ri.Width), (int)(ri.Height), 0) == 0)
            {
                stbi__err("too large");
                return null;
            }

            byte* _out_ = (byte*)(stbi__malloc_mad3(ri.OutComponents, (int)(ri.Width), (int)(ri.Height), 0));
            if (_out_ == null)
            {
                stbi__err("outofmem");
                return null;
            }

            int i;
            int j;
            int width;
            int pad;
            if ((info.bpp) < (16))
            {
                int z = 0;
                if (((psize) == 0) || ((psize) > (256)))
                {
                    CRuntime.Free(_out_);
                    stbi__err("invalid");
                    return null;
                }

                byte* pal = stackalloc byte[256 * 4];
                for (i = 0; (i) < (psize); ++i)
                {
                    pal[i * 4 + 2] = (byte)(stbi__get8(s));
                    pal[i * 4 + 1] = (byte)(stbi__get8(s));
                    pal[i * 4 + 0] = (byte)(stbi__get8(s));
                    if (info.hsz != 12)
                        stbi__get8(s);
                    pal[i * 4 + 3] = 255;
                }

                stbi__skip(s, (int)(info.offset - 14 - info.hsz - psize * ((info.hsz) == (12) ? 3 : 4)));
                if ((info.bpp) == (4))
                    width = (int)((ri.Width + 1) >> 1);
                else if ((info.bpp) == (8))
                    width = (int)(ri.Width);
                else
                {
                    CRuntime.Free(_out_);
                    stbi__err("bad bpp");
                    return null;
                }

                pad = (int)((-width) & 3);
                for (j = 0; (j) < ((int)(ri.Height)); ++j)
                {
                    for (i = 0; (i) < ((int)(ri.Width)); i += (int)2)
                    {
                        int v = (int)(stbi__get8(s));
                        int v2 = 0;
                        if ((info.bpp) == (4))
                        {
                            v2 = (int)(v & 15);
                            v >>= 4;
                        }

                        _out_[z++] = (byte)(pal[v * 4 + 0]);
                        _out_[z++] = (byte)(pal[v * 4 + 1]);
                        _out_[z++] = (byte)(pal[v * 4 + 2]);
                        if (ri.OutComponents == (4))
                            _out_[z++] = 255;
                        if ((i + 1) == ((int)(ri.Width)))
                            break;
                        v = (int)(((info.bpp) == (8)) ? stbi__get8(s) : v2);
                        _out_[z++] = (byte)(pal[v * 4 + 0]);
                        _out_[z++] = (byte)(pal[v * 4 + 1]);
                        _out_[z++] = (byte)(pal[v * 4 + 2]);
                        if (ri.OutComponents == (4))
                            _out_[z++] = 255;
                    }

                    stbi__skip(s, (int)(pad));
                }
            }
            else
            {
                stbi__skip(s, (int)(info.offset - 14 - info.hsz));
                if ((info.bpp) == (24))
                    width = (int)(3 * ri.Width);
                else if ((info.bpp) == (16))
                    width = (int)(2 * ri.Width);
                else
                    width = 0;
                pad = (int)((-width) & 3);

                int easy = 0;
                if ((info.bpp) == (24))
                    easy = 1;
                else if ((info.bpp) == (32))
                    if ((((mb == 0xff) && (mg == 0xff00)) && (mr == 0x00ff0000)) && (ma == 0xff000000))
                        easy = (int)2;

                int rshift = 0, gshift = 0, bshift = 0, ashift = 0;
                int rcount = 0, gcount = 0, bcount = 0, acount = 0;
                if (easy == 0)
                {
                    if (((mr == 0) || (mg == 0)) || (mb == 0))
                    {
                        CRuntime.Free(_out_);
                        stbi__err("bad masks");
                        return null;
                    }

                    rshift = (int)(stbi__high_bit((uint)(mr)) - 7);
                    rcount = (int)(stbi__bitcount((uint)(mr)));
                    gshift = (int)(stbi__high_bit((uint)(mg)) - 7);
                    gcount = (int)(stbi__bitcount((uint)(mg)));
                    bshift = (int)(stbi__high_bit((uint)(mb)) - 7);
                    bcount = (int)(stbi__bitcount((uint)(mb)));
                    ashift = (int)(stbi__high_bit((uint)(ma)) - 7);
                    acount = (int)(stbi__bitcount((uint)(ma)));
                }

                int z = 0;
                j = 0;
                if ((easy) != 0)
                {
                    byte a;
                    for (; j < ri.Height; ++j)
                    {
                        for (i = 0; (i) < ri.Width; ++i)
                        {
                            _out_[z++] = stbi__get8(s);
                            _out_[z++] = stbi__get8(s);
                            _out_[z++] = stbi__get8(s);

                            a = (byte)(easy == 2 ? stbi__get8(s) : 255);
                            all_a |= (uint)(a);
                            if (ri.OutComponents == (4))
                                _out_[z++] = (byte)(a);
                        }
                        stbi__skip(s, (int)(pad));
                    }
                }
                else
                {
                    uint v;
                    int a;
                    for (; j < ri.Height; ++j)
                    {
                        for (i = 0; (i) < ri.Width; ++i)
                        {
                            v = (uint)(info.bpp == 16 ? (uint)stbi__get16le(s) : stbi__get32le(s));
                            _out_[z++] = (byte)((stbi__shiftsigned((int)(v & mr), rshift, rcount)) & 255);
                            _out_[z++] = (byte)((stbi__shiftsigned((int)(v & mg), gshift, gcount)) & 255);
                            _out_[z++] = (byte)((stbi__shiftsigned((int)(v & mb), bshift, bcount)) & 255);

                            a = ma != 0 ? stbi__shiftsigned((int)(v & ma), ashift, acount) : 255;
                            all_a |= (uint)(a);
                            if (ri.OutComponents == (4))
                                _out_[z++] = (byte)(a & 255);
                        }
                        stbi__skip(s, (int)(pad));
                    }
                }
            }

            if ((ri.OutComponents == (4)) && ((all_a) == 0))
                for (i = (int)(4 * ri.Width * ri.Height - 1); (i) >= (0); i -= 4)
                    _out_[i] = 255;

            bool flip_vertically = ri.Height > 0;
            if (flip_vertically)
            {
                byte t;
                for (j = 0; (j) < ((int)(ri.Height) >> 1); ++j)
                {
                    byte* p1 = _out_ + j * ri.Width * ri.OutComponents;
                    byte* p2 = _out_ + (ri.Height - 1 - j) * ri.Width * ri.OutComponents;
                    for (i = 0; (i) < ((int)(ri.Width) * ri.OutComponents); ++i)
                    {
                        t = (byte)(p1[i]);
                        p1[i] = (byte)(p2[i]);
                        p2[i] = (byte)(t);
                    }
                }
            }

            IMemoryResult result = new HGlobalMemoryResult(_out_, ri.OutComponents * ri.Width * ri.Height);
            result = stbi__convert_format(result, ref ri);
            return result;
        }

        public static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, out int bitsPerComp)
        {
            bitsPerComp = 8;

            switch (bits_per_pixel)
            {
                case 8:
                    return (int)(STBI_grey);

                case 15:
                case 16:
                    if (((bits_per_pixel) == (16)) && ((is_grey) != 0))
                        return (int)(STBI_grey_alpha);

                    bitsPerComp = 16;
                    return (int)(STBI_rgb);

                case 24:
                case 32:
                    return (int)(bits_per_pixel / 8);

                default:
                    return 0;
            }
        }

        public static int stbi__tga_info(ReadContext s, ref ReadState ri)
        {
            stbi__get8(s);
            int colormap_type = (int)(stbi__get8(s));
            if ((colormap_type) > (1))
            {
                stbi__rewind(s);
                return 0;
            }

            int sz;
            int colormap_bpp;
            int image_type = (int)(stbi__get8(s));
            if ((colormap_type) == (1))
            {
                if ((image_type != 1) && (image_type != 9))
                {
                    stbi__rewind(s);
                    return 0;
                }

                stbi__skip(s, (int)(4));
                sz = (int)(stbi__get8(s));
                if (sz != 8 &&
                    sz != 15 &&
                    sz != 16 &&
                    sz != 24 &&
                    sz != 32)
                {
                    stbi__rewind(s);
                    return 0;
                }

                stbi__skip(s, (int)(4));
                colormap_bpp = (int)(sz);
            }
            else
            {
                if (image_type != 2 &&
                    image_type != 3 &&
                    image_type != 10 &&
                    image_type != 11)
                {
                    stbi__rewind(s);
                    return 0;
                }

                stbi__skip(s, (int)(9));
                colormap_bpp = 0;
            }

            ri.Width = (int)(stbi__get16le(s));
            if ((ri.Width) < (1))
            {
                stbi__rewind(s);
                return 0;
            }

            ri.Height = (int)(stbi__get16le(s));
            if ((ri.Height) < (1))
            {
                stbi__rewind(s);
                return 0;
            }

            int bpp = (int)(stbi__get8(s));
            stbi__get8(s);
            if (colormap_bpp != 0)
            {
                if (bpp != 8 &&
                    bpp != 16)
                {
                    stbi__rewind(s);
                    return 0;
                }
                ri.Components = (int)(stbi__tga_get_comp((int)(colormap_bpp), 0, out ri.Depth));
            }
            else
            {
                ri.Components = stbi__tga_get_comp(
                    bpp, image_type == 3 || image_type == 11 ? 1 : 0, out ri.Depth);
            }

            if (ri.Components == 0)
            {
                stbi__rewind(s);
                return 0;
            }

            ri.OutComponents = ri.Components;
            ri.OutDepth = ri.Depth;
            return 1;
        }

        public static int stbi__tga_test(ReadContext s)
        {
            int res = 0;
            stbi__get8(s);
            int color_type = (int)(stbi__get8(s));
            if ((color_type) > (1))
                goto ErrorEnd;

            int sz = (int)(stbi__get8(s));
            if ((color_type) == (1))
            {
                if ((sz != 1) && (sz != 9))
                    goto ErrorEnd;
                stbi__skip(s, (int)(4));
                sz = (int)(stbi__get8(s));
                if (((((sz != 8) && (sz != 15)) && (sz != 16)) && (sz != 24)) && (sz != 32))
                    goto ErrorEnd;
                stbi__skip(s, (int)(4));
            }
            else
            {
                if ((((sz != 2) && (sz != 3)) && (sz != 10)) && (sz != 11))
                    goto ErrorEnd;
                stbi__skip(s, (int)(9));
            }

            if ((stbi__get16le(s)) < (1))
                goto ErrorEnd;
            if ((stbi__get16le(s)) < (1))
                goto ErrorEnd;

            sz = (int)(stbi__get8(s));
            if ((((color_type) == (1)) && (sz != 8)) && (sz != 16))
                goto ErrorEnd;
            if (((((sz != 8) && (sz != 15)) && (sz != 16)) && (sz != 24)) && (sz != 32))
                goto ErrorEnd;

            res = 1;

            ErrorEnd:
            stbi__rewind(s);
            return (int)(res);
        }

        public static void stbi__tga_read_rgb16(ReadContext s, byte* _out_)
        {
            ushort px = (ushort)(stbi__get16le(s));
            ushort fiveBitMask = (ushort)(31);
            int r = (int)((px >> 10) & fiveBitMask);
            int g = (int)((px >> 5) & fiveBitMask);
            int b = (int)(px & fiveBitMask);
            _out_[0] = ((byte)((r * 255) / 31));
            _out_[1] = ((byte)((g * 255) / 31));
            _out_[2] = ((byte)((b * 255) / 31));
        }

        public static IMemoryResult stbi__tga_load(ReadContext s, ref ReadState ri)
        {
            int tga_offset = (int)(stbi__get8(s));
            int tga_indexed = (int)(stbi__get8(s));
            int tga_image_type = (int)(stbi__get8(s));
            int tga_is_RLE = 0;
            int tga_palette_start = (int)(stbi__get16le(s));
            int tga_palette_len = (int)(stbi__get16le(s));
            int tga_palette_bits = (int)(stbi__get8(s));
            int tga_x_origin = (int)(stbi__get16le(s));
            int tga_y_origin = (int)(stbi__get16le(s));
            ri.Width = (int)(stbi__get16le(s));
            ri.Height = (int)(stbi__get16le(s));
            int tga_bits_per_pixel = (int)(stbi__get8(s));
            int tga_inverted = (int)(stbi__get8(s));
            tga_inverted = (int)(1 - ((tga_inverted >> 5) & 1));

            if ((tga_image_type) >= (8))
            {
                tga_image_type -= (int)(8);
                tga_is_RLE = 1;
            }

            if ((tga_indexed) != 0)
                ri.Components = stbi__tga_get_comp(tga_palette_bits, 0, out ri.Depth);
            else
                ri.Components = stbi__tga_get_comp(tga_bits_per_pixel, tga_image_type == 3 ? 1 : 0, out ri.Depth);

            ri.OutComponents = ri.Components;
            ri.OutDepth = ri.Depth;

            if (ri.Components == 0)
            {
                stbi__err("bad format");
                return null;
            }

            if (stbi__mad3sizes_valid((int)(ri.Width), (int)(ri.Height), (int)(ri.OutComponents), 0) == 0)
            {
                stbi__err("too large");
                return null;
            }

            byte* _out_ = (byte*)(stbi__malloc_mad3((int)(ri.Width), (int)(ri.Height), (int)(ri.OutComponents), 0));
            if (_out_ == null)
            {
                stbi__err("outofmem");
                return null;
            }

            byte* raw_data = stackalloc byte[4];
            raw_data[0] = 0;

            int i;
            int j;
            stbi__skip(s, (int)(tga_offset));
            if (((tga_indexed == 0) && (tga_is_RLE == 0)) && ri.OutDepth == 8)
            {
                for (i = 0; (i) < (ri.Height); ++i)
                {
                    int row = (int)((tga_inverted) != 0 ? ri.Height - i - 1 : i);
                    byte* tga_row = _out_ + row * ri.Width * ri.OutComponents;
                    stbi__getn(s, tga_row, (int)(ri.Width * ri.OutComponents));
                }
            }
            else
            {
                byte* tga_palette = null;
                if ((tga_indexed) != 0)
                {
                    stbi__skip(s, (int)(tga_palette_start));
                    tga_palette = (byte*)(stbi__malloc_mad2((int)(tga_palette_len), (int)(ri.OutComponents), 0));
                    if (tga_palette == null)
                    {
                        CRuntime.Free(_out_);
                        stbi__err("outofmem");
                        return null;
                    }

                    if (ri.Depth == 16)
                    {
                        byte* pal_entry = tga_palette;
                        for (i = 0; (i) < (tga_palette_len); ++i)
                        {
                            stbi__tga_read_rgb16(s, pal_entry);
                            pal_entry += ri.OutComponents;
                        }
                    }
                    else if (stbi__getn(s, tga_palette, (int)(tga_palette_len * ri.OutComponents)) == 0)
                    {
                        CRuntime.Free(_out_);
                        CRuntime.Free(tga_palette);
                        stbi__err("bad palette");
                        return null;
                    }
                }

                int RLE_count = 0;
                int RLE_repeating = 0;
                int read_next_pixel = 1;

                for (i = 0; (i) < (ri.Width * ri.Height); ++i)
                {
                    if ((tga_is_RLE) != 0)
                    {
                        if ((RLE_count) == 0)
                        {
                            int RLE_cmd = (int)(stbi__get8(s));
                            RLE_count = (int)(1 + (RLE_cmd & 127));
                            RLE_repeating = (int)(RLE_cmd >> 7);
                            read_next_pixel = 1;
                        }
                        else if (RLE_repeating == 0)
                            read_next_pixel = 1;
                    }
                    else
                        read_next_pixel = 1;

                    if ((read_next_pixel) != 0)
                    {
                        if ((tga_indexed) != 0)
                        {
                            int pal_idx = (int)(((tga_bits_per_pixel) == (8)) ? stbi__get8(s) : stbi__get16le(s));
                            if ((pal_idx) >= (tga_palette_len))
                                pal_idx = 0;

                            pal_idx *= (int)(ri.OutComponents);
                            for (j = 0; (j) < (ri.OutComponents); ++j)
                                raw_data[j] = (byte)(tga_palette[pal_idx + j]);
                        }
                        else if (ri.OutDepth == 16)
                            stbi__tga_read_rgb16(s, raw_data);
                        else
                            for (j = 0; (j) < (ri.OutComponents); ++j)
                                raw_data[j] = (byte)(stbi__get8(s));

                        read_next_pixel = 0;
                    }

                    for (j = 0; (j) < (ri.OutComponents); ++j)
                        _out_[i * ri.OutComponents + j] = (byte)(raw_data[j]);

                    RLE_count--;
                }

                if ((tga_inverted) != 0)
                {
                    for (j = 0; (j * 2) < (ri.Height); ++j)
                    {
                        int index1 = (int)(j * ri.Width * ri.OutComponents);
                        int index2 = (int)((ri.Height - 1 - j) * ri.Width * ri.OutComponents);
                        for (i = (int)(ri.Width * ri.OutComponents); (i) > (0); --i)
                        {
                            byte temp = (byte)(_out_[index1]);
                            _out_[index1] = (byte)(_out_[index2]);
                            _out_[index2] = (byte)(temp);
                            ++index1;
                            ++index2;
                        }
                    }
                }

                if (tga_palette != null)
                    CRuntime.Free(tga_palette);
            }

            if (((ri.OutComponents) >= (3)) && ri.OutDepth == 8)
            {
                byte* tga_pixel = _out_;
                for (i = 0; (i) < (ri.Width * ri.Height); ++i)
                {
                    byte tmp = (byte)(tga_pixel[0]);
                    tga_pixel[0] = (byte)(tga_pixel[2]);
                    tga_pixel[2] = (byte)(tmp);
                    tga_pixel += ri.OutComponents;
                }
            }

            IMemoryResult result = new HGlobalMemoryResult(_out_, ri.OutComponents * ri.Width * ri.Height);
            result = stbi__convert_format(result, ref ri);
            return result;
        }

        public static int stbi__psd_test(ReadContext s)
        {
            int r = (((stbi__get32be(s)) == (0x38425053))) ? 1 : 0;
            stbi__rewind(s);
            return (int)(r);
        }

        public static int stbi__psd_decode_rle(ReadContext s, byte* p, int pixelCount)
        {
            int len;
            int nleft;
            int count = 0;
            while ((nleft = (int)(pixelCount - count)) > (0))
            {
                len = (int)(stbi__get8(s));
                if ((len) == (128))
                {
                }
                else if ((len) < (128))
                {
                    len++;
                    if ((len) > (nleft))
                        return 0;

                    count += (int)(len);
                    while ((len) != 0)
                    {
                        *p = (byte)(stbi__get8(s));
                        p += 4;
                        len--;
                    }
                }
                else if ((len) > (128))
                {
                    len = (int)(257 - len);
                    if ((len) > (nleft))
                        return 0;

                    int val = (byte)(stbi__get8(s));
                    count += (int)(len);
                    while ((len) != 0)
                    {
                        *p = (byte)(val);
                        p += 4;
                        len--;
                    }
                }
            }

            return 1;
        }

        public static IMemoryResult stbi__psd_load(ReadContext s, ref ReadState ri)
        {
            if (stbi__get32be(s) != 0x38425053)
            {
                stbi__err("not PSD");
                return null;
            }
            if (stbi__get16be(s) != 1)
            {
                stbi__err("wrong version");
                return null;
            }

            stbi__skip(s, (int)(6));
            int channelCount = (int)(stbi__get16be(s));
            if (((channelCount) < (0)) || ((channelCount) > (16)))
            {
                stbi__err("wrong channel count");
                return null;
            }

            int h = (int)(stbi__get32be(s));
            int w = (int)(stbi__get32be(s));
            ri.Depth = (int)(stbi__get16be(s));
            if ((ri.Depth != 8) && (ri.Depth != 16))
            {
                stbi__err("unsupported bit depth");
                return null;
            }
            if (stbi__get16be(s) != 3)
            {
                stbi__err("wrong color format");
                return null;
            }

            stbi__skip(s, (int)(stbi__get32be(s)));
            stbi__skip(s, (int)(stbi__get32be(s)));
            stbi__skip(s, (int)(stbi__get32be(s)));
            int compression = (int)(stbi__get16be(s));
            if ((compression) > (1))
            {
                stbi__err("bad compression");
                return null;
            }
            if (stbi__mad3sizes_valid((int)(4), (int)(w), (int)(h), 0) == 0)
            {
                stbi__err("too large");
                return null;
            }

            byte* _out_;
            if (compression == 0 && ri.Depth == 16 && ri.RequestedDepth == ri.Depth)
            {
                _out_ = (byte*)(stbi__malloc_mad3(8, w, h, 0));
                ri.OutDepth = 16;
            }
            else
            {
                _out_ = (byte*)(CRuntime.MAlloc(4 * w * h));
                ri.OutDepth = ri.RequestedDepth ?? 8;
            }

            if (_out_ == null)
            {
                stbi__err("outofmem");
                return null;
            }

            int i;
            int pixelCount = (int)(w * h);
            if ((compression) != 0)
            {
                stbi__skip(s, (int)(h * channelCount * 2));
                for (int channel = 0; (channel) < (4); channel++)
                {
                    byte* p;
                    p = _out_ + channel;
                    if ((channel) >= (channelCount))
                    {
                        for (i = 0; (i) < (pixelCount); i++, p += 4)
                            *p = (byte)((channel) == (3) ? 255 : 0);
                    }
                    else
                    {
                        if (stbi__psd_decode_rle(s, p, (int)(pixelCount)) == 0)
                        {
                            CRuntime.Free(_out_);
                            stbi__err("corrupt");
                            return null;
                        }
                    }
                }
            }
            else
            {
                for (int channel = 0; (channel) < (4); channel++)
                {
                    if ((channel) >= (channelCount))
                    {
                        if (ri.Depth == 16 && ri.RequestedDepth == ri.Depth)
                        {
                            ushort* q = ((ushort*)(_out_)) + channel;
                            ushort val = (ushort)((channel) == (3) ? 65535 : 0);
                            for (i = 0; (i) < (pixelCount); i++, q += 4)
                                *q = (ushort)(val);
                        }
                        else
                        {
                            byte* p = _out_ + channel;
                            byte val = (byte)((channel) == (3) ? 255 : 0);
                            for (i = 0; (i) < (pixelCount); i++, p += 4)
                                *p = (byte)(val);
                        }
                    }
                    else
                    {
                        if ((ri.OutDepth) == (16))
                        {
                            ushort* q = ((ushort*)(_out_)) + channel;
                            for (i = 0; (i) < (pixelCount); i++, q += 4)
                                *q = ((ushort)(stbi__get16be(s)));
                        }
                        else
                        {
                            byte* p = _out_ + channel;
                            if ((ri.OutDepth) == (16))
                            {
                                for (i = 0; (i) < (pixelCount); i++, p += 4)
                                    *p = ((byte)(stbi__get16be(s) >> 8));
                            }
                            else
                            {
                                for (i = 0; (i) < (pixelCount); i++, p += 4)
                                    *p = (byte)(stbi__get8(s));
                            }
                        }
                    }
                }
            }

            if ((channelCount) >= (4))
            {
                if ((ri.OutDepth) == (16))
                {
                    for (i = 0; (i) < (w * h); ++i)
                    {
                        ushort* pixel = (ushort*)(_out_) + 4 * i;
                        if ((pixel[3] != 0) && (pixel[3] != 65535))
                        {
                            float a = (float)(pixel[3] / 65535.0f);
                            float ra = (float)(1f / a);
                            float inv_a = (float)(65535.0f * (1 - ra));
                            pixel[0] = ((ushort)(pixel[0] * ra + inv_a));
                            pixel[1] = ((ushort)(pixel[1] * ra + inv_a));
                            pixel[2] = ((ushort)(pixel[2] * ra + inv_a));
                        }
                    }
                }
                else
                {
                    for (i = 0; (i) < (w * h); ++i)
                    {
                        byte* pixel = _out_ + 4 * i;
                        if ((pixel[3] != 0) && (pixel[3] != 255))
                        {
                            float a = (float)(pixel[3] / 255f);
                            float ra = (float)(1f / a);
                            float inv_a = (float)(255f * (1 - ra));
                            pixel[0] = ((byte)(pixel[0] * ra + inv_a));
                            pixel[1] = ((byte)(pixel[1] * ra + inv_a));
                            pixel[2] = ((byte)(pixel[2] * ra + inv_a));
                        }
                    }
                }
            }

            IMemoryResult result = new HGlobalMemoryResult(_out_, ri.Width * ri.Height * ri.OutComponents);
            result = stbi__convert_format(result, ref ri);

            return result;
        }

        public static int stbi__gif_test_raw(ReadContext s)
        {
            if (stbi__get8(s) != 'G' ||
                stbi__get8(s) != 'I' ||
                stbi__get8(s) != 'F' ||
                stbi__get8(s) != '8')
                return 0;

            int sz = (int)(stbi__get8(s));
            if (sz != '9' && sz != '7')
                return 0;

            if (stbi__get8(s) != 'a')
                return 0;

            return 1;
        }

        public static int stbi__gif_test(ReadContext s)
        {
            int r = (int)(stbi__gif_test_raw(s));
            stbi__rewind(s);
            return (int)(r);
        }

        public static int stbi__gif_header(
            ReadContext s, ref GifContext g, ref ReadState ri, bool skipColorTable)
        {
            byte version;
            if ((((stbi__get8(s) != 'G') || (stbi__get8(s) != 'I')) || (stbi__get8(s) != 'F')) ||
                (stbi__get8(s) != '8'))
                return (int)(stbi__err("not GIF"));
            version = (byte)(stbi__get8(s));
            if ((version != '7') && (version != '9'))
                return (int)(stbi__err("not GIF"));
            if (stbi__get8(s) != 'a')
                return (int)(stbi__err("not GIF"));

            ri.Width = (int)(stbi__get16le(s));
            ri.Height = (int)(stbi__get16le(s));
            ri.Components = 4;

            g.flags = (int)(stbi__get8(s));
            g.bgindex = (int)(stbi__get8(s));
            g.ratio = (int)(stbi__get8(s));
            g.transparent = -1;
            if (skipColorTable)
                return 1;

            if ((g.flags & 0x80) != 0)
                stbi__gif_parse_colortable(s, ref ri, g.pal, (int)(2 << (g.flags & 7)), -1);
            return 1;
        }

        public static void stbi__out_gif_code(ref GifContext g, ushort code)
        {
            byte* p;
            byte* c;
            if ((g.codes[code].prefix) >= (0))
                stbi__out_gif_code(ref g, (ushort)(g.codes[code].prefix));
            if ((g.cur_y) >= (g.max_y))
                return;

            p = &g._out_[g.cur_x + g.cur_y];
            c = &g.color_table[g.codes[code].suffix * 4];
            if ((c[3]) >= (128))
            {
                p[0] = (byte)(c[2]);
                p[1] = (byte)(c[1]);
                p[2] = (byte)(c[0]);
                p[3] = (byte)(c[3]);
            }

            g.cur_x += (int)(4);
            if ((g.cur_x) >= (g.max_x))
            {
                g.cur_x = (int)(g.start_x);
                g.cur_y += (int)(g.step);
                while (((g.cur_y) >= (g.max_y)) && ((g.parse) > (0)))
                {
                    g.step = (int)((1 << g.parse) * g.line_size);
                    g.cur_y = (int)(g.start_y + (g.step >> 1));
                    --g.parse;
                }
            }

        }

        public static IMemoryResult stbi__process_gif_raster(
            ReadContext s, ref GifContext g, ref ReadState ri)
        {
            byte lzw_cs = (byte)(stbi__get8(s));
            if ((lzw_cs) > (12))
                return null;

            int clear = (int)(1 << lzw_cs);
            uint first = (uint)(1);
            int codesize = (int)(lzw_cs + 1);
            int codemask = (int)((1 << codesize) - 1);
            int bits = 0;
            int valid_bits = 0;
            for (int init_code = 0; (init_code) < (clear); init_code++)
            {
                (g.codes)[init_code].prefix = (short)(-1);
                (g.codes)[init_code].first = ((byte)(init_code));
                (g.codes)[init_code].suffix = ((byte)(init_code));
            }

            GifLzw* p;
            int avail = (int)(clear + 2);
            int oldcode = -1;
            int len = 0;
            for (; ; )
            {
                if ((valid_bits) < (codesize))
                {
                    if ((len) == 0)
                    {
                        len = (int)(stbi__get8(s));
                        if ((len) == 0)
                            return new HGlobalMemoryResult(g._out_, ri.Width * ri.Height * ri.OutComponents);
                    }

                    len--;
                    bits |= (int)((int)(stbi__get8(s)) << valid_bits);
                    valid_bits += (int)(8);
                }
                else
                {
                    int code = (int)(bits & codemask);
                    bits >>= codesize;
                    valid_bits -= (int)(codesize);
                    if ((code) == (clear))
                    {
                        codesize = (int)(lzw_cs + 1);
                        codemask = (int)((1 << codesize) - 1);
                        avail = (int)(clear + 2);
                        oldcode = -1;
                        first = (uint)(0);
                    }
                    else if ((code) == (clear + 1))
                    {
                        stbi__skip(s, (int)(len));
                        while ((len = (int)(stbi__get8(s))) > (0))
                            stbi__skip(s, (int)(len));

                        return new HGlobalMemoryResult(g._out_, ri.Width * ri.Height * ri.OutComponents);
                    }
                    else if (code <= avail)
                    {
                        if ((first) != 0)
                            stbi__err("no clear code");
                        if ((oldcode) >= (0))
                        {
                            p = (GifLzw*)g.codes + avail++;
                            if ((avail) > (4096))
                                stbi__err("too many codes");

                            p->prefix = ((short)(oldcode));
                            p->first = (byte)(g.codes[oldcode].first);
                            p->suffix = (byte)(((code) == (avail)) ? p->first : g.codes[code].first);
                        }
                        else if ((code) == (avail))
                        {
                            stbi__err("illegal code in raster");
                            return null;
                        }

                        stbi__out_gif_code(ref g, (ushort)(code));
                        if (((avail & codemask) == 0) && (avail <= 0x0FFF))
                        {
                            codesize++;
                            codemask = (int)((1 << codesize) - 1);
                        }

                        oldcode = (int)(code);
                    }
                    else
                    {
                        stbi__err("illegal code in raster");
                        return null;
                    }
                }
            }
        }

        public static void stbi__fill_gif_background(
            ref GifContext g, ref ReadState ri, int x0, int y0, int x1, int y1)
        {
            byte* c = (byte*)g.pal + g.bgindex;
            for (int y = (int)(y0); (y) < (y1); y += (int)(ri.OutComponents * ri.Width))
            {
                for (int x = (int)(x0); (x) < (x1); x += ri.OutComponents)
                {
                    byte* p = &g._out_[y + x];
                    p[0] = (byte)(c[2]);
                    p[1] = (byte)(c[1]);
                    p[2] = (byte)(c[0]);
                    p[3] = 0;
                }
            }
        }

        public static void stbi__gif_parse_colortable(
            ReadContext s, ref ReadState ri, byte* pal, int num_entries, int transp)
        {
            for (int i = 0; (i) < (num_entries); ++i)
            {
                pal[i * ri.OutComponents + 3] = (byte)(transp == i ? 0 : 255);
                pal[i * ri.OutComponents + 2] = stbi__get8(s);
                pal[i * ri.OutComponents + 1] = stbi__get8(s);
                pal[i * ri.OutComponents] = stbi__get8(s);
            }
        }

        public static IMemoryResult stbi__gif_load_next(
            ReadContext s, ref GifContext g, ref ReadState ri, byte* two_back)
        {
            int dispose = 0;
            int first_frame = 0;
            int pi = 0;
            int pcount = 0;

            if ((g._out_) == null)
            {
                if (stbi__gif_header(s, ref g, ref ri, skipColorTable: false) == 0)
                    return null;

                ri.OutComponents = ri.Components;

                if (stbi__mad3sizes_valid(ri.OutComponents, ri.Width, ri.Height, 0) == 0)
                {
                    stbi__err("too large");
                    return null;
                }

                pcount = (int)(ri.Width * ri.Height);
                g._out_ = (byte*)(CRuntime.MAlloc(ri.OutComponents * pcount));
                g.background = (byte*)(CRuntime.MAlloc(ri.OutComponents * pcount));
                g.history = (byte*)(CRuntime.MAlloc(pcount));
                if (((g._out_ == null) || (g.background == null)) || (g.history == null))
                {
                    stbi__err("outofmem");
                    return null;
                }

                CRuntime.MemSet(g._out_, 0, ri.OutComponents * pcount);
                CRuntime.MemSet(g.background, 0, ri.OutComponents * pcount);
                CRuntime.MemSet(g.history, 0, pcount);
                first_frame = 1;
            }
            else
            {
                dispose = (int)((g.eflags & 0x1C) >> 2);
                pcount = (int)(ri.Width * ri.Height);
                if (((dispose) == (3)) && ((two_back) == null))
                    dispose = (int)2;

                if ((dispose) == (3))
                {
                    for (pi = 0; (pi) < (pcount); ++pi)
                    {
                        if ((g.history[pi]) != 0)
                            CRuntime.MemCopy(
                                &g._out_[pi * ri.OutComponents], &two_back[pi * ri.OutComponents], ri.OutComponents);
                    }
                }
                else if ((dispose) == 2)
                {
                    for (pi = 0; (pi) < (pcount); ++pi)
                    {
                        if ((g.history[pi]) != 0)
                            CRuntime.MemCopy(
                                &g._out_[pi * ri.OutComponents], &g.background[pi * ri.OutComponents], ri.OutComponents);
                    }
                }
                CRuntime.MemCopy(g.background, g._out_, ri.OutComponents * pcount);
            }

            CRuntime.MemSet(g.history, 0, pcount);
            for (; ; )
            {
                int tag = (int)(stbi__get8(s));
                switch (tag)
                {
                    case 0x2C:
                    {
                        int x = (int)(stbi__get16le(s));
                        int y = (int)(stbi__get16le(s));
                        int w = (int)(stbi__get16le(s));
                        int h = (int)(stbi__get16le(s));
                        if (((x + w) > ri.Width) || ((y + h) > (ri.Height)))
                        {
                            stbi__err("bad image descriptor");
                            return null;
                        }

                        g.line_size = (int)(ri.Width * ri.OutComponents);
                        g.start_x = (int)(x * ri.OutComponents);
                        g.start_y = (int)(y * g.line_size);
                        g.max_x = (int)(g.start_x + w * ri.OutComponents);
                        g.max_y = (int)(g.start_y + h * g.line_size);
                        g.cur_x = (int)(g.start_x);
                        g.cur_y = (int)(g.start_y);
                        if ((w) == 0)
                            g.cur_y = (int)(g.max_y);
                        g.lflags = (int)(stbi__get8(s));

                        if ((g.lflags & 0x40) != 0)
                        {
                            g.step = (int)(8 * g.line_size);
                            g.parse = (int)(3);
                        }
                        else
                        {
                            g.step = (int)(g.line_size);
                            g.parse = 0;
                        }
                        if ((g.lflags & 0x80) != 0)
                        {
                            stbi__gif_parse_colortable(
                                s,
                                ref ri,
                                g.lpal,
                                (int)(2 << (g.lflags & 7)),
                                (int)((g.eflags & 0x01) != 0 ? g.transparent : -1));

                            g.color_table = (byte*)(g.lpal);
                        }
                        else if ((g.flags & 0x80) != 0)
                        {
                            g.color_table = (byte*)(g.pal);
                        }
                        else
                        {
                            stbi__err("missing color table");
                            return null;
                        }

                        var o = stbi__process_gif_raster(s, ref g, ref ri);
                        if (o == null)
                            return null;

                        pcount = (int)(ri.Width * ri.Height);
                        if (((first_frame) != 0) && ((g.bgindex) > (0)))
                        {
                            for (pi = 0; (pi) < (pcount); ++pi)
                            {
                                if ((g.history[pi]) == 0)
                                {
                                    g.pal[g.bgindex * ri.OutComponents + 3] = 255;
                                    CRuntime.MemCopy(
                                        &g._out_[pi * ri.OutComponents], &g.pal[g.bgindex], ri.OutComponents);
                                }
                            }
                        }
                        return o;
                    }

                    case 0x21:
                    {
                        int block_len = 0;
                        int ext = (int)(stbi__get8(s));
                        if ((ext) == (0xF9))
                        {
                            block_len = (int)(stbi__get8(s));
                            if ((block_len) == (4))
                            {
                                g.eflags = (int)(stbi__get8(s));
                                g.delay = (int)(10 * stbi__get16le(s));
                                if ((g.transparent) >= (0))
                                    g.pal[g.transparent * ri.OutComponents + 3] = 255;

                                if ((g.eflags & 0x01) != 0)
                                {
                                    g.transparent = (int)(stbi__get8(s));
                                    if ((g.transparent) >= (0))
                                        g.pal[g.transparent * ri.OutComponents + 3] = 0;
                                }
                                else
                                {
                                    stbi__skip(s, 1);
                                    g.transparent = -1;
                                }
                            }
                            else
                            {
                                stbi__skip(s, (int)(block_len));
                                break;
                            }
                        }
                        while ((block_len = (int)(stbi__get8(s))) != 0)
                            stbi__skip(s, (int)(block_len));
                        break;
                    }

                    case 0x3B:
                        return null;

                    default:
                        stbi__err("unknown code");
                        return null;
                }
            }
        }

        public static IMemoryResult stbi__load_gif_main(
            ReadContext s, out List<int> delays, out int layers, ref ReadState ri)
        {
            layers = 0;
            delays = null;

            if (stbi__gif_test(s) != 0)
            {
                IMemoryResult u = null;
                byte* _out_ = null;
                byte* two_back = null;
                int stride = 0;
                delays = new List<int>();

                var g = GifContext.Create();
                try
                {
                    {
                        do
                        {
                            u = stbi__gif_load_next(s, ref g, ref ri, two_back);
                            if (u == null)
                                break;

                            layers++;
                            stride = (int)(ri.Width * ri.Height * 4);

                            _out_ = _out_ != null
                                ? (byte*)(CRuntime.ReAlloc(_out_, layers * stride))
                                : (byte*)(CRuntime.MAlloc(layers * stride));
                            CRuntime.MemCopy(_out_ + ((layers - 1) * stride), (byte*)u.Pointer, stride);

                            if ((layers) >= 2)
                                two_back = _out_ - 2 * stride;

                            delays[layers - 1] = g.delay;
                        }
                        while (u != null);

                        CRuntime.Free(g._out_);
                        CRuntime.Free(g.history);
                        CRuntime.Free(g.background);

                        IMemoryResult result = new HGlobalMemoryResult(_out_, layers * stride);

                        if (ri.RequestedComponents.HasValue && ri.RequestedComponents != ri.OutComponents)
                            result = stbi__convert_format8(
                                result, ri.OutComponents, ri.RequestedComponents.Value, (layers * ri.Width), ri.Height);

                        return result;
                    }
                }
                finally
                {
                    g.Dispose();
                }
            }
            else
            {
                stbi__err("not GIF");
                return null;
            }
        }

        public static IMemoryResult stbi__gif_load(ReadContext s, ref ReadState ri)
        {
            var g = GifContext.Create();
            try
            {
                IMemoryResult u = stbi__gif_load_next(s, ref g, ref ri, null);
                if ((u) != null)
                {
                    if (ri.RequestedComponents.HasValue && ri.RequestedComponents != 4)
                        u = stbi__convert_format8(
                            u, ri.OutComponents, ri.RequestedComponents.Value, ri.Width, ri.Height);
                }
                else if ((g._out_) != null)
                {
                    CRuntime.Free(g._out_);
                }
                return u;
            }
            finally
            {
                g.Dispose();
            }
        }

        public static int stbi__gif_info(ReadContext s, out ReadState ri)
        {
            var g = GifContext.Create();
            try
            {
                ri = new ReadState();
                if (stbi__gif_header(s, ref g, ref ri, skipColorTable: true) == 0)
                {
                    stbi__rewind(s);
                    return 0;
                }
                return 1;
            }
            finally
            {
                g.Dispose();
            }
        }

        public static bool stbi__bmp_info(ReadContext s, out ReadState ri)
        {
            var info = new BmpInfo();
            info.all_a = (uint)(255);

            ri = new ReadState();
            bool success = stbi__bmp_parse_header(s, ref info, ref ri);
            stbi__rewind(s);
            return success;
        }

        public static int stbi__psd_info(ReadContext s, out int width, out int height, out int comp)
        {
            width = default;
            height = default;
            comp = default;

            if (stbi__get32be(s) != 0x38425053)
            {
                stbi__rewind(s);
                return 0;
            }

            if (stbi__get16be(s) != 1)
            {
                stbi__rewind(s);
                return 0;
            }

            stbi__skip(s, (int)(6));
            int channelCount = (int)(stbi__get16be(s));
            if (((channelCount) < (0)) || ((channelCount) > (16)))
            {
                stbi__rewind(s);
                return 0;
            }

            height = (int)(stbi__get32be(s));
            width = (int)(stbi__get32be(s));
            if (stbi__get16be(s) != 8)
            {
                stbi__rewind(s);
                return 0;
            }

            if (stbi__get16be(s) != 3)
            {
                stbi__rewind(s);
                return 0;
            }

            comp = (int)(4);
            return 1;
        }

        /*
        public static int stbi__info_main(ReadContext s, int* x, int* y, int* comp)
        {
            if ((stbi__jpeg_info(s, x, y, comp)) != 0)
                return 1;
            if ((stbi__png_info(s, x, y, comp)) != 0)
                return 1;
            if ((stbi__gif_info(s, x, y, comp)) != 0)
                return 1;
            if ((stbi__bmp_info(s, x, y, comp)) != 0)
                return 1;
            if ((stbi__psd_info(s, x, y, comp)) != 0)
                return 1;
            if ((stbi__tga_info(s, x, y, comp)) != 0)
                return 1;
            return (int)(stbi__err("unknown image type"));
        }

        public static int stbi_info_from_memory(byte* buffer, int len, int* x, int* y, int* comp)
        {
            ReadContext s = new ReadContext();
            stbi__start_mem(s, buffer, (int)(len));
            return (int)(stbi__info_main(s, x, y, comp));
        }

        public static int stbi_info_from_callbacks(
            stbi_io_callbacks c, Stream stream, byte[] buffer, int* x, int* y, int* comp)
        {
            ReadContext s = new ReadContext();
            stbi__start_callbacks(s, c, stream, buffer);
            return (int)(stbi__info_main(s, x, y, comp));
        }
        */
    }
}